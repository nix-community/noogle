[
  {
    "url": "/f/builtins/dirOf.html",
    "content": "builtins.dirOf Primop. Takes 1 arguments. s. Return the directory part of the string s, that is, everything before the final slash in the string. This is similar to the GNU dirname command.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.dirOf Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.dirOf Primop. Takes 1 arguments. s. Return the directory part of the string s, that is, everything before the final slash in the string. This is similar to the GNU dirname command.",
    "raw_url": "/f/builtins/dirOf.html",
    "excerpt": "builtins.dirOf Primop. Takes 1 arguments. s. Return the directory part of the string s, that is, everything before the final slash in the string. This is similar to the GNU",
    "sub_results": []
  },
  {
    "url": "/f/builtins/genList.html",
    "content": "builtins.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x * x) 5 returns the list [ 0 1 4 9 16 ]. Noogle also knows. Aliases. lib.genList. lib.lists.genList. lib.strings.genList.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.genList Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x * x) 5 returns the list [ 0 1 4 9 16 ]. Noogle also knows. Aliases. lib.genList. lib.lists.genList. lib.strings.genList.",
    "raw_url": "/f/builtins/genList.html",
    "excerpt": "builtins.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x *",
    "sub_results": []
  },
  {
    "url": "/f/builtins/toJSON.html",
    "content": "builtins.toJSON Primop. Takes 1 arguments. e. Return a string containing a JSON representation of e. Strings, integers, floats, booleans, nulls and lists are mapped to their JSON equivalents. Sets (except derivations) are represented as objects. Derivations are translated to a JSON string containing the derivation’s output path. Paths are copied to the store and represented as a JSON string of the resulting store path. Noogle also knows. Aliases. lib.strings.toJSON.",
    "word_count": 69,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.toJSON Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.toJSON Primop. Takes 1 arguments. e. Return a string containing a JSON representation of e. Strings, integers, floats, booleans, nulls and lists are mapped to their JSON equivalents. Sets (except derivations) are represented as objects. Derivations are translated to a JSON string containing the derivation’s output path. Paths are copied to the store and represented as a JSON string of the resulting store path. Noogle also knows. Aliases. lib.strings.toJSON.",
    "raw_url": "/f/builtins/toJSON.html",
    "excerpt": "builtins.toJSON Primop. Takes 1 arguments. e. Return a string containing a JSON representation of e. Strings, integers, floats, booleans, nulls and lists are mapped to their JSON equivalents. Sets (except",
    "sub_results": []
  },
  {
    "url": "/f/builtins/storePath.html",
    "content": "builtins.storePath Primop. Takes 1 arguments. path. This function allows you to define a dependency on an already existing store path. For example, the derivation attribute src = builtins.storePath /nix/store/f1d18v1y…-source causes the derivation to depend on the specified path, which must exist or be substitutable. Note that this differs from a plain path (e.g. src = /nix/store/f1d18v1y…-source) in that the latter causes the path to be copied again to the Nix store, resulting in a new path (e.g. /nix/store/ld01dnzc…-source-source). Not available in pure evaluation mode. See also builtins.fetchClosure.",
    "word_count": 87,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.storePath Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.storePath Primop. Takes 1 arguments. path. This function allows you to define a dependency on an already existing store path. For example, the derivation attribute src = builtins.storePath /nix/store/f1d18v1y…-source causes the derivation to depend on the specified path, which must exist or be substitutable. Note that this differs from a plain path (e.g. src = /nix/store/f1d18v1y…-source) in that the latter causes the path to be copied again to the Nix store, resulting in a new path (e.g. /nix/store/ld01dnzc…-source-source). Not available in pure evaluation mode. See also builtins.fetchClosure.",
    "raw_url": "/f/builtins/storePath.html",
    "excerpt": "builtins.storePath Primop. Takes 1 arguments. path. This function allows you to define a dependency on an already existing store path. For example, the derivation attribute src = builtins.storePath /nix/store/f1d18v1y…-source causes",
    "sub_results": []
  },
  {
    "url": "/f/builtins/hasContext.html",
    "content": "builtins.hasContext Primop. Takes 1 arguments. s. Return true if string s has a non-empty context. The context can be obtained with getContext. Noogle also knows. Aliases. lib.pathHasContext. lib.sources.pathHasContext.",
    "word_count": 28,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.hasContext Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.hasContext Primop. Takes 1 arguments. s. Return true if string s has a non-empty context. The context can be obtained with getContext. Noogle also knows. Aliases. lib.pathHasContext. lib.sources.pathHasContext.",
    "raw_url": "/f/builtins/hasContext.html",
    "excerpt": "builtins.hasContext Primop. Takes 1 arguments. s. Return true if string s has a non-empty context. The context can be obtained with getContext. Noogle also knows. Aliases. lib.pathHasContext. lib.sources.pathHasContext.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/split.html",
    "content": "builtins.split Primop. Takes 2 arguments. regex, str. Returns a list composed of non matched strings interleaved with the lists of the extended POSIX regular expression regex matches of str. Each item in the lists of matched sequences is a regex group. builtins.split \"(a)b\" \"abc\" Evaluates to [ \"\" [ \"a\" ] \"c\" ]. builtins.split \"([ac])\" \"abc\" Evaluates to [ \"\" [ \"a\" ] \"b\" [ \"c\" ] \"\" ]. builtins.split \"(a)|(c)\" \"abc\" Evaluates to [ \"\" [ \"a\" null ] \"b\" [ null \"c\" ] \"\" ]. builtins.split \"([[:upper:]]+)\" \" FOO \" Evaluates to [ \" \" [ \"FOO\" ] \" \" ]. Noogle also knows. Aliases. lib.strings.split.",
    "word_count": 108,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.split Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.split Primop. Takes 2 arguments. regex, str. Returns a list composed of non matched strings interleaved with the lists of the extended POSIX regular expression regex matches of str. Each item in the lists of matched sequences is a regex group. builtins.split \"(a)b\" \"abc\" Evaluates to [ \"\" [ \"a\" ] \"c\" ]. builtins.split \"([ac])\" \"abc\" Evaluates to [ \"\" [ \"a\" ] \"b\" [ \"c\" ] \"\" ]. builtins.split \"(a)|(c)\" \"abc\" Evaluates to [ \"\" [ \"a\" null ] \"b\" [ null \"c\" ] \"\" ]. builtins.split \"([[:upper:]]+)\" \" FOO \" Evaluates to [ \" \" [ \"FOO\" ] \" \" ]. Noogle also knows. Aliases. lib.strings.split.",
    "raw_url": "/f/builtins/split.html",
    "excerpt": "builtins.split Primop. Takes 2 arguments. regex, str. Returns a list composed of non matched strings interleaved with the lists of the extended POSIX regular expression regex matches of str. Each",
    "sub_results": []
  },
  {
    "url": "/f/builtins/listToAttrs.html",
    "content": "builtins.listToAttrs Primop. Takes 1 arguments. e. Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting of a string-valued attribute name specifying the name of the attribute, and an attribute value specifying its value. In case of duplicate occurrences of the same name, the first takes precedence. Example: builtins.listToAttrs [ { name = \"foo\"; value = 123; } { name = \"bar\"; value = 456; } { name = \"bar\"; value = 420; } ] evaluates to. { foo = 123; bar = 456; } Noogle also knows. Aliases. lib.listToAttrs. lib.attrsets.listToAttrs.",
    "word_count": 105,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.listToAttrs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.listToAttrs Primop. Takes 1 arguments. e. Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting of a string-valued attribute name specifying the name of the attribute, and an attribute value specifying its value. In case of duplicate occurrences of the same name, the first takes precedence. Example: builtins.listToAttrs [ { name = \"foo\"; value = 123; } { name = \"bar\"; value = 456; } { name = \"bar\"; value = 420; } ] evaluates to. { foo = 123; bar = 456; } Noogle also knows. Aliases. lib.listToAttrs. lib.attrsets.listToAttrs.",
    "raw_url": "/f/builtins/listToAttrs.html",
    "excerpt": "builtins.listToAttrs Primop. Takes 1 arguments. e. Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting",
    "sub_results": []
  },
  {
    "url": "/f/builtins/traceVerbose.html",
    "content": "builtins.traceVerbose Primop. Takes 2 arguments. e1, e2. Evaluate e1 and print its abstract syntax representation on standard error if --trace-verbose is enabled. Then return e2. This function is useful for debugging.",
    "word_count": 31,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.traceVerbose Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.traceVerbose Primop. Takes 2 arguments. e1, e2. Evaluate e1 and print its abstract syntax representation on standard error if --trace-verbose is enabled. Then return e2. This function is useful for debugging.",
    "raw_url": "/f/builtins/traceVerbose.html",
    "excerpt": "builtins.traceVerbose Primop. Takes 2 arguments. e1, e2. Evaluate e1 and print its abstract syntax representation on standard error if --trace-verbose is enabled. Then return e2. This function is useful for",
    "sub_results": []
  },
  {
    "url": "/f/builtins/removeAttrs.html",
    "content": "builtins.removeAttrs Primop. Takes 2 arguments. set, list. Remove the attributes listed in list from set. The attributes don’t have to exist in set. For instance, removeAttrs { x = 1; y = 2; z = 3; } [ \"a\" \"x\" \"z\" ] evaluates to { y = 2; }. Noogle also knows. Aliases. lib.attrsets.removeAttrs.",
    "word_count": 54,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.removeAttrs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.removeAttrs Primop. Takes 2 arguments. set, list. Remove the attributes listed in list from set. The attributes don’t have to exist in set. For instance, removeAttrs { x = 1; y = 2; z = 3; } [ \"a\" \"x\" \"z\" ] evaluates to { y = 2; }. Noogle also knows. Aliases. lib.attrsets.removeAttrs.",
    "raw_url": "/f/builtins/removeAttrs.html",
    "excerpt": "builtins.removeAttrs Primop. Takes 2 arguments. set, list. Remove the attributes listed in list from set. The attributes don’t have to exist in set. For instance, removeAttrs { x = 1;",
    "sub_results": []
  },
  {
    "url": "/f/builtins/getEnv.html",
    "content": "builtins.getEnv Primop. Takes 1 arguments. s. getEnv returns the value of the environment variable s, or an empty string if the variable doesn’t exist. This function should be used with care, as it can introduce all sorts of nasty environment dependencies in your Nix expression. getEnv is used in Nix Packages to locate the file ~/.nixpkgs/config.nix, which contains user-local settings for Nix Packages. (That is, it does a getEnv \"HOME\" to locate the user’s home directory.).",
    "word_count": 76,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.getEnv Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.getEnv Primop. Takes 1 arguments. s. getEnv returns the value of the environment variable s, or an empty string if the variable doesn’t exist. This function should be used with care, as it can introduce all sorts of nasty environment dependencies in your Nix expression. getEnv is used in Nix Packages to locate the file ~/.nixpkgs/config.nix, which contains user-local settings for Nix Packages. (That is, it does a getEnv \"HOME\" to locate the user’s home directory.).",
    "raw_url": "/f/builtins/getEnv.html",
    "excerpt": "builtins.getEnv Primop. Takes 1 arguments. s. getEnv returns the value of the environment variable s, or an empty string if the variable doesn’t exist. This function should be used with",
    "sub_results": []
  },
  {
    "url": "/f/builtins/appendContext.html",
    "content": "builtins.appendContext Primop. Takes 2 arguments.",
    "word_count": 5,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.appendContext Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.appendContext Primop. Takes 2 arguments.",
    "raw_url": "/f/builtins/appendContext.html",
    "excerpt": "builtins.appendContext Primop. Takes 2 arguments.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/div.html",
    "content": "builtins.div Primop. Takes 2 arguments. e1, e2. Return the quotient of the numbers e1 and e2.",
    "word_count": 16,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.div Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.div Primop. Takes 2 arguments. e1, e2. Return the quotient of the numbers e1 and e2.",
    "raw_url": "/f/builtins/div.html",
    "excerpt": "builtins.div Primop. Takes 2 arguments. e1, e2. Return the quotient of the numbers e1 and e2.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/bitOr.html",
    "content": "builtins.bitOr Primop. Takes 2 arguments. e1, e2. bitwise “or” Edit source. Noogle also knows. Aliases. lib.bitOr. lib.trivial.bitOr.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.bitOr Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.bitOr Primop. Takes 2 arguments. e1, e2. bitwise “or” Edit source. Noogle also knows. Aliases. lib.bitOr. lib.trivial.bitOr.",
    "raw_url": "/f/builtins/bitOr.html",
    "excerpt": "builtins.bitOr Primop. Takes 2 arguments. e1, e2. bitwise “or” Edit source. Noogle also knows. Aliases. lib.bitOr. lib.trivial.bitOr.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/fromJSON.html",
    "content": "builtins.fromJSON Primop. Takes 1 arguments. e. Convert a JSON string to a Nix value. For example, builtins.fromJSON ''{\"x\": [1, 2, 3], \"y\": null}'' returns the value { x = [ 1 2 3 ]; y = null; }. Noogle also knows. Aliases. lib.strings.fromJSON.",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.fromJSON Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.fromJSON Primop. Takes 1 arguments. e. Convert a JSON string to a Nix value. For example, builtins.fromJSON ''{\"x\": [1, 2, 3], \"y\": null}'' returns the value { x = [ 1 2 3 ]; y = null; }. Noogle also knows. Aliases. lib.strings.fromJSON.",
    "raw_url": "/f/builtins/fromJSON.html",
    "excerpt": "builtins.fromJSON Primop. Takes 1 arguments. e. Convert a JSON string to a Nix value. For example, builtins.fromJSON ''{\"x\": [1, 2, 3], \"y\": null}'' returns the value { x = [",
    "sub_results": []
  },
  {
    "url": "/f/builtins/unsafeDiscardStringContext.html",
    "content": "builtins.unsafeDiscardStringContext Primop. Takes 1 arguments.",
    "word_count": 5,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.unsafeDiscardStringContext Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.unsafeDiscardStringContext Primop. Takes 1 arguments.",
    "raw_url": "/f/builtins/unsafeDiscardStringContext.html",
    "excerpt": "builtins.unsafeDiscardStringContext Primop. Takes 1 arguments.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/isNull.html",
    "content": "builtins.isNull Primop. Takes 1 arguments. e. Return true if e evaluates to null, and false otherwise. Warning. This function is deprecated; just write e == null instead.",
    "word_count": 27,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.isNull Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.isNull Primop. Takes 1 arguments. e. Return true if e evaluates to null, and false otherwise. Warning. This function is deprecated; just write e == null instead.",
    "raw_url": "/f/builtins/isNull.html",
    "excerpt": "builtins.isNull Primop. Takes 1 arguments. e. Return true if e evaluates to null, and false otherwise. Warning. This function is deprecated; just write e == null instead.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/addErrorContext.html",
    "content": "builtins.addErrorContext Primop. Takes 2 arguments.",
    "word_count": 5,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.addErrorContext Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.addErrorContext Primop. Takes 2 arguments.",
    "raw_url": "/f/builtins/addErrorContext.html",
    "excerpt": "builtins.addErrorContext Primop. Takes 2 arguments.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/readDir.html",
    "content": "builtins.readDir Primop. Takes 1 arguments. path. Return the contents of the directory path as a set mapping directory entries to the corresponding file type. For instance, if directory A contains a regular file B and another directory C, then builtins.readDir ./A will return the set. { B = \"regular\"; C = \"directory\"; } The possible values for the file type are \"regular\", \"directory\", \"symlink\" and \"unknown\".",
    "word_count": 66,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.readDir Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.readDir Primop. Takes 1 arguments. path. Return the contents of the directory path as a set mapping directory entries to the corresponding file type. For instance, if directory A contains a regular file B and another directory C, then builtins.readDir ./A will return the set. { B = \"regular\"; C = \"directory\"; } The possible values for the file type are \"regular\", \"directory\", \"symlink\" and \"unknown\".",
    "raw_url": "/f/builtins/readDir.html",
    "excerpt": "builtins.readDir Primop. Takes 1 arguments. path. Return the contents of the directory path as a set mapping directory entries to the corresponding file type. For instance, if directory A contains",
    "sub_results": []
  },
  {
    "url": "/f/builtins/toString.html",
    "content": "builtins.toString Primop. Takes 1 arguments. e. Convert the expression e to a string. e can be: A string (in which case the string is returned unmodified). A path (e.g., toString /foo/bar yields \"/foo/bar\". A set containing { __toString = self: ...; } or { outPath = ...; }. An integer. A list, in which case the string representations of its elements are joined with spaces. A Boolean (false yields \"\", true yields \"1\"). null, which yields the empty string.",
    "word_count": 79,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.toString Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.toString Primop. Takes 1 arguments. e. Convert the expression e to a string. e can be: A string (in which case the string is returned unmodified). A path (e.g., toString /foo/bar yields \"/foo/bar\". A set containing { __toString = self: ...; } or { outPath = ...; }. An integer. A list, in which case the string representations of its elements are joined with spaces. A Boolean (false yields \"\", true yields \"1\"). null, which yields the empty string.",
    "raw_url": "/f/builtins/toString.html",
    "excerpt": "builtins.toString Primop. Takes 1 arguments. e. Convert the expression e to a string. e can be: A string (in which case the string is returned unmodified). A path (e.g., toString",
    "sub_results": []
  },
  {
    "url": "/f/builtins/throw.html",
    "content": "builtins.throw Primop. Takes 1 arguments. s. Throw an error message s. This usually aborts Nix expression evaluation, but in nix-env -qa and other commands that try to evaluate a set of derivations to get information about those derivations, a derivation that throws an error is silently skipped (which is not the case for abort).",
    "word_count": 54,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.throw Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.throw Primop. Takes 1 arguments. s. Throw an error message s. This usually aborts Nix expression evaluation, but in nix-env -qa and other commands that try to evaluate a set of derivations to get information about those derivations, a derivation that throws an error is silently skipped (which is not the case for abort).",
    "raw_url": "/f/builtins/throw.html",
    "excerpt": "builtins.throw Primop. Takes 1 arguments. s. Throw an error message s. This usually aborts Nix expression evaluation, but in nix-env -qa and other commands that try to evaluate a set",
    "sub_results": []
  },
  {
    "url": "/f/builtins/zipAttrsWith.html",
    "content": "builtins.zipAttrsWith Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names. Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names. Example. zipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet Edit source. Noogle also knows. Aliases. lib.zip. lib.zipAttrsWith. lib.attrsets.zip. lib.attrsets.zipAttrsWith.",
    "word_count": 118,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.zipAttrsWith Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 68
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 92
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.zipAttrsWith Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names. Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names. Example. zipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrsWith :: (String -&gt; [ Any ] -&gt; Any) -&gt; [ AttrSet ] -&gt; AttrSet Edit source. Noogle also knows. Aliases. lib.zip. lib.zipAttrsWith. lib.attrsets.zip. lib.attrsets.zipAttrsWith.",
    "raw_url": "/f/builtins/zipAttrsWith.html",
    "excerpt": "builtins.zipAttrsWith Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/seq.html",
    "content": "builtins.seq Primop. Takes 2 arguments. e1, e2. Evaluate e1, then evaluate and return e2. This ensures that a computation is strict in the value of e1. Noogle also knows. Aliases. lib.seq. lib.trivial.seq.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.seq Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.seq Primop. Takes 2 arguments. e1, e2. Evaluate e1, then evaluate and return e2. This ensures that a computation is strict in the value of e1. Noogle also knows. Aliases. lib.seq. lib.trivial.seq.",
    "raw_url": "/f/builtins/seq.html",
    "excerpt": "builtins.seq Primop. Takes 2 arguments. e1, e2. Evaluate e1, then evaluate and return e2. This ensures that a computation is strict in the value of e1. Noogle also knows. Aliases.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/placeholder.html",
    "content": "builtins.placeholder Primop. Takes 1 arguments. output. Return a placeholder string for the specified output that will be substituted by the corresponding output path at build time. Typical outputs would be \"out\", \"bin\" or \"dev\".",
    "word_count": 34,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.placeholder Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.placeholder Primop. Takes 1 arguments. output. Return a placeholder string for the specified output that will be substituted by the corresponding output path at build time. Typical outputs would be \"out\", \"bin\" or \"dev\".",
    "raw_url": "/f/builtins/placeholder.html",
    "excerpt": "builtins.placeholder Primop. Takes 1 arguments. output. Return a placeholder string for the specified output that will be substituted by the corresponding output path at build time. Typical outputs would be",
    "sub_results": []
  },
  {
    "url": "/f/builtins/mul.html",
    "content": "builtins.mul Primop. Takes 2 arguments. e1, e2. Return the product of the numbers e1 and e2.",
    "word_count": 16,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.mul Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.mul Primop. Takes 2 arguments. e1, e2. Return the product of the numbers e1 and e2.",
    "raw_url": "/f/builtins/mul.html",
    "excerpt": "builtins.mul Primop. Takes 2 arguments. e1, e2. Return the product of the numbers e1 and e2.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/head.html",
    "content": "builtins.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether a list is empty by comparing it with []. Noogle also knows. Aliases. lib.head. lib.lists.head. lib.strings.head.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.head Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether a list is empty by comparing it with []. Noogle also knows. Aliases. lib.head. lib.lists.head. lib.strings.head.",
    "raw_url": "/f/builtins/head.html",
    "excerpt": "builtins.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether",
    "sub_results": []
  },
  {
    "url": "/f/builtins/hashFile.html",
    "content": "builtins.hashFile Primop. Takes 2 arguments. type, p. Return a base-16 representation of the cryptographic hash of the file at path p. The hash algorithm specified by type must be one of \"md5\", \"sha1\", \"sha256\" or \"sha512\".",
    "word_count": 36,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.hashFile Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.hashFile Primop. Takes 2 arguments. type, p. Return a base-16 representation of the cryptographic hash of the file at path p. The hash algorithm specified by type must be one of \"md5\", \"sha1\", \"sha256\" or \"sha512\".",
    "raw_url": "/f/builtins/hashFile.html",
    "excerpt": "builtins.hashFile Primop. Takes 2 arguments. type, p. Return a base-16 representation of the cryptographic hash of the file at path p. The hash algorithm specified by type must be one",
    "sub_results": []
  },
  {
    "url": "/f/builtins/toFile.html",
    "content": "builtins.toFile Primop. Takes 2 arguments. name, s. Store the string s in a file in the Nix store and return its path. The file has suffix name. This file can be used as an input to derivations. One application is to write builders “inline”. For instance, the following Nix expression combines the Nix expression for GNU Hello and its build script into one file: { stdenv, fetchurl, perl }: stdenv.mkDerivation { name = \"hello-2.1.1\"; builder = builtins.toFile \"builder.sh\" \" source $stdenv/setup PATH=$perl/bin:$PATH tar xvfz $src cd hello-* ./configure --prefix=$out make make install \"; src = fetchurl { url = \"http://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz\"; sha256 = \"1md7jsfd8pa45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465\"; }; inherit perl; } It is even possible for one file to refer to another, e.g., builder = let configFile = builtins.toFile \"foo.conf\" \" # This is some dummy configuration file. ... \"; in builtins.toFile \"builder.sh\" \" source $stdenv/setup ... cp ${configFile} $out/etc/foo.conf \"; Note that ${configFile} is a string interpolation, so the result of the expression configFile (i.e., a path like /nix/store/m7p7jfny445k...-foo.conf) will be spliced into the resulting string. It is however not allowed to have files mutually referring to each other, like so: let foo = builtins.toFile \"foo\" \"...${bar}...\"; bar = builtins.toFile \"bar\" \"...${foo}...\"; in foo This is not allowed because it would cause a cyclic dependency in the computation of the cryptographic hashes for foo and bar. It is also not possible to reference the result of a derivation. If you are using Nixpkgs, the writeTextFile function is able to do that.",
    "word_count": 248,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.toFile Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.toFile Primop. Takes 2 arguments. name, s. Store the string s in a file in the Nix store and return its path. The file has suffix name. This file can be used as an input to derivations. One application is to write builders “inline”. For instance, the following Nix expression combines the Nix expression for GNU Hello and its build script into one file: { stdenv, fetchurl, perl }: stdenv.mkDerivation { name = \"hello-2.1.1\"; builder = builtins.toFile \"builder.sh\" \" source $stdenv/setup PATH=$perl/bin:$PATH tar xvfz $src cd hello-* ./configure --prefix=$out make make install \"; src = fetchurl { url = \"http://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz\"; sha256 = \"1md7jsfd8pa45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465\"; }; inherit perl; } It is even possible for one file to refer to another, e.g., builder = let configFile = builtins.toFile \"foo.conf\" \" # This is some dummy configuration file. ... \"; in builtins.toFile \"builder.sh\" \" source $stdenv/setup ... cp ${configFile} $out/etc/foo.conf \"; Note that ${configFile} is a string interpolation, so the result of the expression configFile (i.e., a path like /nix/store/m7p7jfny445k...-foo.conf) will be spliced into the resulting string. It is however not allowed to have files mutually referring to each other, like so: let foo = builtins.toFile \"foo\" \"...${bar}...\"; bar = builtins.toFile \"bar\" \"...${foo}...\"; in foo This is not allowed because it would cause a cyclic dependency in the computation of the cryptographic hashes for foo and bar. It is also not possible to reference the result of a derivation. If you are using Nixpkgs, the writeTextFile function is able to do that.",
    "raw_url": "/f/builtins/toFile.html",
    "excerpt": "builtins.toFile Primop. Takes 2 arguments. name, s. Store the string s in a file in the Nix store and return its path. The file has suffix name. This file can",
    "sub_results": []
  },
  {
    "url": "/f/builtins/pathExists.html",
    "content": "builtins.pathExists Primop. Takes 1 arguments. path. Return true if the path path exists at evaluation time, and false otherwise. Noogle also knows. Aliases. lib.pathExists. lib.trivial.pathExists.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.pathExists Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.pathExists Primop. Takes 1 arguments. path. Return true if the path path exists at evaluation time, and false otherwise. Noogle also knows. Aliases. lib.pathExists. lib.trivial.pathExists.",
    "raw_url": "/f/builtins/pathExists.html",
    "excerpt": "builtins.pathExists Primop. Takes 1 arguments. path. Return true if the path path exists at evaluation time, and false otherwise. Noogle also knows. Aliases. lib.pathExists. lib.trivial.pathExists.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/typeOf.html",
    "content": "builtins.typeOf Primop. Takes 1 arguments. e. Return a string representing the type of the value e, namely \"int\", \"bool\", \"string\", \"path\", \"null\", \"set\", \"list\", \"lambda\" or \"float\". Noogle also knows. Aliases. lib.strings.typeOf.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.typeOf Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.typeOf Primop. Takes 1 arguments. e. Return a string representing the type of the value e, namely \"int\", \"bool\", \"string\", \"path\", \"null\", \"set\", \"list\", \"lambda\" or \"float\". Noogle also knows. Aliases. lib.strings.typeOf.",
    "raw_url": "/f/builtins/typeOf.html",
    "excerpt": "builtins.typeOf Primop. Takes 1 arguments. e. Return a string representing the type of the value e, namely \"int\", \"bool\", \"string\", \"path\", \"null\", \"set\", \"list\", \"lambda\" or \"float\". Noogle also knows.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/unsafeGetAttrPos.html",
    "content": "builtins.unsafeGetAttrPos Primop. Takes 2 arguments.",
    "word_count": 5,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.unsafeGetAttrPos Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.unsafeGetAttrPos Primop. Takes 2 arguments.",
    "raw_url": "/f/builtins/unsafeGetAttrPos.html",
    "excerpt": "builtins.unsafeGetAttrPos Primop. Takes 2 arguments.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/compareVersions.html",
    "content": "builtins.compareVersions Primop. Takes 2 arguments. s1, s2. Compare two strings representing versions and return -1 if version s1 is older than version s2, 0 if they are the same, and 1 if s1 is newer than s2. The version comparison algorithm is the same as the one used by nix-env -u. Noogle also knows. Aliases. lib.strings.compareVersions.",
    "word_count": 56,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.compareVersions Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.compareVersions Primop. Takes 2 arguments. s1, s2. Compare two strings representing versions and return -1 if version s1 is older than version s2, 0 if they are the same, and 1 if s1 is newer than s2. The version comparison algorithm is the same as the one used by nix-env -u. Noogle also knows. Aliases. lib.strings.compareVersions.",
    "raw_url": "/f/builtins/compareVersions.html",
    "excerpt": "builtins.compareVersions Primop. Takes 2 arguments. s1, s2. Compare two strings representing versions and return -1 if version s1 is older than version s2, 0 if they are the same, and",
    "sub_results": []
  },
  {
    "url": "/f/builtins/all.html",
    "content": "builtins.all Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for all elements of list. Example. all (x: x < 3) [ 1 2 ] => true all (x: x < 3) [ 1 2 3 ] => false Type. all :: (a -> bool) -> [a] -> bool Edit source. Noogle also knows. Aliases. lib.all. lib.lists.all.",
    "word_count": 61,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.all Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 43
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.all Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for all elements of list. Example. all (x: x &lt; 3) [ 1 2 ] =&gt; true all (x: x &lt; 3) [ 1 2 3 ] =&gt; false Type. all :: (a -&gt; bool) -&gt; [a] -&gt; bool Edit source. Noogle also knows. Aliases. lib.all. lib.lists.all.",
    "raw_url": "/f/builtins/all.html",
    "excerpt": "builtins.all Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for all elements of list. Example. all (x: x &lt; 3) [ 1 2 ] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/builtins/hasAttr.html",
    "content": "builtins.hasAttr Primop. Takes 2 arguments. s, set. hasAttr returns true if set has an attribute named s, and false otherwise. This is a dynamic version of the ? operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. lib.hasAttr. lib.attrsets.hasAttr.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.hasAttr Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.hasAttr Primop. Takes 2 arguments. s, set. hasAttr returns true if set has an attribute named s, and false otherwise. This is a dynamic version of the ? operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. lib.hasAttr. lib.attrsets.hasAttr.",
    "raw_url": "/f/builtins/hasAttr.html",
    "excerpt": "builtins.hasAttr Primop. Takes 2 arguments. s, set. hasAttr returns true if set has an attribute named s, and false otherwise. This is a dynamic version of the ? operator, since",
    "sub_results": []
  },
  {
    "url": "/f/builtins/path.html",
    "content": "builtins.path Primop. Takes 1 arguments. args. An enrichment of the built-in path type, based on the attributes present in args. All are optional except path: path The underlying path. name The name of the path when added to the store. This can used to reference paths that have nix-illegal characters in their names, like @. filter A function of the type expected by builtins.filterSource, with the same semantics. recursive When false, when path is added to the store it is with a flat hash, rather than a hash of the NAR serialization of the file. Thus, path must refer to a regular file, not a directory. This allows similar behavior to fetchurl. Defaults to true. sha256 When provided, this is the expected hash of the file at the path. Evaluation will fail if the hash is incorrect, and providing a hash allows builtins.path to be used even when the pure-eval nix config option is on.",
    "word_count": 155,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.path Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.path Primop. Takes 1 arguments. args. An enrichment of the built-in path type, based on the attributes present in args. All are optional except path: path The underlying path. name The name of the path when added to the store. This can used to reference paths that have nix-illegal characters in their names, like @. filter A function of the type expected by builtins.filterSource, with the same semantics. recursive When false, when path is added to the store it is with a flat hash, rather than a hash of the NAR serialization of the file. Thus, path must refer to a regular file, not a directory. This allows similar behavior to fetchurl. Defaults to true. sha256 When provided, this is the expected hash of the file at the path. Evaluation will fail if the hash is incorrect, and providing a hash allows builtins.path to be used even when the pure-eval nix config option is on.",
    "raw_url": "/f/builtins/path.html",
    "excerpt": "builtins.path Primop. Takes 1 arguments. args. An enrichment of the built-in path type, based on the attributes present in args. All are optional except path: path The underlying path. name",
    "sub_results": []
  },
  {
    "url": "/f/builtins/isPath.html",
    "content": "builtins.isPath Primop. Takes 1 arguments. e. Return true if e evaluates to a path, and false otherwise. Noogle also knows. Aliases. lib.isPath. lib.strings.isPath.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.isPath Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.isPath Primop. Takes 1 arguments. e. Return true if e evaluates to a path, and false otherwise. Noogle also knows. Aliases. lib.isPath. lib.strings.isPath.",
    "raw_url": "/f/builtins/isPath.html",
    "excerpt": "builtins.isPath Primop. Takes 1 arguments. e. Return true if e evaluates to a path, and false otherwise. Noogle also knows. Aliases. lib.isPath. lib.strings.isPath.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/toPath.html",
    "content": "builtins.toPath Primop. Takes 1 arguments. s. DEPRECATED. Use /. + \"/path\" to convert a string into an absolute path. For relative paths, use ./. + \"/path\".",
    "word_count": 26,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.toPath Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.toPath Primop. Takes 1 arguments. s. DEPRECATED. Use /. + \"/path\" to convert a string into an absolute path. For relative paths, use ./. + \"/path\".",
    "raw_url": "/f/builtins/toPath.html",
    "excerpt": "builtins.toPath Primop. Takes 1 arguments. s. DEPRECATED. Use /. + \"/path\" to convert a string into an absolute path. For relative paths, use ./. + \"/path\".",
    "sub_results": []
  },
  {
    "url": "/f/builtins/add.html",
    "content": "builtins.add Primop. Takes 2 arguments. e1, e2. Return the sum of the numbers e1 and e2. Noogle also knows. Aliases. lib.add. lib.trivial.add.",
    "word_count": 22,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.add Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.add Primop. Takes 2 arguments. e1, e2. Return the sum of the numbers e1 and e2. Noogle also knows. Aliases. lib.add. lib.trivial.add.",
    "raw_url": "/f/builtins/add.html",
    "excerpt": "builtins.add Primop. Takes 2 arguments. e1, e2. Return the sum of the numbers e1 and e2. Noogle also knows. Aliases. lib.add. lib.trivial.add.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/isFunction.html",
    "content": "builtins.isFunction Primop. Takes 1 arguments. e. Return true if e evaluates to a function, and false otherwise.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.isFunction Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.isFunction Primop. Takes 1 arguments. e. Return true if e evaluates to a function, and false otherwise.",
    "raw_url": "/f/builtins/isFunction.html",
    "excerpt": "builtins.isFunction Primop. Takes 1 arguments. e. Return true if e evaluates to a function, and false otherwise.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/unsafeDiscardOutputDependency.html",
    "content": "builtins.unsafeDiscardOutputDependency Primop. Takes 1 arguments.",
    "word_count": 5,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.unsafeDiscardOutputDependency Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.unsafeDiscardOutputDependency Primop. Takes 1 arguments.",
    "raw_url": "/f/builtins/unsafeDiscardOutputDependency.html",
    "excerpt": "builtins.unsafeDiscardOutputDependency Primop. Takes 1 arguments.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/fetchurl.html",
    "content": "builtins.fetchurl Primop. Takes 1 arguments. url. Download the specified URL and return the path of the downloaded file. Not available in restricted evaluation mode.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.fetchurl Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.fetchurl Primop. Takes 1 arguments. url. Download the specified URL and return the path of the downloaded file. Not available in restricted evaluation mode.",
    "raw_url": "/f/builtins/fetchurl.html",
    "excerpt": "builtins.fetchurl Primop. Takes 1 arguments. url. Download the specified URL and return the path of the downloaded file. Not available in restricted evaluation mode.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/filter.html",
    "content": "builtins.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. lib.filter. lib.lists.filter. lib.strings.filter.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.filter Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. lib.filter. lib.lists.filter. lib.strings.filter.",
    "raw_url": "/f/builtins/filter.html",
    "excerpt": "builtins.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. lib.filter. lib.lists.filter. lib.strings.filter.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/intersectAttrs.html",
    "content": "builtins.intersectAttrs Primop. Takes 2 arguments. e1, e2. Return a set consisting of the attributes in the set e2 which have the same name as some attribute in e1. Performs in O(n log m) where n is the size of the smaller set and m the larger set's size.",
    "word_count": 48,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.intersectAttrs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.intersectAttrs Primop. Takes 2 arguments. e1, e2. Return a set consisting of the attributes in the set e2 which have the same name as some attribute in e1. Performs in O(n log m) where n is the size of the smaller set and m the larger set's size.",
    "raw_url": "/f/builtins/intersectAttrs.html",
    "excerpt": "builtins.intersectAttrs Primop. Takes 2 arguments. e1, e2. Return a set consisting of the attributes in the set e2 which have the same name as some attribute in e1. Performs in",
    "sub_results": []
  },
  {
    "url": "/f/builtins/concatMap.html",
    "content": "builtins.concatMap Primop. Takes 2 arguments. f, list. Map and concatenate the result. Example. concatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"] => [ \"a\" \"z\" \"b\" \"z\" ] Type. concatMap :: (a -> [b]) -> [a] -> [b] Edit source. Noogle also knows. Aliases. lib.concatMap. lib.lists.concatMap.",
    "word_count": 45,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.concatMap Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.concatMap Primop. Takes 2 arguments. f, list. Map and concatenate the result. Example. concatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"] =&gt; [ \"a\" \"z\" \"b\" \"z\" ] Type. concatMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b] Edit source. Noogle also knows. Aliases. lib.concatMap. lib.lists.concatMap.",
    "raw_url": "/f/builtins/concatMap.html",
    "excerpt": "builtins.concatMap Primop. Takes 2 arguments. f, list. Map and concatenate the result. Example. concatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"] =&gt; [ \"a\" \"z\" \"b\" \"z\" ] Type. concatMap ::",
    "sub_results": []
  },
  {
    "url": "/f/builtins/fetchMercurial.html",
    "content": "builtins.fetchMercurial Primop. Takes 1 arguments.",
    "word_count": 5,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.fetchMercurial Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.fetchMercurial Primop. Takes 1 arguments.",
    "raw_url": "/f/builtins/fetchMercurial.html",
    "excerpt": "builtins.fetchMercurial Primop. Takes 1 arguments.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/stringLength.html",
    "content": "builtins.stringLength Primop. Takes 1 arguments. e. Return the length of the string e. If e is not a string, evaluation is aborted. Noogle also knows. Aliases. lib.stringLength. lib.strings.stringLength.",
    "word_count": 28,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.stringLength Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.stringLength Primop. Takes 1 arguments. e. Return the length of the string e. If e is not a string, evaluation is aborted. Noogle also knows. Aliases. lib.stringLength. lib.strings.stringLength.",
    "raw_url": "/f/builtins/stringLength.html",
    "excerpt": "builtins.stringLength Primop. Takes 1 arguments. e. Return the length of the string e. If e is not a string, evaluation is aborted. Noogle also knows. Aliases. lib.stringLength. lib.strings.stringLength.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/readFile.html",
    "content": "builtins.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. lib.readFile. lib.strings.readFile. lib.trivial.readFile.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.readFile Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. lib.readFile. lib.strings.readFile. lib.trivial.readFile.",
    "raw_url": "/f/builtins/readFile.html",
    "excerpt": "builtins.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. lib.readFile. lib.strings.readFile. lib.trivial.readFile.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/concatStringsSep.html",
    "content": "builtins.concatStringsSep Primop. Takes 2 arguments. separator, list. Concatenate a list of strings with a separator between each element. Example. concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] => \"usr/local/bin\" Type. concatStringsSep :: string -> [string] -> string Edit source. Noogle also knows. Aliases. lib.concatStringsSep. lib.strings.concatStringsSep.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.concatStringsSep Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.concatStringsSep Primop. Takes 2 arguments. separator, list. Concatenate a list of strings with a separator between each element. Example. concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] =&gt; \"usr/local/bin\" Type. concatStringsSep :: string -&gt; [string] -&gt; string Edit source. Noogle also knows. Aliases. lib.concatStringsSep. lib.strings.concatStringsSep.",
    "raw_url": "/f/builtins/concatStringsSep.html",
    "excerpt": "builtins.concatStringsSep Primop. Takes 2 arguments. separator, list. Concatenate a list of strings with a separator between each element. Example. concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] =&gt; \"usr/local/bin\" Type. concatStringsSep :: string",
    "sub_results": []
  },
  {
    "url": "/f/builtins/getAttr.html",
    "content": "builtins.getAttr Primop. Takes 2 arguments. s, set. getAttr returns the attribute named s from set. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the . operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. lib.getAttr. lib.attrsets.getAttr.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.getAttr Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.getAttr Primop. Takes 2 arguments. s, set. getAttr returns the attribute named s from set. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the . operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. lib.getAttr. lib.attrsets.getAttr.",
    "raw_url": "/f/builtins/getAttr.html",
    "excerpt": "builtins.getAttr Primop. Takes 2 arguments. s, set. getAttr returns the attribute named s from set. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the .",
    "sub_results": []
  },
  {
    "url": "/f/builtins/splitVersion.html",
    "content": "builtins.splitVersion Primop. Takes 1 arguments. s. Break a version string into its component parts. Example. splitVersion \"1.2.3\" => [\"1\" \"2\" \"3\"] Edit source. Noogle also knows. Aliases. lib.splitVersion. lib.versions.splitVersion.",
    "word_count": 29,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.splitVersion Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.splitVersion Primop. Takes 1 arguments. s. Break a version string into its component parts. Example. splitVersion \"1.2.3\" =&gt; [\"1\" \"2\" \"3\"] Edit source. Noogle also knows. Aliases. lib.splitVersion. lib.versions.splitVersion.",
    "raw_url": "/f/builtins/splitVersion.html",
    "excerpt": "builtins.splitVersion Primop. Takes 1 arguments. s. Break a version string into its component parts. Example. splitVersion \"1.2.3\" =&gt; [\"1\" \"2\" \"3\"] Edit source. Noogle also knows. Aliases. lib.splitVersion. lib.versions.splitVersion.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/isString.html",
    "content": "builtins.isString Primop. Takes 1 arguments. e. Return true if e evaluates to a string, and false otherwise. Noogle also knows. Aliases. lib.isString. lib.strings.isString.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.isString Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.isString Primop. Takes 1 arguments. e. Return true if e evaluates to a string, and false otherwise. Noogle also knows. Aliases. lib.isString. lib.strings.isString.",
    "raw_url": "/f/builtins/isString.html",
    "excerpt": "builtins.isString Primop. Takes 1 arguments. e. Return true if e evaluates to a string, and false otherwise. Noogle also knows. Aliases. lib.isString. lib.strings.isString.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/trace.html",
    "content": "builtins.trace Primop. Takes 2 arguments. e1, e2. Evaluate e1 and print its abstract syntax representation on standard error. Then return e2. This function is useful for debugging. Noogle also knows. Aliases. lib.trace.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.trace Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.trace Primop. Takes 2 arguments. e1, e2. Evaluate e1 and print its abstract syntax representation on standard error. Then return e2. This function is useful for debugging. Noogle also knows. Aliases. lib.trace.",
    "raw_url": "/f/builtins/trace.html",
    "excerpt": "builtins.trace Primop. Takes 2 arguments. e1, e2. Evaluate e1 and print its abstract syntax representation on standard error. Then return e2. This function is useful for debugging. Noogle also knows.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/concatLists.html",
    "content": "builtins.concatLists Primop. Takes 1 arguments. lists. Concatenate a list of lists into a single list. Noogle also knows. Aliases. lib.concatLists. lib.lists.concatLists.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.concatLists Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.concatLists Primop. Takes 1 arguments. lists. Concatenate a list of lists into a single list. Noogle also knows. Aliases. lib.concatLists. lib.lists.concatLists.",
    "raw_url": "/f/builtins/concatLists.html",
    "excerpt": "builtins.concatLists Primop. Takes 1 arguments. lists. Concatenate a list of lists into a single list. Noogle also knows. Aliases. lib.concatLists. lib.lists.concatLists.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/lambdaMeta.html",
    "content": "builtins.lambdaMeta Primop. Takes 1 arguments. f.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.lambdaMeta Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.lambdaMeta Primop. Takes 1 arguments. f.",
    "raw_url": "/f/builtins/lambdaMeta.html",
    "excerpt": "builtins.lambdaMeta Primop. Takes 1 arguments. f.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/functionArgs.html",
    "content": "builtins.functionArgs Primop. Takes 1 arguments. f. Return a set containing the names of the formal arguments expected by the function f. The value of each attribute is a Boolean denoting whether the corresponding argument has a default value. For instance, functionArgs ({ x, y ? 123}: ...) = { x = false; y = true; }. \"Formal argument\" here refers to the attributes pattern-matched by the function. Plain lambdas are not included, e.g. functionArgs (x: ...) = { }.",
    "word_count": 79,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.functionArgs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.functionArgs Primop. Takes 1 arguments. f. Return a set containing the names of the formal arguments expected by the function f. The value of each attribute is a Boolean denoting whether the corresponding argument has a default value. For instance, functionArgs ({ x, y ? 123}: ...) = { x = false; y = true; }. \"Formal argument\" here refers to the attributes pattern-matched by the function. Plain lambdas are not included, e.g. functionArgs (x: ...) = { }.",
    "raw_url": "/f/builtins/functionArgs.html",
    "excerpt": "builtins.functionArgs Primop. Takes 1 arguments. f. Return a set containing the names of the formal arguments expected by the function f. The value of each attribute is a Boolean denoting",
    "sub_results": []
  },
  {
    "url": "/f/builtins/attrValues.html",
    "content": "builtins.attrValues Primop. Takes 1 arguments. set. Return the values of all attributes in the given set, sorted by attribute name. Example. attrValues {c = 3; a = 1; b = 2;} => [1 2 3] Type. attrValues :: AttrSet -> [Any] Edit source. Noogle also knows. Aliases. lib.attrValues. lib.attrsets.attrValues.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.attrValues Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.attrValues Primop. Takes 1 arguments. set. Return the values of all attributes in the given set, sorted by attribute name. Example. attrValues {c = 3; a = 1; b = 2;} =&gt; [1 2 3] Type. attrValues :: AttrSet -&gt; [Any] Edit source. Noogle also knows. Aliases. lib.attrValues. lib.attrsets.attrValues.",
    "raw_url": "/f/builtins/attrValues.html",
    "excerpt": "builtins.attrValues Primop. Takes 1 arguments. set. Return the values of all attributes in the given set, sorted by attribute name. Example. attrValues {c = 3; a = 1; b =",
    "sub_results": []
  },
  {
    "url": "/f/builtins/replaceStrings.html",
    "content": "builtins.replaceStrings Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s. Example: builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\" evaluates to \"fabir\". Noogle also knows. Aliases. lib.replaceChars. lib.replaceStrings. lib.strings.replaceChars. lib.strings.replaceStrings.",
    "word_count": 66,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.replaceStrings Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.replaceStrings Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s. Example: builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\" evaluates to \"fabir\". Noogle also knows. Aliases. lib.replaceChars. lib.replaceStrings. lib.strings.replaceChars. lib.strings.replaceStrings.",
    "raw_url": "/f/builtins/replaceStrings.html",
    "excerpt": "builtins.replaceStrings Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy,",
    "sub_results": []
  },
  {
    "url": "/f/builtins/isList.html",
    "content": "builtins.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. lib.isList. lib.lists.isList. lib.strings.isList.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.isList Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. lib.isList. lib.lists.isList. lib.strings.isList.",
    "raw_url": "/f/builtins/isList.html",
    "excerpt": "builtins.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. lib.isList. lib.lists.isList. lib.strings.isList.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/partition.html",
    "content": "builtins.partition Primop. Takes 2 arguments. pred, list. Splits the elements of a list in two lists, right and wrong, depending on the evaluation of a predicate. Example. partition (x: x > 2) [ 5 1 2 3 4 ] => { right = [ 5 3 4 ]; wrong = [ 1 2 ]; } Type. (a -> bool) -> [a] -> { right :: [a]; wrong :: [a]; } Edit source. Noogle also knows. Aliases. lib.partition. lib.lists.partition.",
    "word_count": 78,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.partition Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.partition Primop. Takes 2 arguments. pred, list. Splits the elements of a list in two lists, right and wrong, depending on the evaluation of a predicate. Example. partition (x: x &gt; 2) [ 5 1 2 3 4 ] =&gt; { right = [ 5 3 4 ]; wrong = [ 1 2 ]; } Type. (a -&gt; bool) -&gt; [a] -&gt; { right :: [a]; wrong :: [a]; } Edit source. Noogle also knows. Aliases. lib.partition. lib.lists.partition.",
    "raw_url": "/f/builtins/partition.html",
    "excerpt": "builtins.partition Primop. Takes 2 arguments. pred, list. Splits the elements of a list in two lists, right and wrong, depending on the evaluation of a predicate. Example. partition (x: x",
    "sub_results": []
  },
  {
    "url": "/f/builtins/parseDrvName.html",
    "content": "builtins.parseDrvName Primop. Takes 1 arguments. s. Split the string s into a package name and version. The package name is everything up to but not including the first dash not followed by a letter, and the version is everything following that dash. The result is returned in a set { name, version }. Thus, builtins.parseDrvName \"nix-0.12pre12876\" returns { name = \"nix\"; version = \"0.12pre12876\"; }. Noogle also knows. Aliases. lib.strings.parseDrvName.",
    "word_count": 70,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.parseDrvName Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.parseDrvName Primop. Takes 1 arguments. s. Split the string s into a package name and version. The package name is everything up to but not including the first dash not followed by a letter, and the version is everything following that dash. The result is returned in a set { name, version }. Thus, builtins.parseDrvName \"nix-0.12pre12876\" returns { name = \"nix\"; version = \"0.12pre12876\"; }. Noogle also knows. Aliases. lib.strings.parseDrvName.",
    "raw_url": "/f/builtins/parseDrvName.html",
    "excerpt": "builtins.parseDrvName Primop. Takes 1 arguments. s. Split the string s into a package name and version. The package name is everything up to but not including the first dash not",
    "sub_results": []
  },
  {
    "url": "/f/builtins/filterSource.html",
    "content": "builtins.filterSource Primop. Takes 2 arguments. e1, e2. Warning. filterSource should not be used to filter store paths. Since filterSource uses the name of the input directory while naming the output directory, doing so will produce a directory name in the form of <hash2>-<hash>-<name>, where <hash>-<name> is the name of the input directory. Since <hash> depends on the unfiltered directory, the name of the output directory will indirectly depend on files that are filtered out by the function. This will trigger a rebuild even when a filtered out file is changed. Use builtins.path instead, which allows specifying the name of the output directory. This function allows you to copy sources into the Nix store while filtering certain files. For instance, suppose that you want to use the directory source-dir as an input to a Nix expression, e.g. stdenv.mkDerivation { ... src = ./source-dir; } However, if source-dir is a Subversion working copy, then all those annoying .svn subdirectories will also be copied to the store. Worse, the contents of those directories may change a lot, causing lots of spurious rebuilds. With filterSource you can filter out the .svn directories: src = builtins.filterSource (path: type: type != \"directory\" || baseNameOf path != \".svn\") ./source-dir; Thus, the first argument e1 must be a predicate function that is called for each regular file, directory or symlink in the source tree e2. If the function returns true, the file is copied to the Nix store, otherwise it is omitted. The function is called with two arguments. The first is the full path of the file. The second is a string that identifies the type of the file, which is either \"regular\", \"directory\", \"symlink\" or \"unknown\" (for other kinds of files such as device nodes or fifos — but note that those cannot be copied to the Nix store, so if the predicate returns true for them, the copy will fail). If you exclude a directory, the entire corresponding subtree of e2 will be excluded.",
    "word_count": 329,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.filterSource Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.filterSource Primop. Takes 2 arguments. e1, e2. Warning. filterSource should not be used to filter store paths. Since filterSource uses the name of the input directory while naming the output directory, doing so will produce a directory name in the form of &lt;hash2&gt;-&lt;hash&gt;-&lt;name&gt;, where &lt;hash&gt;-&lt;name&gt; is the name of the input directory. Since &lt;hash&gt; depends on the unfiltered directory, the name of the output directory will indirectly depend on files that are filtered out by the function. This will trigger a rebuild even when a filtered out file is changed. Use builtins.path instead, which allows specifying the name of the output directory. This function allows you to copy sources into the Nix store while filtering certain files. For instance, suppose that you want to use the directory source-dir as an input to a Nix expression, e.g. stdenv.mkDerivation { ... src = ./source-dir; } However, if source-dir is a Subversion working copy, then all those annoying .svn subdirectories will also be copied to the store. Worse, the contents of those directories may change a lot, causing lots of spurious rebuilds. With filterSource you can filter out the .svn directories: src = builtins.filterSource (path: type: type != \"directory\" || baseNameOf path != \".svn\") ./source-dir; Thus, the first argument e1 must be a predicate function that is called for each regular file, directory or symlink in the source tree e2. If the function returns true, the file is copied to the Nix store, otherwise it is omitted. The function is called with two arguments. The first is the full path of the file. The second is a string that identifies the type of the file, which is either \"regular\", \"directory\", \"symlink\" or \"unknown\" (for other kinds of files such as device nodes or fifos — but note that those cannot be copied to the Nix store, so if the predicate returns true for them, the copy will fail). If you exclude a directory, the entire corresponding subtree of e2 will be excluded.",
    "raw_url": "/f/builtins/filterSource.html",
    "excerpt": "builtins.filterSource Primop. Takes 2 arguments. e1, e2. Warning. filterSource should not be used to filter store paths. Since filterSource uses the name of the input directory while naming the output",
    "sub_results": []
  },
  {
    "url": "/f/builtins/tryEval.html",
    "content": "builtins.tryEval Primop. Takes 1 arguments. e. Try to shallowly evaluate e. Return a set containing the attributes success (true if e evaluated successfully, false if an error was thrown) and value, equalling e if successful and false otherwise. tryEval will only prevent errors created by throw or assert from being thrown. Errors tryEval will not catch are for example those created by abort and type errors generated by builtins. Also note that this doesn't evaluate e deeply, so let e = { x = throw \"\"; }; in (builtins.tryEval e).success will be true. Using builtins.deepSeq one can get the expected result: let e = { x = throw \"\"; }; in (builtins.tryEval (builtins.deepSeq e e)).success will be false.",
    "word_count": 118,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.tryEval Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.tryEval Primop. Takes 1 arguments. e. Try to shallowly evaluate e. Return a set containing the attributes success (true if e evaluated successfully, false if an error was thrown) and value, equalling e if successful and false otherwise. tryEval will only prevent errors created by throw or assert from being thrown. Errors tryEval will not catch are for example those created by abort and type errors generated by builtins. Also note that this doesn't evaluate e deeply, so let e = { x = throw \"\"; }; in (builtins.tryEval e).success will be true. Using builtins.deepSeq one can get the expected result: let e = { x = throw \"\"; }; in (builtins.tryEval (builtins.deepSeq e e)).success will be false.",
    "raw_url": "/f/builtins/tryEval.html",
    "excerpt": "builtins.tryEval Primop. Takes 1 arguments. e. Try to shallowly evaluate e. Return a set containing the attributes success (true if e evaluated successfully, false if an error was thrown) and",
    "sub_results": []
  },
  {
    "url": "/f/builtins/genericClosure.html",
    "content": "builtins.genericClosure Primop. Takes 1 arguments. attrset. Takes an attrset with the following attributes: startSet [ Item ] A list of start items. Each item must be an attrset containing a key. The key must be comparable. operator Item -> [ Item ] A function. returns a list of attrsets. GenericClosure starts with the startSet and recursively applying the operator function to each item. The attrsets in the startSet and the attrsets produced by operator must contain a value named key which is comparable. The result is produced by calling operator for each item with a value for key that has not been called yet including newly produced items. The function terminates when no new items are produced. The resulting list of attrsets contains only attrsets with a unique key. For example, builtins.genericClosure { startSet = [ {key = 5;} ]; operator = item: [{ key = if (item.key / 2 ) * 2 == item.key then item.key / 2 else 3 * item.key + 1; }]; } evaluates to. [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ] Noogle also knows. Aliases. lib.genericClosure. lib.trivial.genericClosure.",
    "word_count": 207,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.genericClosure Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.genericClosure Primop. Takes 1 arguments. attrset. Takes an attrset with the following attributes: startSet [ Item ] A list of start items. Each item must be an attrset containing a key. The key must be comparable. operator Item -&gt; [ Item ] A function. returns a list of attrsets. GenericClosure starts with the startSet and recursively applying the operator function to each item. The attrsets in the startSet and the attrsets produced by operator must contain a value named key which is comparable. The result is produced by calling operator for each item with a value for key that has not been called yet including newly produced items. The function terminates when no new items are produced. The resulting list of attrsets contains only attrsets with a unique key. For example, builtins.genericClosure { startSet = [ {key = 5;} ]; operator = item: [{ key = if (item.key / 2 ) * 2 == item.key then item.key / 2 else 3 * item.key + 1; }]; } evaluates to. [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ] Noogle also knows. Aliases. lib.genericClosure. lib.trivial.genericClosure.",
    "raw_url": "/f/builtins/genericClosure.html",
    "excerpt": "builtins.genericClosure Primop. Takes 1 arguments. attrset. Takes an attrset with the following attributes: startSet [ Item ] A list of start items. Each item must be an attrset containing a",
    "sub_results": []
  },
  {
    "url": "/f/builtins/isBool.html",
    "content": "builtins.isBool Primop. Takes 1 arguments. e. Return true if e evaluates to a bool, and false otherwise. Noogle also knows. Aliases. lib.isBool. lib.trivial.isBool.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.isBool Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.isBool Primop. Takes 1 arguments. e. Return true if e evaluates to a bool, and false otherwise. Noogle also knows. Aliases. lib.isBool. lib.trivial.isBool.",
    "raw_url": "/f/builtins/isBool.html",
    "excerpt": "builtins.isBool Primop. Takes 1 arguments. e. Return true if e evaluates to a bool, and false otherwise. Noogle also knows. Aliases. lib.isBool. lib.trivial.isBool.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/break.html",
    "content": "builtins.break Primop. Takes 1 arguments. v. In debug mode (enabled using --debugger), pause Nix expression evaluation and enter the REPL. Otherwise, return the argument v.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.break Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.break Primop. Takes 1 arguments. v. In debug mode (enabled using --debugger), pause Nix expression evaluation and enter the REPL. Otherwise, return the argument v.",
    "raw_url": "/f/builtins/break.html",
    "excerpt": "builtins.break Primop. Takes 1 arguments. v. In debug mode (enabled using --debugger), pause Nix expression evaluation and enter the REPL. Otherwise, return the argument v.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/derivation.html",
    "content": "builtins.derivation.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.derivation"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.derivation.",
    "raw_url": "/f/builtins/derivation.html",
    "excerpt": "builtins.derivation.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/findFile.html",
    "content": "builtins.findFile Primop. Takes 2 arguments. search path, lookup path. Look up the given path with the given search path. A search path is represented list of attribute sets with two attributes, prefix, and path. prefix is a relative path. path denotes a file system location; the exact syntax depends on the command line interface. Examples of search path attribute sets: { prefix = \"nixos-config\"; path = \"/etc/nixos/configuration.nix\"; } { prefix = \"\"; path = \"/nix/var/nix/profiles/per-user/root/channels\"; } The lookup algorithm checks each entry until a match is found, returning a path value of the match. This is the process for each entry: If the lookup path matches prefix, then the remainder of the lookup path (the \"suffix\") is searched for within the directory denoted by patch. Note that the path may need to be downloaded at this point to look inside. If the suffix is found inside that directory, then the entry is a match; the combined absolute path of the directory (now downloaded if need be) and the suffix is returned. Lookup path expressions can be desugared using this and builtins.nixPath: <nixpkgs> is equivalent to: builtins.findFile builtins.nixPath \"nixpkgs\"",
    "word_count": 188,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.findFile Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.findFile Primop. Takes 2 arguments. search path, lookup path. Look up the given path with the given search path. A search path is represented list of attribute sets with two attributes, prefix, and path. prefix is a relative path. path denotes a file system location; the exact syntax depends on the command line interface. Examples of search path attribute sets: { prefix = \"nixos-config\"; path = \"/etc/nixos/configuration.nix\"; } { prefix = \"\"; path = \"/nix/var/nix/profiles/per-user/root/channels\"; } The lookup algorithm checks each entry until a match is found, returning a path value of the match. This is the process for each entry: If the lookup path matches prefix, then the remainder of the lookup path (the \"suffix\") is searched for within the directory denoted by patch. Note that the path may need to be downloaded at this point to look inside. If the suffix is found inside that directory, then the entry is a match; the combined absolute path of the directory (now downloaded if need be) and the suffix is returned. Lookup path expressions can be desugared using this and builtins.nixPath: &lt;nixpkgs&gt; is equivalent to: builtins.findFile builtins.nixPath \"nixpkgs\"",
    "raw_url": "/f/builtins/findFile.html",
    "excerpt": "builtins.findFile Primop. Takes 2 arguments. search path, lookup path. Look up the given path with the given search path. A search path is represented list of attribute sets with two",
    "sub_results": []
  },
  {
    "url": "/f/builtins/derivationStrict.html",
    "content": "builtins.derivationStrict Primop. Takes 1 arguments.",
    "word_count": 5,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.derivationStrict Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.derivationStrict Primop. Takes 1 arguments.",
    "raw_url": "/f/builtins/derivationStrict.html",
    "excerpt": "builtins.derivationStrict Primop. Takes 1 arguments.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/fetchTarball.html",
    "content": "builtins.fetchTarball Primop. Takes 1 arguments. args. Download the specified URL, unpack it and return the path of the unpacked tree. The file must be a tape archive (.tar) compressed with gzip, bzip2 or xz. The top-level path component of the files in the tarball is removed, so it is best if the tarball contains a single directory at top level. The typical use of the function is to obtain external Nix expression dependencies, such as a particular version of Nixpkgs, e.g. with import (fetchTarball https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz) {}; stdenv.mkDerivation { … } The fetched tarball is cached for a certain amount of time (1 hour by default) in ~/.cache/nix/tarballs/. You can change the cache timeout either on the command line with --tarball-ttl number-of-seconds or in the Nix configuration file by adding the line tarball-ttl = number-of-seconds. Note that when obtaining the hash with nix-prefetch-url the option --unpack is required. This function can also verify the contents against a hash. In that case, the function takes a set instead of a URL. The set requires the attribute url and the attribute sha256, e.g. with import (fetchTarball { url = \"https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz\"; sha256 = \"1jppksrfvbk5ypiqdz4cddxdl8z6zyzdb2srq8fcffr327ld5jj2\"; }) {}; stdenv.mkDerivation { … } Not available in restricted evaluation mode.",
    "word_count": 202,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.fetchTarball Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.fetchTarball Primop. Takes 1 arguments. args. Download the specified URL, unpack it and return the path of the unpacked tree. The file must be a tape archive (.tar) compressed with gzip, bzip2 or xz. The top-level path component of the files in the tarball is removed, so it is best if the tarball contains a single directory at top level. The typical use of the function is to obtain external Nix expression dependencies, such as a particular version of Nixpkgs, e.g. with import (fetchTarball https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz) {}; stdenv.mkDerivation { … } The fetched tarball is cached for a certain amount of time (1 hour by default) in ~/.cache/nix/tarballs/. You can change the cache timeout either on the command line with --tarball-ttl number-of-seconds or in the Nix configuration file by adding the line tarball-ttl = number-of-seconds. Note that when obtaining the hash with nix-prefetch-url the option --unpack is required. This function can also verify the contents against a hash. In that case, the function takes a set instead of a URL. The set requires the attribute url and the attribute sha256, e.g. with import (fetchTarball { url = \"https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz\"; sha256 = \"1jppksrfvbk5ypiqdz4cddxdl8z6zyzdb2srq8fcffr327ld5jj2\"; }) {}; stdenv.mkDerivation { … } Not available in restricted evaluation mode.",
    "raw_url": "/f/builtins/fetchTarball.html",
    "excerpt": "builtins.fetchTarball Primop. Takes 1 arguments. args. Download the specified URL, unpack it and return the path of the unpacked tree. The file must be a tape archive (.tar) compressed with",
    "sub_results": []
  },
  {
    "url": "/f/builtins/import.html",
    "content": "builtins.import Primop. Takes 1 arguments. path. Load, parse, and return the Nix expression in the file path. Note. Unlike some languages, import is a regular function in Nix. The path argument must meet the same criteria as an interpolated expression. If path is a directory, the file default.nix in that directory is used if it exists. Example. $ echo 123 > default.nix Import default.nix from the current directory. import ./. 123 Evaluation aborts if the file doesn’t exist or contains an invalid Nix expression. A Nix expression loaded by import must not contain any free variables, that is, identifiers that are not defined in the Nix expression itself and are not built-in. Therefore, it cannot refer to variables that are in scope at the call site. Example. If you have a calling expression. rec { x = 123; y = import ./foo.nix; } then the following foo.nix will give an error: # foo.nix x + 456 since x is not in scope in foo.nix. If you want x to be available in foo.nix, pass it as a function argument: rec { x = 123; y = import ./foo.nix x; } and. # foo.nix x: x + 456 The function argument doesn’t have to be called x in foo.nix; any name would work.",
    "word_count": 212,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.import Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.import Primop. Takes 1 arguments. path. Load, parse, and return the Nix expression in the file path. Note. Unlike some languages, import is a regular function in Nix. The path argument must meet the same criteria as an interpolated expression. If path is a directory, the file default.nix in that directory is used if it exists. Example. $ echo 123 &gt; default.nix Import default.nix from the current directory. import ./. 123 Evaluation aborts if the file doesn’t exist or contains an invalid Nix expression. A Nix expression loaded by import must not contain any free variables, that is, identifiers that are not defined in the Nix expression itself and are not built-in. Therefore, it cannot refer to variables that are in scope at the call site. Example. If you have a calling expression. rec { x = 123; y = import ./foo.nix; } then the following foo.nix will give an error: # foo.nix x + 456 since x is not in scope in foo.nix. If you want x to be available in foo.nix, pass it as a function argument: rec { x = 123; y = import ./foo.nix x; } and. # foo.nix x: x + 456 The function argument doesn’t have to be called x in foo.nix; any name would work.",
    "raw_url": "/f/builtins/import.html",
    "excerpt": "builtins.import Primop. Takes 1 arguments. path. Load, parse, and return the Nix expression in the file path. Note. Unlike some languages, import is a regular function in Nix. The path",
    "sub_results": []
  },
  {
    "url": "/f/builtins/map.html",
    "content": "builtins.map Primop. Takes 2 arguments. f, list. Apply the function f to each element in the list list. For example, map (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ] evaluates to [ \"foobar\" \"foobla\" \"fooabc\" ]. Noogle also knows. Aliases. lib.lists.map.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.map Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.map Primop. Takes 2 arguments. f, list. Apply the function f to each element in the list list. For example, map (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ] evaluates to [ \"foobar\" \"foobla\" \"fooabc\" ]. Noogle also knows. Aliases. lib.lists.map.",
    "raw_url": "/f/builtins/map.html",
    "excerpt": "builtins.map Primop. Takes 2 arguments. f, list. Apply the function f to each element in the list list. For example, map (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]",
    "sub_results": []
  },
  {
    "url": "/f/builtins/sort.html",
    "content": "builtins.sort Primop. Takes 2 arguments. comparator, list. Sort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the second argument. The returned list is sorted in an increasing order. The implementation does a quick-sort. Example. sort (a: b: a < b) [ 5 3 7 ] => [ 3 5 7 ] Edit source. Noogle also knows. Aliases. lib.sort. lib.lists.sort.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.sort Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 46
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.sort Primop. Takes 2 arguments. comparator, list. Sort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the second argument. The returned list is sorted in an increasing order. The implementation does a quick-sort. Example. sort (a: b: a &lt; b) [ 5 3 7 ] =&gt; [ 3 5 7 ] Edit source. Noogle also knows. Aliases. lib.sort. lib.lists.sort.",
    "raw_url": "/f/builtins/sort.html",
    "excerpt": "builtins.sort Primop. Takes 2 arguments. comparator, list. Sort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the",
    "sub_results": []
  },
  {
    "url": "/f/builtins/baseNameOf.html",
    "content": "builtins.baseNameOf Primop. Takes 1 arguments. s. Return the base name of the string s, that is, everything following the final slash in the string. This is similar to the GNU basename command.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.baseNameOf Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.baseNameOf Primop. Takes 1 arguments. s. Return the base name of the string s, that is, everything following the final slash in the string. This is similar to the GNU basename command.",
    "raw_url": "/f/builtins/baseNameOf.html",
    "excerpt": "builtins.baseNameOf Primop. Takes 1 arguments. s. Return the base name of the string s, that is, everything following the final slash in the string. This is similar to the GNU",
    "sub_results": []
  },
  {
    "url": "/f/builtins/length.html",
    "content": "builtins.length Primop. Takes 1 arguments. e. Return the length of the list e. Noogle also knows. Aliases. lib.length. lib.lists.length.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.length Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.length Primop. Takes 1 arguments. e. Return the length of the list e. Noogle also knows. Aliases. lib.length. lib.lists.length.",
    "raw_url": "/f/builtins/length.html",
    "excerpt": "builtins.length Primop. Takes 1 arguments. e. Return the length of the list e. Noogle also knows. Aliases. lib.length. lib.lists.length.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/abort.html",
    "content": "builtins.abort Primop. Takes 1 arguments. s. Abort Nix expression evaluation and print the error message s.",
    "word_count": 16,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.abort Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.abort Primop. Takes 1 arguments. s. Abort Nix expression evaluation and print the error message s.",
    "raw_url": "/f/builtins/abort.html",
    "excerpt": "builtins.abort Primop. Takes 1 arguments. s. Abort Nix expression evaluation and print the error message s.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/ceil.html",
    "content": "builtins.ceil Primop. Takes 1 arguments. double. Converts an IEEE-754 double-precision floating-point number (double) to the next higher integer. If the datatype is neither an integer nor a \"float\", an evaluation error will be thrown.",
    "word_count": 34,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.ceil Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.ceil Primop. Takes 1 arguments. double. Converts an IEEE-754 double-precision floating-point number (double) to the next higher integer. If the datatype is neither an integer nor a \"float\", an evaluation error will be thrown.",
    "raw_url": "/f/builtins/ceil.html",
    "excerpt": "builtins.ceil Primop. Takes 1 arguments. double. Converts an IEEE-754 double-precision floating-point number (double) to the next higher integer. If the datatype is neither an integer nor a \"float\", an evaluation",
    "sub_results": []
  },
  {
    "url": "/f/builtins/substring.html",
    "content": "builtins.substring Primop. Takes 3 arguments. start, len, s. Return the substring of s from character position start (zero-based) up to but not including start + len. If start is greater than the length of the string, an empty string is returned, and if start + len lies beyond the end of the string, only the substring up to the end of the string is returned. start must be non-negative. For example, builtins.substring 0 3 \"nixos\" evaluates to \"nix\". Noogle also knows. Aliases. lib.substring. lib.strings.substring.",
    "word_count": 84,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.substring Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.substring Primop. Takes 3 arguments. start, len, s. Return the substring of s from character position start (zero-based) up to but not including start + len. If start is greater than the length of the string, an empty string is returned, and if start + len lies beyond the end of the string, only the substring up to the end of the string is returned. start must be non-negative. For example, builtins.substring 0 3 \"nixos\" evaluates to \"nix\". Noogle also knows. Aliases. lib.substring. lib.strings.substring.",
    "raw_url": "/f/builtins/substring.html",
    "excerpt": "builtins.substring Primop. Takes 3 arguments. start, len, s. Return the substring of s from character position start (zero-based) up to but not including start + len. If start is greater",
    "sub_results": []
  },
  {
    "url": "/f/builtins/isFloat.html",
    "content": "builtins.isFloat Primop. Takes 1 arguments. e. Return true if e evaluates to a float, and false otherwise. Noogle also knows. Aliases. lib.isFloat. lib.trivial.isFloat.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.isFloat Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.isFloat Primop. Takes 1 arguments. e. Return true if e evaluates to a float, and false otherwise. Noogle also knows. Aliases. lib.isFloat. lib.trivial.isFloat.",
    "raw_url": "/f/builtins/isFloat.html",
    "excerpt": "builtins.isFloat Primop. Takes 1 arguments. e. Return true if e evaluates to a float, and false otherwise. Noogle also knows. Aliases. lib.isFloat. lib.trivial.isFloat.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/hashString.html",
    "content": "builtins.hashString Primop. Takes 2 arguments. type, s. Return a base-16 representation of the cryptographic hash of string s. The hash algorithm specified by type must be one of \"md5\", \"sha1\", \"sha256\" or \"sha512\".",
    "word_count": 33,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.hashString Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.hashString Primop. Takes 2 arguments. type, s. Return a base-16 representation of the cryptographic hash of string s. The hash algorithm specified by type must be one of \"md5\", \"sha1\", \"sha256\" or \"sha512\".",
    "raw_url": "/f/builtins/hashString.html",
    "excerpt": "builtins.hashString Primop. Takes 2 arguments. type, s. Return a base-16 representation of the cryptographic hash of string s. The hash algorithm specified by type must be one of \"md5\", \"sha1\",",
    "sub_results": []
  },
  {
    "url": "/f/builtins/bitAnd.html",
    "content": "builtins.bitAnd Primop. Takes 2 arguments. e1, e2. bitwise “and” Edit source. Noogle also knows. Aliases. lib.bitAnd. lib.trivial.bitAnd.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.bitAnd Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.bitAnd Primop. Takes 2 arguments. e1, e2. bitwise “and” Edit source. Noogle also knows. Aliases. lib.bitAnd. lib.trivial.bitAnd.",
    "raw_url": "/f/builtins/bitAnd.html",
    "excerpt": "builtins.bitAnd Primop. Takes 2 arguments. e1, e2. bitwise “and” Edit source. Noogle also knows. Aliases. lib.bitAnd. lib.trivial.bitAnd.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/foldl'.html",
    "content": "builtins.foldl' (Prime) Primop. Takes 3 arguments. op, nul, list. Reduce a list by applying a binary operator, from left to right, e.g. foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2) .... For example, foldl' (x: y: x + y) 0 [1 2 3] evaluates to 6. The return value of each application of op is evaluated immediately, even for intermediate values.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.foldl' (Prime) Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.foldl' (Prime) Primop. Takes 3 arguments. op, nul, list. Reduce a list by applying a binary operator, from left to right, e.g. foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2) .... For example, foldl' (x: y: x + y) 0 [1 2 3] evaluates to 6. The return value of each application of op is evaluated immediately, even for intermediate values.",
    "raw_url": "/f/builtins/foldl'.html",
    "excerpt": "builtins.foldl' (Prime) Primop. Takes 3 arguments. op, nul, list. Reduce a list by applying a binary operator, from left to right, e.g. foldl' op nul [x0 x1 x2 ...] =",
    "sub_results": []
  },
  {
    "url": "/f/builtins/readFileType.html",
    "content": "builtins.readFileType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else. Example. pathType /. => \"directory\" pathType /some/file.nix => \"regular\" Type. pathType :: Path -> String Edit source. Noogle also knows. Aliases. lib.pathType. lib.filesystem.pathType. lib.sources.pathType.",
    "word_count": 65,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.readFileType Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 41
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.readFileType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else. Example. pathType /. =&gt; \"directory\" pathType /some/file.nix =&gt; \"regular\" Type. pathType :: Path -&gt; String Edit source. Noogle also knows. Aliases. lib.pathType. lib.filesystem.pathType. lib.sources.pathType.",
    "raw_url": "/f/builtins/readFileType.html",
    "excerpt": "builtins.readFileType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a",
    "sub_results": []
  },
  {
    "url": "/f/builtins/lessThan.html",
    "content": "builtins.lessThan Primop. Takes 2 arguments. e1, e2. Return true if the number e1 is less than the number e2, and false otherwise. Evaluation aborts if either e1 or e2 does not evaluate to a number. Noogle also knows. Aliases. lib.lessThan. lib.trivial.lessThan.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.lessThan Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.lessThan Primop. Takes 2 arguments. e1, e2. Return true if the number e1 is less than the number e2, and false otherwise. Evaluation aborts if either e1 or e2 does not evaluate to a number. Noogle also knows. Aliases. lib.lessThan. lib.trivial.lessThan.",
    "raw_url": "/f/builtins/lessThan.html",
    "excerpt": "builtins.lessThan Primop. Takes 2 arguments. e1, e2. Return true if the number e1 is less than the number e2, and false otherwise. Evaluation aborts if either e1 or e2 does",
    "sub_results": []
  },
  {
    "url": "/f/builtins/bitXor.html",
    "content": "builtins.bitXor Primop. Takes 2 arguments. e1, e2. bitwise “xor” Edit source. Noogle also knows. Aliases. lib.bitXor. lib.trivial.bitXor.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.bitXor Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.bitXor Primop. Takes 2 arguments. e1, e2. bitwise “xor” Edit source. Noogle also knows. Aliases. lib.bitXor. lib.trivial.bitXor.",
    "raw_url": "/f/builtins/bitXor.html",
    "excerpt": "builtins.bitXor Primop. Takes 2 arguments. e1, e2. bitwise “xor” Edit source. Noogle also knows. Aliases. lib.bitXor. lib.trivial.bitXor.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/groupBy.html",
    "content": "builtins.groupBy Primop. Takes 2 arguments. f, list. Groups elements of list together by the string returned from the function f called on each element. It returns an attribute set where each attribute value contains the elements of list that are mapped to the same corresponding attribute name returned by f. For example, builtins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"] evaluates to. { b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; } Noogle also knows. Aliases. lib.groupBy. lib.lists.groupBy.",
    "word_count": 80,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.groupBy Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.groupBy Primop. Takes 2 arguments. f, list. Groups elements of list together by the string returned from the function f called on each element. It returns an attribute set where each attribute value contains the elements of list that are mapped to the same corresponding attribute name returned by f. For example, builtins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"] evaluates to. { b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; } Noogle also knows. Aliases. lib.groupBy. lib.lists.groupBy.",
    "raw_url": "/f/builtins/groupBy.html",
    "excerpt": "builtins.groupBy Primop. Takes 2 arguments. f, list. Groups elements of list together by the string returned from the function f called on each element. It returns an attribute set where",
    "sub_results": []
  },
  {
    "url": "/f/builtins/floor.html",
    "content": "builtins.floor Primop. Takes 1 arguments. double. Converts an IEEE-754 double-precision floating-point number (double) to the next lower integer. If the datatype is neither an integer nor a \"float\", an evaluation error will be thrown.",
    "word_count": 34,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.floor Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.floor Primop. Takes 1 arguments. double. Converts an IEEE-754 double-precision floating-point number (double) to the next lower integer. If the datatype is neither an integer nor a \"float\", an evaluation error will be thrown.",
    "raw_url": "/f/builtins/floor.html",
    "excerpt": "builtins.floor Primop. Takes 1 arguments. double. Converts an IEEE-754 double-precision floating-point number (double) to the next lower integer. If the datatype is neither an integer nor a \"float\", an evaluation",
    "sub_results": []
  },
  {
    "url": "/f/builtins/tail.html",
    "content": "builtins.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should generally be avoided since it's inefficient: unlike Haskell's tail, it takes O(n) time, so recursing over a list by repeatedly calling tail takes O(n^2) time. Noogle also knows. Aliases. lib.tail. lib.lists.tail. lib.strings.tail.",
    "word_count": 62,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.tail Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should generally be avoided since it's inefficient: unlike Haskell's tail, it takes O(n) time, so recursing over a list by repeatedly calling tail takes O(n^2) time. Noogle also knows. Aliases. lib.tail. lib.lists.tail. lib.strings.tail.",
    "raw_url": "/f/builtins/tail.html",
    "excerpt": "builtins.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should",
    "sub_results": []
  },
  {
    "url": "/f/builtins/elemAt.html",
    "content": "builtins.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of bounds. Noogle also knows. Aliases. lib.elemAt. lib.lists.elemAt. lib.strings.elemAt.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.elemAt Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of bounds. Noogle also knows. Aliases. lib.elemAt. lib.lists.elemAt. lib.strings.elemAt.",
    "raw_url": "/f/builtins/elemAt.html",
    "excerpt": "builtins.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of",
    "sub_results": []
  },
  {
    "url": "/f/builtins/scopedImport.html",
    "content": "builtins.scopedImport Primop. Takes 2 arguments.",
    "word_count": 5,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.scopedImport Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.scopedImport Primop. Takes 2 arguments.",
    "raw_url": "/f/builtins/scopedImport.html",
    "excerpt": "builtins.scopedImport Primop. Takes 2 arguments.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/any.html",
    "content": "builtins.any Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for at least one element of list. Example. any isString [ 1 \"a\" { } ] => true any isString [ 1 { } ] => false Type. any :: (a -> bool) -> [a] -> bool Edit source. Noogle also knows. Aliases. lib.any. lib.lists.any.",
    "word_count": 59,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.any Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 21
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.any Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for at least one element of list. Example. any isString [ 1 \"a\" { } ] =&gt; true any isString [ 1 { } ] =&gt; false Type. any :: (a -&gt; bool) -&gt; [a] -&gt; bool Edit source. Noogle also knows. Aliases. lib.any. lib.lists.any.",
    "raw_url": "/f/builtins/any.html",
    "excerpt": "builtins.any Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for at least one element of list. Example. any isString [ 1 \"a\" { } ]",
    "sub_results": []
  },
  {
    "url": "/f/builtins/toXML.html",
    "content": "builtins.toXML Primop. Takes 1 arguments. e. Return a string containing an XML representation of e. The main application for toXML is to communicate information with the builder in a more structured format than plain environment variables. Here is an example where this is the case: { stdenv, fetchurl, libxslt, jira, uberwiki }: stdenv.mkDerivation (rec { name = \"web-server\"; buildInputs = [ libxslt ]; builder = builtins.toFile \"builder.sh\" \" source $stdenv/setup mkdir $out echo \"$servlets\" | xsltproc ${stylesheet} - > $out/server-conf.xml ① \"; stylesheet = builtins.toFile \"stylesheet.xsl\" ② \"<?xml version='1.0' encoding='UTF-8'?> <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'> <xsl:template match='/'> <Configure> <xsl:for-each select='/expr/list/attrs'> <Call name='addWebApplication'> <Arg><xsl:value-of select=\\\"attr[@name = 'path']/string/@value\\\" /></Arg> <Arg><xsl:value-of select=\\\"attr[@name = 'war']/path/@value\\\" /></Arg> </Call> </xsl:for-each> </Configure> </xsl:template> </xsl:stylesheet> \"; servlets = builtins.toXML [ ③ { path = \"/bugtracker\"; war = jira + \"/lib/atlassian-jira.war\"; } { path = \"/wiki\"; war = uberwiki + \"/uberwiki.war\"; } ]; }) The builder is supposed to generate the configuration file for a Jetty servlet container. A servlet container contains a number of servlets (*.war files) each exported under a specific URI prefix. So the servlet configuration is a list of sets containing the path and war of the servlet (①). This kind of information is difficult to communicate with the normal method of passing information through an environment variable, which just concatenates everything together into a string (which might just work in this case, but wouldn’t work if fields are optional or contain lists themselves). Instead the Nix expression is converted to an XML representation with toXML, which is unambiguous and can easily be processed with the appropriate tools. For instance, in the example an XSLT stylesheet (at point ②) is applied to it (at point ①) to generate the XML configuration file for the Jetty server. The XML representation produced at point ③ by toXML is as follows: <?xml version='1.0' encoding='utf-8'?> <expr> <list> <attrs> <attr name=\"path\"> <string value=\"/bugtracker\" /> </attr> <attr name=\"war\"> <path value=\"/nix/store/d1jh9pasa7k2...-jira/lib/atlassian-jira.war\" /> </attr> </attrs> <attrs> <attr name=\"path\"> <string value=\"/wiki\" /> </attr> <attr name=\"war\"> <path value=\"/nix/store/y6423b1yi4sx...-uberwiki/uberwiki.war\" /> </attr> </attrs> </list> </expr> Note that we used the toFile built-in to write the builder and the stylesheet “inline” in the Nix expression. The path of the stylesheet is spliced into the builder using the syntax xsltproc ${stylesheet}.",
    "word_count": 370,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.toXML Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.toXML Primop. Takes 1 arguments. e. Return a string containing an XML representation of e. The main application for toXML is to communicate information with the builder in a more structured format than plain environment variables. Here is an example where this is the case: { stdenv, fetchurl, libxslt, jira, uberwiki }: stdenv.mkDerivation (rec { name = \"web-server\"; buildInputs = [ libxslt ]; builder = builtins.toFile \"builder.sh\" \" source $stdenv/setup mkdir $out echo \"$servlets\" | xsltproc ${stylesheet} - &gt; $out/server-conf.xml ① \"; stylesheet = builtins.toFile \"stylesheet.xsl\" ② \"&lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'&gt; &lt;xsl:template match='/'&gt; &lt;Configure&gt; &lt;xsl:for-each select='/expr/list/attrs'&gt; &lt;Call name='addWebApplication'&gt; &lt;Arg&gt;&lt;xsl:value-of select=\\\"attr[@name = 'path']/string/@value\\\" /&gt;&lt;/Arg&gt; &lt;Arg&gt;&lt;xsl:value-of select=\\\"attr[@name = 'war']/path/@value\\\" /&gt;&lt;/Arg&gt; &lt;/Call&gt; &lt;/xsl:for-each&gt; &lt;/Configure&gt; &lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt; \"; servlets = builtins.toXML [ ③ { path = \"/bugtracker\"; war = jira + \"/lib/atlassian-jira.war\"; } { path = \"/wiki\"; war = uberwiki + \"/uberwiki.war\"; } ]; }) The builder is supposed to generate the configuration file for a Jetty servlet container. A servlet container contains a number of servlets (*.war files) each exported under a specific URI prefix. So the servlet configuration is a list of sets containing the path and war of the servlet (①). This kind of information is difficult to communicate with the normal method of passing information through an environment variable, which just concatenates everything together into a string (which might just work in this case, but wouldn’t work if fields are optional or contain lists themselves). Instead the Nix expression is converted to an XML representation with toXML, which is unambiguous and can easily be processed with the appropriate tools. For instance, in the example an XSLT stylesheet (at point ②) is applied to it (at point ①) to generate the XML configuration file for the Jetty server. The XML representation produced at point ③ by toXML is as follows: &lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;expr&gt; &lt;list&gt; &lt;attrs&gt; &lt;attr name=\"path\"&gt; &lt;string value=\"/bugtracker\" /&gt; &lt;/attr&gt; &lt;attr name=\"war\"&gt; &lt;path value=\"/nix/store/d1jh9pasa7k2...-jira/lib/atlassian-jira.war\" /&gt; &lt;/attr&gt; &lt;/attrs&gt; &lt;attrs&gt; &lt;attr name=\"path\"&gt; &lt;string value=\"/wiki\" /&gt; &lt;/attr&gt; &lt;attr name=\"war\"&gt; &lt;path value=\"/nix/store/y6423b1yi4sx...-uberwiki/uberwiki.war\" /&gt; &lt;/attr&gt; &lt;/attrs&gt; &lt;/list&gt; &lt;/expr&gt; Note that we used the toFile built-in to write the builder and the stylesheet “inline” in the Nix expression. The path of the stylesheet is spliced into the builder using the syntax xsltproc ${stylesheet}.",
    "raw_url": "/f/builtins/toXML.html",
    "excerpt": "builtins.toXML Primop. Takes 1 arguments. e. Return a string containing an XML representation of e. The main application for toXML is to communicate information with the builder in a more",
    "sub_results": []
  },
  {
    "url": "/f/builtins/isAttrs.html",
    "content": "builtins.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. lib.isAttrs. lib.attrsets.isAttrs. lib.strings.isAttrs.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.isAttrs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. lib.isAttrs. lib.attrsets.isAttrs. lib.strings.isAttrs.",
    "raw_url": "/f/builtins/isAttrs.html",
    "excerpt": "builtins.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. lib.isAttrs. lib.attrsets.isAttrs. lib.strings.isAttrs.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/mapAttrs.html",
    "content": "builtins.mapAttrs Primop. Takes 2 arguments. f, attrset. Apply a function to each element in an attribute set, creating a new attribute set. Example. mapAttrs (name: value: name + \"-\" + value) { x = \"foo\"; y = \"bar\"; } => { x = \"x-foo\"; y = \"y-bar\"; } Type. mapAttrs :: (String -> Any -> Any) -> AttrSet -> AttrSet Edit source. Noogle also knows. Aliases. lib.mapAttrs. lib.attrsets.mapAttrs.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.mapAttrs Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 22
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 48
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.mapAttrs Primop. Takes 2 arguments. f, attrset. Apply a function to each element in an attribute set, creating a new attribute set. Example. mapAttrs (name: value: name + \"-\" + value) { x = \"foo\"; y = \"bar\"; } =&gt; { x = \"x-foo\"; y = \"y-bar\"; } Type. mapAttrs :: (String -&gt; Any -&gt; Any) -&gt; AttrSet -&gt; AttrSet Edit source. Noogle also knows. Aliases. lib.mapAttrs. lib.attrsets.mapAttrs.",
    "raw_url": "/f/builtins/mapAttrs.html",
    "excerpt": "builtins.mapAttrs Primop. Takes 2 arguments. f, attrset. Apply a function to each element in an attribute set, creating a new attribute set. Example. mapAttrs (name: value: name + \"-\" +",
    "sub_results": []
  },
  {
    "url": "/f/builtins/fetchGit.html",
    "content": "builtins.fetchGit Primop. Takes 1 arguments. args. Fetch a path from git. args can be a URL, in which case the HEAD of the repo at that URL is fetched. Otherwise, it can be an attribute with the following attributes (all except url optional): url. The URL of the repo. name (default: basename of the URL). The name of the directory the repo should be exported to in the store. rev (default: the tip of ref). The Git revision to fetch. This is typically a commit hash. ref (default: HEAD). The Git reference under which to look for the requested revision. This is often a branch or tag name. By default, the ref value is prefixed with refs/heads/. As of 2.3.0, Nix will not prefix refs/heads/ if ref starts with refs/. submodules (default: false). A Boolean parameter that specifies whether submodules should be checked out. shallow (default: false). A Boolean parameter that specifies whether fetching a shallow clone is allowed. allRefs. Whether to fetch all references of the repository. With this argument being true, it's possible to load a rev from any ref (by default only revs from the specified ref are supported). Here are some examples of how to use fetchGit. To fetch a private repository over SSH: builtins.fetchGit { url = \"git@github.com:my-secret/repository.git\"; ref = \"master\"; rev = \"adab8b916a45068c044658c4158d81878f9ed1c3\"; } To fetch an arbitrary reference: builtins.fetchGit { url = \"https://github.com/NixOS/nix.git\"; ref = \"refs/heads/0.5-release\"; } If the revision you're looking for is in the default branch of the git repository you don't strictly need to specify the branch name in the ref attribute. However, if the revision you're looking for is in a future branch for the non-default branch you will need to specify the the ref attribute as well. builtins.fetchGit { url = \"https://github.com/nixos/nix.git\"; rev = \"841fcbd04755c7a2865c51c1e2d3b045976b7452\"; ref = \"1.11-maintenance\"; } Note. It is nice to always specify the branch which a revision belongs to. Without the branch being specified, the fetcher might fail if the default branch changes. Additionally, it can be confusing to try a commit from a non-default branch and see the fetch fail. If the branch is specified the fault is much more obvious. If the revision you're looking for is in the default branch of the git repository you may omit the ref attribute. builtins.fetchGit { url = \"https://github.com/nixos/nix.git\"; rev = \"841fcbd04755c7a2865c51c1e2d3b045976b7452\"; } To fetch a specific tag: builtins.fetchGit { url = \"https://github.com/nixos/nix.git\"; ref = \"refs/tags/1.9\"; } To fetch the latest version of a remote branch: builtins.fetchGit { url = \"ssh://git@github.com/nixos/nix.git\"; ref = \"master\"; } Nix will refetch the branch according to the tarball-ttl setting. This behavior is disabled in pure evaluation mode. To fetch the content of a checked-out work directory: builtins.fetchGit ./work-dir If the URL points to a local directory, and no ref or rev is given, fetchGit will use the current content of the checked-out files, even if they are not committed or added to Git's index. It will only consider files added to the Git repository, as listed by git ls-files.",
    "word_count": 500,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.fetchGit Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.fetchGit Primop. Takes 1 arguments. args. Fetch a path from git. args can be a URL, in which case the HEAD of the repo at that URL is fetched. Otherwise, it can be an attribute with the following attributes (all except url optional): url. The URL of the repo. name (default: basename of the URL). The name of the directory the repo should be exported to in the store. rev (default: the tip of ref). The Git revision to fetch. This is typically a commit hash. ref (default: HEAD). The Git reference under which to look for the requested revision. This is often a branch or tag name. By default, the ref value is prefixed with refs/heads/. As of 2.3.0, Nix will not prefix refs/heads/ if ref starts with refs/. submodules (default: false). A Boolean parameter that specifies whether submodules should be checked out. shallow (default: false). A Boolean parameter that specifies whether fetching a shallow clone is allowed. allRefs. Whether to fetch all references of the repository. With this argument being true, it's possible to load a rev from any ref (by default only revs from the specified ref are supported). Here are some examples of how to use fetchGit. To fetch a private repository over SSH: builtins.fetchGit { url = \"git@github.com:my-secret/repository.git\"; ref = \"master\"; rev = \"adab8b916a45068c044658c4158d81878f9ed1c3\"; } To fetch an arbitrary reference: builtins.fetchGit { url = \"https://github.com/NixOS/nix.git\"; ref = \"refs/heads/0.5-release\"; } If the revision you're looking for is in the default branch of the git repository you don't strictly need to specify the branch name in the ref attribute. However, if the revision you're looking for is in a future branch for the non-default branch you will need to specify the the ref attribute as well. builtins.fetchGit { url = \"https://github.com/nixos/nix.git\"; rev = \"841fcbd04755c7a2865c51c1e2d3b045976b7452\"; ref = \"1.11-maintenance\"; } Note. It is nice to always specify the branch which a revision belongs to. Without the branch being specified, the fetcher might fail if the default branch changes. Additionally, it can be confusing to try a commit from a non-default branch and see the fetch fail. If the branch is specified the fault is much more obvious. If the revision you're looking for is in the default branch of the git repository you may omit the ref attribute. builtins.fetchGit { url = \"https://github.com/nixos/nix.git\"; rev = \"841fcbd04755c7a2865c51c1e2d3b045976b7452\"; } To fetch a specific tag: builtins.fetchGit { url = \"https://github.com/nixos/nix.git\"; ref = \"refs/tags/1.9\"; } To fetch the latest version of a remote branch: builtins.fetchGit { url = \"ssh://git@github.com/nixos/nix.git\"; ref = \"master\"; } Nix will refetch the branch according to the tarball-ttl setting. This behavior is disabled in pure evaluation mode. To fetch the content of a checked-out work directory: builtins.fetchGit ./work-dir If the URL points to a local directory, and no ref or rev is given, fetchGit will use the current content of the checked-out files, even if they are not committed or added to Git's index. It will only consider files added to the Git repository, as listed by git ls-files.",
    "raw_url": "/f/builtins/fetchGit.html",
    "excerpt": "builtins.fetchGit Primop. Takes 1 arguments. args. Fetch a path from git. args can be a URL, in which case the HEAD of the repo at that URL is fetched. Otherwise,",
    "sub_results": []
  },
  {
    "url": "/f/builtins/fromTOML.html",
    "content": "builtins.fromTOML Primop. Takes 1 arguments. e. Convert a TOML string to a Nix value. For example, builtins.fromTOML '' x=1 s=\"a\" [table] y=2 '' returns the value { s = \"a\"; table = { y = 2; }; x = 1; }.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.fromTOML Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.fromTOML Primop. Takes 1 arguments. e. Convert a TOML string to a Nix value. For example, builtins.fromTOML '' x=1 s=\"a\" [table] y=2 '' returns the value { s = \"a\"; table = { y = 2; }; x = 1; }.",
    "raw_url": "/f/builtins/fromTOML.html",
    "excerpt": "builtins.fromTOML Primop. Takes 1 arguments. e. Convert a TOML string to a Nix value. For example, builtins.fromTOML '' x=1 s=\"a\" [table] y=2 '' returns the value { s = \"a\";",
    "sub_results": []
  },
  {
    "url": "/f/builtins/attrNames.html",
    "content": "builtins.attrNames Primop. Takes 1 arguments. set. Return the names of the attributes in the set set in an alphabetically sorted list. For instance, builtins.attrNames { y = 1; x = \"foo\"; } evaluates to [ \"x\" \"y\" ]. Noogle also knows. Aliases. lib.attrNames. lib.attrsets.attrNames.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.attrNames Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.attrNames Primop. Takes 1 arguments. set. Return the names of the attributes in the set set in an alphabetically sorted list. For instance, builtins.attrNames { y = 1; x = \"foo\"; } evaluates to [ \"x\" \"y\" ]. Noogle also knows. Aliases. lib.attrNames. lib.attrsets.attrNames.",
    "raw_url": "/f/builtins/attrNames.html",
    "excerpt": "builtins.attrNames Primop. Takes 1 arguments. set. Return the names of the attributes in the set set in an alphabetically sorted list. For instance, builtins.attrNames { y = 1; x =",
    "sub_results": []
  },
  {
    "url": "/f/builtins/match.html",
    "content": "builtins.match Primop. Takes 2 arguments. regex, str. Returns a list if the extended POSIX regular expression regex matches str precisely, otherwise returns null. Each item in the list is a regex group. builtins.match \"ab\" \"abc\" Evaluates to null. builtins.match \"abc\" \"abc\" Evaluates to [ ]. builtins.match \"a(b)(c)\" \"abc\" Evaluates to [ \"b\" \"c\" ]. builtins.match \"[[:space:]]+([[:upper:]]+)[[:space:]]+\" \" FOO \" Evaluates to [ \"FOO\" ]. Noogle also knows. Aliases. lib.strings.match.",
    "word_count": 69,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.match Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.match Primop. Takes 2 arguments. regex, str. Returns a list if the extended POSIX regular expression regex matches str precisely, otherwise returns null. Each item in the list is a regex group. builtins.match \"ab\" \"abc\" Evaluates to null. builtins.match \"abc\" \"abc\" Evaluates to [ ]. builtins.match \"a(b)(c)\" \"abc\" Evaluates to [ \"b\" \"c\" ]. builtins.match \"[[:space:]]+([[:upper:]]+)[[:space:]]+\" \" FOO \" Evaluates to [ \"FOO\" ]. Noogle also knows. Aliases. lib.strings.match.",
    "raw_url": "/f/builtins/match.html",
    "excerpt": "builtins.match Primop. Takes 2 arguments. regex, str. Returns a list if the extended POSIX regular expression regex matches str precisely, otherwise returns null. Each item in the list is a",
    "sub_results": []
  },
  {
    "url": "/f/builtins/sub.html",
    "content": "builtins.sub Primop. Takes 2 arguments. e1, e2. Return the difference between the numbers e1 and e2. Noogle also knows. Aliases. lib.sub. lib.trivial.sub.",
    "word_count": 22,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.sub Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.sub Primop. Takes 2 arguments. e1, e2. Return the difference between the numbers e1 and e2. Noogle also knows. Aliases. lib.sub. lib.trivial.sub.",
    "raw_url": "/f/builtins/sub.html",
    "excerpt": "builtins.sub Primop. Takes 2 arguments. e1, e2. Return the difference between the numbers e1 and e2. Noogle also knows. Aliases. lib.sub. lib.trivial.sub.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/getContext.html",
    "content": "builtins.getContext Primop. Takes 1 arguments. s. Return the string context of s. The string context tracks references to derivations within a string. It is represented as an attribute set of store derivation paths mapping to output names. Using string interpolation on a derivation will add that derivation to the string context. For example, builtins.getContext \"${derivation { name = \"a\"; builder = \"b\"; system = \"c\"; }}\" evaluates to. { \"/nix/store/arhvjaf6zmlyn8vh8fgn55rpwnxq0n7l-a.drv\" = { outputs = [ \"out\" ]; }; }",
    "word_count": 79,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.getContext Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.getContext Primop. Takes 1 arguments. s. Return the string context of s. The string context tracks references to derivations within a string. It is represented as an attribute set of store derivation paths mapping to output names. Using string interpolation on a derivation will add that derivation to the string context. For example, builtins.getContext \"${derivation { name = \"a\"; builder = \"b\"; system = \"c\"; }}\" evaluates to. { \"/nix/store/arhvjaf6zmlyn8vh8fgn55rpwnxq0n7l-a.drv\" = { outputs = [ \"out\" ]; }; }",
    "raw_url": "/f/builtins/getContext.html",
    "excerpt": "builtins.getContext Primop. Takes 1 arguments. s. Return the string context of s. The string context tracks references to derivations within a string. It is represented as an attribute set of",
    "sub_results": []
  },
  {
    "url": "/f/builtins/deepSeq.html",
    "content": "builtins.deepSeq Primop. Takes 2 arguments. e1, e2. This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are also evaluated recursively. Noogle also knows. Aliases. lib.deepSeq. lib.trivial.deepSeq.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.deepSeq Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.deepSeq Primop. Takes 2 arguments. e1, e2. This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are also evaluated recursively. Noogle also knows. Aliases. lib.deepSeq. lib.trivial.deepSeq.",
    "raw_url": "/f/builtins/deepSeq.html",
    "excerpt": "builtins.deepSeq Primop. Takes 2 arguments. e1, e2. This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are",
    "sub_results": []
  },
  {
    "url": "/f/builtins/elem.html",
    "content": "builtins.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. lib.elem. lib.lists.elem. lib.strings.elem.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.elem Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. lib.elem. lib.lists.elem. lib.strings.elem.",
    "raw_url": "/f/builtins/elem.html",
    "excerpt": "builtins.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. lib.elem. lib.lists.elem. lib.strings.elem.",
    "sub_results": []
  },
  {
    "url": "/f/builtins/catAttrs.html",
    "content": "builtins.catAttrs Primop. Takes 2 arguments. attr, list. Collect each attribute named attr from a list of attribute sets. Sets that don't contain the named attribute are ignored. Example. catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}] => [1 2] Type. catAttrs :: String -> [AttrSet] -> [Any] Edit source. Noogle also knows. Aliases. lib.catAttrs. lib.attrsets.catAttrs.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.catAttrs Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 27
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.catAttrs Primop. Takes 2 arguments. attr, list. Collect each attribute named attr from a list of attribute sets. Sets that don't contain the named attribute are ignored. Example. catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}] =&gt; [1 2] Type. catAttrs :: String -&gt; [AttrSet] -&gt; [Any] Edit source. Noogle also knows. Aliases. lib.catAttrs. lib.attrsets.catAttrs.",
    "raw_url": "/f/builtins/catAttrs.html",
    "excerpt": "builtins.catAttrs Primop. Takes 2 arguments. attr, list. Collect each attribute named attr from a list of attribute sets. Sets that don't contain the named attribute are ignored. Example. catAttrs \"a\"",
    "sub_results": []
  },
  {
    "url": "/f/builtins/isInt.html",
    "content": "builtins.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. lib.isInt. lib.strings.isInt. lib.trivial.isInt.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "builtins.isInt Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "builtins.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. lib.isInt. lib.strings.isInt. lib.trivial.isInt.",
    "raw_url": "/f/builtins/isInt.html",
    "excerpt": "builtins.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. lib.isInt. lib.strings.isInt. lib.trivial.isInt.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildEmscriptenPackage.html",
    "content": "pkgs.buildEmscriptenPackage.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildEmscriptenPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildEmscriptenPackage.",
    "raw_url": "/f/pkgs/buildEmscriptenPackage.html",
    "excerpt": "pkgs.buildEmscriptenPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildGoPackage.html",
    "content": "pkgs.buildGoPackage.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildGoPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildGoPackage.",
    "raw_url": "/f/pkgs/buildGoPackage.html",
    "excerpt": "pkgs.buildGoPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/enableSharedLibraries.html",
    "content": "pkgs.haskell.lib.enableSharedLibraries.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.enableSharedLibraries"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.enableSharedLibraries.",
    "raw_url": "/f/pkgs/haskell/lib/enableSharedLibraries.html",
    "excerpt": "pkgs.haskell.lib.enableSharedLibraries.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/controlPhases.html",
    "content": "pkgs.haskell.lib.controlPhases. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.controlPhases"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.controlPhases. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/controlPhases.html",
    "excerpt": "pkgs.haskell.lib.controlPhases. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/buildFromSdist.html",
    "content": "pkgs.haskell.lib.buildFromSdist. Build a source distribution tarball instead of using the source files directly. The effect is that the package is built as if it were published on hackage. This can be used as a test for the source distribution, assuming the build fails when packaging mistakes are in the cabal file. Edit source.",
    "word_count": 53,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.buildFromSdist"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.buildFromSdist. Build a source distribution tarball instead of using the source files directly. The effect is that the package is built as if it were published on hackage. This can be used as a test for the source distribution, assuming the build fails when packaging mistakes are in the cabal file. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/buildFromSdist.html",
    "excerpt": "pkgs.haskell.lib.buildFromSdist. Build a source distribution tarball instead of using the source files directly. The effect is that the package is built as if it were published on hackage. This can",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/enableDeadCodeElimination.html",
    "content": "pkgs.haskell.lib.enableDeadCodeElimination.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.enableDeadCodeElimination"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.enableDeadCodeElimination.",
    "raw_url": "/f/pkgs/haskell/lib/enableDeadCodeElimination.html",
    "excerpt": "pkgs.haskell.lib.enableDeadCodeElimination.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addBuildTools.html",
    "content": "pkgs.haskell.lib.addBuildTools. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addBuildTools"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addBuildTools. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addBuildTools.html",
    "excerpt": "pkgs.haskell.lib.addBuildTools. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addOptparseApplicativeCompletionScripts.html",
    "content": "pkgs.haskell.lib.addOptparseApplicativeCompletionScripts. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addOptparseApplicativeCompletionScripts"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addOptparseApplicativeCompletionScripts. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addOptparseApplicativeCompletionScripts.html",
    "excerpt": "pkgs.haskell.lib.addOptparseApplicativeCompletionScripts. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/setBuildTarget.html",
    "content": "pkgs.haskell.lib.setBuildTarget. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.setBuildTarget"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.setBuildTarget. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/setBuildTarget.html",
    "excerpt": "pkgs.haskell.lib.setBuildTarget. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/setBuildTargets.html",
    "content": "pkgs.haskell.lib.setBuildTargets. Set a specific build target instead of compiling all targets in the package. For example, imagine we have a .cabal file with a library, and 2 executables \"dev\" and \"server\". We can build only \"server\" and not wait on the compilation of \"dev\" by using setBuildTarget as follows: setBuildTarget (callCabal2nix \"thePackageName\" thePackageSrc {}) \"server\" Arguments. [drv] [xs] Edit source.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.setBuildTargets"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.setBuildTargets. Set a specific build target instead of compiling all targets in the package. For example, imagine we have a .cabal file with a library, and 2 executables \"dev\" and \"server\". We can build only \"server\" and not wait on the compilation of \"dev\" by using setBuildTarget as follows: setBuildTarget (callCabal2nix \"thePackageName\" thePackageSrc {}) \"server\" Arguments. [drv] [xs] Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/setBuildTargets.html",
    "excerpt": "pkgs.haskell.lib.setBuildTargets. Set a specific build target instead of compiling all targets in the package. For example, imagine we have a .cabal file with a library, and 2 executables \"dev\" and",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/appendBuildFlags.html",
    "content": "pkgs.haskell.lib.appendBuildFlags. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.appendBuildFlags"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.appendBuildFlags. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/appendBuildFlags.html",
    "excerpt": "pkgs.haskell.lib.appendBuildFlags. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/disableSharedExecutables.html",
    "content": "pkgs.haskell.lib.disableSharedExecutables.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.disableSharedExecutables"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.disableSharedExecutables.",
    "raw_url": "/f/pkgs/haskell/lib/disableSharedExecutables.html",
    "excerpt": "pkgs.haskell.lib.disableSharedExecutables.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addSetupDepends.html",
    "content": "pkgs.haskell.lib.addSetupDepends. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addSetupDepends"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addSetupDepends. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addSetupDepends.html",
    "excerpt": "pkgs.haskell.lib.addSetupDepends. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/disableLibraryProfiling.html",
    "content": "pkgs.haskell.lib.disableLibraryProfiling.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.disableLibraryProfiling"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.disableLibraryProfiling.",
    "raw_url": "/f/pkgs/haskell/lib/disableLibraryProfiling.html",
    "excerpt": "pkgs.haskell.lib.disableLibraryProfiling.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addBuildTool.html",
    "content": "pkgs.haskell.lib.addBuildTool. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addBuildTool"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addBuildTool. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addBuildTool.html",
    "excerpt": "pkgs.haskell.lib.addBuildTool. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/overrideSrc.html",
    "content": "pkgs.haskell.lib.overrideSrc. Override the sources for the package and optionally the version. This also takes of removing editedCabalFile. Arguments. [drv] [src] Edit source.",
    "word_count": 22,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.overrideSrc"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.overrideSrc. Override the sources for the package and optionally the version. This also takes of removing editedCabalFile. Arguments. [drv] [src] Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/overrideSrc.html",
    "excerpt": "pkgs.haskell.lib.overrideSrc. Override the sources for the package and optionally the version. This also takes of removing editedCabalFile. Arguments. [drv] [src] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/ghcInfo.html",
    "content": "pkgs.haskell.lib.ghcInfo. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.ghcInfo"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.ghcInfo. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/ghcInfo.html",
    "excerpt": "pkgs.haskell.lib.ghcInfo. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/generateOptparseApplicativeCompletions.html",
    "content": "pkgs.haskell.lib.generateOptparseApplicativeCompletions. Modify a Haskell package to add shell completion scripts for the given executables produced by it. These completion scripts will be picked up automatically if the resulting derivation is installed, e.g. by nix-env -i. Invocation: generateOptparseApplicativeCompletions commands pkg commands: name of an executable pkg: Haskell package that builds the executables. Edit source.",
    "word_count": 53,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.generateOptparseApplicativeCompletions"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.generateOptparseApplicativeCompletions. Modify a Haskell package to add shell completion scripts for the given executables produced by it. These completion scripts will be picked up automatically if the resulting derivation is installed, e.g. by nix-env -i. Invocation: generateOptparseApplicativeCompletions commands pkg commands: name of an executable pkg: Haskell package that builds the executables. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/generateOptparseApplicativeCompletions.html",
    "excerpt": "pkgs.haskell.lib.generateOptparseApplicativeCompletions. Modify a Haskell package to add shell completion scripts for the given executables produced by it. These completion scripts will be picked up automatically if the resulting derivation is",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/shellAware.html",
    "content": "pkgs.haskell.lib.shellAware. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.shellAware"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.shellAware. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/shellAware.html",
    "excerpt": "pkgs.haskell.lib.shellAware. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/enableLibraryProfiling.html",
    "content": "pkgs.haskell.lib.enableLibraryProfiling.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.enableLibraryProfiling"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.enableLibraryProfiling.",
    "raw_url": "/f/pkgs/haskell/lib/enableLibraryProfiling.html",
    "excerpt": "pkgs.haskell.lib.enableLibraryProfiling.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/appendConfigureFlags.html",
    "content": "pkgs.haskell.lib.appendConfigureFlags. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.appendConfigureFlags"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.appendConfigureFlags. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/appendConfigureFlags.html",
    "excerpt": "pkgs.haskell.lib.appendConfigureFlags. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/markBrokenVersion.html",
    "content": "pkgs.haskell.lib.markBrokenVersion. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.markBrokenVersion"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.markBrokenVersion. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/markBrokenVersion.html",
    "excerpt": "pkgs.haskell.lib.markBrokenVersion. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/dontCheck.html",
    "content": "pkgs.haskell.lib.dontCheck. dontCheck disables dependency checking, compilation and execution of test suites listed in the package description file. Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.dontCheck"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.dontCheck. dontCheck disables dependency checking, compilation and execution of test suites listed in the package description file. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/dontCheck.html",
    "excerpt": "pkgs.haskell.lib.dontCheck. dontCheck disables dependency checking, compilation and execution of test suites listed in the package description file. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/appendPatch.html",
    "content": "pkgs.haskell.lib.appendPatch. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.appendPatch"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.appendPatch. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/appendPatch.html",
    "excerpt": "pkgs.haskell.lib.appendPatch. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/triggerRebuild.html",
    "content": "pkgs.haskell.lib.triggerRebuild. Add a dummy command to trigger a build despite an equivalent earlier build that is present in the store or cache. Arguments. [drv] [i] Edit source.",
    "word_count": 27,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.triggerRebuild"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 22
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.triggerRebuild. Add a dummy command to trigger a build despite an equivalent earlier build that is present in the store or cache. Arguments. [drv] [i] Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/triggerRebuild.html",
    "excerpt": "pkgs.haskell.lib.triggerRebuild. Add a dummy command to trigger a build despite an equivalent earlier build that is present in the store or cache. Arguments. [drv] [i] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/getBuildInputs.html",
    "content": "pkgs.haskell.lib.getBuildInputs. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.getBuildInputs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.getBuildInputs. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/getBuildInputs.html",
    "excerpt": "pkgs.haskell.lib.getBuildInputs. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/doStrip.html",
    "content": "pkgs.haskell.lib.doStrip. Let Nix strip the binary files. This removes debugging symbols. Edit source.",
    "word_count": 13,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.doStrip"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.doStrip. Let Nix strip the binary files. This removes debugging symbols. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/doStrip.html",
    "excerpt": "pkgs.haskell.lib.doStrip. Let Nix strip the binary files. This removes debugging symbols. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/disableStaticLibraries.html",
    "content": "pkgs.haskell.lib.disableStaticLibraries.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.disableStaticLibraries"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.disableStaticLibraries.",
    "raw_url": "/f/pkgs/haskell/lib/disableStaticLibraries.html",
    "excerpt": "pkgs.haskell.lib.disableStaticLibraries.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/disableSharedLibraries.html",
    "content": "pkgs.haskell.lib.disableSharedLibraries.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.disableSharedLibraries"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.disableSharedLibraries.",
    "raw_url": "/f/pkgs/haskell/lib/disableSharedLibraries.html",
    "excerpt": "pkgs.haskell.lib.disableSharedLibraries.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/enableCabalFlag.html",
    "content": "pkgs.haskell.lib.enableCabalFlag. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.enableCabalFlag"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.enableCabalFlag. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/enableCabalFlag.html",
    "excerpt": "pkgs.haskell.lib.enableCabalFlag. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addPkgconfigDepend.html",
    "content": "pkgs.haskell.lib.addPkgconfigDepend. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addPkgconfigDepend"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addPkgconfigDepend. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addPkgconfigDepend.html",
    "excerpt": "pkgs.haskell.lib.addPkgconfigDepend. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/enableSeparateBinOutput.html",
    "content": "pkgs.haskell.lib.enableSeparateBinOutput.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.enableSeparateBinOutput"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.enableSeparateBinOutput.",
    "raw_url": "/f/pkgs/haskell/lib/enableSeparateBinOutput.html",
    "excerpt": "pkgs.haskell.lib.enableSeparateBinOutput.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/failOnAllWarnings.html",
    "content": "pkgs.haskell.lib.failOnAllWarnings. Turn on most of the compiler warnings and fail the build if any of them occur. Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.failOnAllWarnings"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.failOnAllWarnings. Turn on most of the compiler warnings and fail the build if any of them occur. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/failOnAllWarnings.html",
    "excerpt": "pkgs.haskell.lib.failOnAllWarnings. Turn on most of the compiler warnings and fail the build if any of them occur. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/getHaskellBuildInputs.html",
    "content": "pkgs.haskell.lib.getHaskellBuildInputs. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.getHaskellBuildInputs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.getHaskellBuildInputs. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/getHaskellBuildInputs.html",
    "excerpt": "pkgs.haskell.lib.getHaskellBuildInputs. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/dontCoverage.html",
    "content": "pkgs.haskell.lib.dontCoverage. dontCoverage modifies a haskell package to disable the generation and installation of a coverage report. Edit source.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.dontCoverage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.dontCoverage. dontCoverage modifies a haskell package to disable the generation and installation of a coverage report. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/dontCoverage.html",
    "excerpt": "pkgs.haskell.lib.dontCoverage. dontCoverage modifies a haskell package to disable the generation and installation of a coverage report. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/buildStrictly.html",
    "content": "pkgs.haskell.lib.buildStrictly. Build the package in a strict way to uncover potential problems. This includes buildFromSdist and failOnAllWarnings. Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.buildStrictly"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.buildStrictly. Build the package in a strict way to uncover potential problems. This includes buildFromSdist and failOnAllWarnings. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/buildStrictly.html",
    "excerpt": "pkgs.haskell.lib.buildStrictly. Build the package in a strict way to uncover potential problems. This includes buildFromSdist and failOnAllWarnings. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/overrideCabal.html",
    "content": "pkgs.haskell.lib.overrideCabal. The function overrideCabal lets you alter the arguments to the mkDerivation function. Example. First, note how the aeson package is constructed in hackage-packages.nix: \"aeson\" = callPackage ({ mkDerivation, attoparsec, <snip> }: mkDerivation { pname = \"aeson\"; <snip> homepage = \"https://github.com/bos/aeson\"; }) The mkDerivation function of haskellPackages will take care of putting the homepage in the right place, in meta. > haskellPackages.aeson.meta.homepage \"https://github.com/bos/aeson\" > x = haskell.lib.overrideCabal haskellPackages.aeson (old: { homepage = old.homepage + \"#readme\"; }) > x.meta.homepage \"https://github.com/bos/aeson#readme\" Arguments. [drv] [f] Edit source.",
    "word_count": 84,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.overrideCabal"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 79
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.overrideCabal. The function overrideCabal lets you alter the arguments to the mkDerivation function. Example. First, note how the aeson package is constructed in hackage-packages.nix: \"aeson\" = callPackage ({ mkDerivation, attoparsec, &lt;snip&gt; }: mkDerivation { pname = \"aeson\"; &lt;snip&gt; homepage = \"https://github.com/bos/aeson\"; }) The mkDerivation function of haskellPackages will take care of putting the homepage in the right place, in meta. &gt; haskellPackages.aeson.meta.homepage \"https://github.com/bos/aeson\" &gt; x = haskell.lib.overrideCabal haskellPackages.aeson (old: { homepage = old.homepage + \"#readme\"; }) &gt; x.meta.homepage \"https://github.com/bos/aeson#readme\" Arguments. [drv] [f] Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/overrideCabal.html",
    "excerpt": "pkgs.haskell.lib.overrideCabal. The function overrideCabal lets you alter the arguments to the mkDerivation function. Example. First, note how the aeson package is constructed in hackage-packages.nix: \"aeson\" = callPackage ({ mkDerivation, attoparsec,",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/doCheck.html",
    "content": "pkgs.haskell.lib.doCheck. doCheck enables dependency checking, compilation and execution of test suites listed in the package description file. Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.doCheck"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.doCheck. doCheck enables dependency checking, compilation and execution of test suites listed in the package description file. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/doCheck.html",
    "excerpt": "pkgs.haskell.lib.doCheck. doCheck enables dependency checking, compilation and execution of test suites listed in the package description file. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addTestToolDepends.html",
    "content": "pkgs.haskell.lib.addTestToolDepends. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addTestToolDepends"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addTestToolDepends. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addTestToolDepends.html",
    "excerpt": "pkgs.haskell.lib.addTestToolDepends. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/doBenchmark.html",
    "content": "pkgs.haskell.lib.doBenchmark. doBenchmark enables dependency checking, compilation and execution for benchmarks listed in the package description file. Edit source.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.doBenchmark"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.doBenchmark. doBenchmark enables dependency checking, compilation and execution for benchmarks listed in the package description file. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/doBenchmark.html",
    "excerpt": "pkgs.haskell.lib.doBenchmark. doBenchmark enables dependency checking, compilation and execution for benchmarks listed in the package description file. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/doJailbreak.html",
    "content": "pkgs.haskell.lib.doJailbreak. doJailbreak enables the removal of version bounds from the cabal file. You may want to avoid this function. This is useful when a package reports that it can not be built due to version mismatches. In some cases, removing the version bounds entirely is an easy way to make a package build, but at the risk of breaking software in non-obvious ways now or in the future. Instead of jailbreaking, you can patch the cabal file. Note that jailbreaking at this time, doesn't lift bounds on conditional branches. https://github.com/peti/jailbreak-cabal/issues/7 has further details. Edit source.",
    "word_count": 95,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.doJailbreak"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.doJailbreak. doJailbreak enables the removal of version bounds from the cabal file. You may want to avoid this function. This is useful when a package reports that it can not be built due to version mismatches. In some cases, removing the version bounds entirely is an easy way to make a package build, but at the risk of breaking software in non-obvious ways now or in the future. Instead of jailbreaking, you can patch the cabal file. Note that jailbreaking at this time, doesn't lift bounds on conditional branches. https://github.com/peti/jailbreak-cabal/issues/7 has further details. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/doJailbreak.html",
    "excerpt": "pkgs.haskell.lib.doJailbreak. doJailbreak enables the removal of version bounds from the cabal file. You may want to avoid this function. This is useful when a package reports that it can not",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/enableExecutableProfiling.html",
    "content": "pkgs.haskell.lib.enableExecutableProfiling.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.enableExecutableProfiling"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.enableExecutableProfiling.",
    "raw_url": "/f/pkgs/haskell/lib/enableExecutableProfiling.html",
    "excerpt": "pkgs.haskell.lib.enableExecutableProfiling.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/enableDWARFDebugging.html",
    "content": "pkgs.haskell.lib.enableDWARFDebugging. Useful for debugging segfaults with gdb. This includes dontStrip. Edit source.",
    "word_count": 12,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.enableDWARFDebugging"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.enableDWARFDebugging. Useful for debugging segfaults with gdb. This includes dontStrip. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/enableDWARFDebugging.html",
    "excerpt": "pkgs.haskell.lib.enableDWARFDebugging. Useful for debugging segfaults with gdb. This includes dontStrip. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/checkUnusedPackages.html",
    "content": "pkgs.haskell.lib.checkUnusedPackages. Add a post-build check to verify that dependencies declared in the cabal file are actually used. The first attrset argument can be used to configure the strictness of this check and a list of ignored package names that would otherwise cause false alarms. Edit source.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.checkUnusedPackages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.checkUnusedPackages. Add a post-build check to verify that dependencies declared in the cabal file are actually used. The first attrset argument can be used to configure the strictness of this check and a list of ignored package names that would otherwise cause false alarms. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/checkUnusedPackages.html",
    "excerpt": "pkgs.haskell.lib.checkUnusedPackages. Add a post-build check to verify that dependencies declared in the cabal file are actually used. The first attrset argument can be used to configure the strictness of this",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/disableOptimization.html",
    "content": "pkgs.haskell.lib.disableOptimization. Disable core optimizations, significantly speeds up build time. Edit source.",
    "word_count": 11,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.disableOptimization"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.disableOptimization. Disable core optimizations, significantly speeds up build time. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/disableOptimization.html",
    "excerpt": "pkgs.haskell.lib.disableOptimization. Disable core optimizations, significantly speeds up build time. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/generateOptparseApplicativeCompletion.html",
    "content": "pkgs.haskell.lib.generateOptparseApplicativeCompletion. Modify a Haskell package to add shell completion scripts for the given executable produced by it. These completion scripts will be picked up automatically if the resulting derivation is installed, e.g. by nix-env -i. Invocation: generateOptparseApplicativeCompletions command pkg command: name of an executable pkg: Haskell package that builds the executables. Edit source.",
    "word_count": 53,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.generateOptparseApplicativeCompletion"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.generateOptparseApplicativeCompletion. Modify a Haskell package to add shell completion scripts for the given executable produced by it. These completion scripts will be picked up automatically if the resulting derivation is installed, e.g. by nix-env -i. Invocation: generateOptparseApplicativeCompletions command pkg command: name of an executable pkg: Haskell package that builds the executables. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/generateOptparseApplicativeCompletion.html",
    "excerpt": "pkgs.haskell.lib.generateOptparseApplicativeCompletion. Modify a Haskell package to add shell completion scripts for the given executable produced by it. These completion scripts will be picked up automatically if the resulting derivation is",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/appendPatches.html",
    "content": "pkgs.haskell.lib.appendPatches. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.appendPatches"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.appendPatches. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/appendPatches.html",
    "excerpt": "pkgs.haskell.lib.appendPatches. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/dontHyperlinkSource.html",
    "content": "pkgs.haskell.lib.dontHyperlinkSource.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.dontHyperlinkSource"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.dontHyperlinkSource.",
    "raw_url": "/f/pkgs/haskell/lib/dontHyperlinkSource.html",
    "excerpt": "pkgs.haskell.lib.dontHyperlinkSource.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/buildStackProject.html",
    "content": "pkgs.haskell.lib.buildStackProject.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.buildStackProject"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.buildStackProject.",
    "raw_url": "/f/pkgs/haskell/lib/buildStackProject.html",
    "excerpt": "pkgs.haskell.lib.buildStackProject.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/removeConfigureFlag.html",
    "content": "pkgs.haskell.lib.removeConfigureFlag. removeConfigureFlag drv x is a Haskell package like drv, but with all cabal configure arguments that are equal to x removed. haskell.lib.removeConfigureFlag haskellPackages.servant \"--verbose\" Arguments. [drv] [x] Edit source.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.removeConfigureFlag"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.removeConfigureFlag. removeConfigureFlag drv x is a Haskell package like drv, but with all cabal configure arguments that are equal to x removed. haskell.lib.removeConfigureFlag haskellPackages.servant \"--verbose\" Arguments. [drv] [x] Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/removeConfigureFlag.html",
    "excerpt": "pkgs.haskell.lib.removeConfigureFlag. removeConfigureFlag drv x is a Haskell package like drv, but with all cabal configure arguments that are equal to x removed. haskell.lib.removeConfigureFlag haskellPackages.servant \"--verbose\" Arguments. [drv] [x] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addTestToolDepend.html",
    "content": "pkgs.haskell.lib.addTestToolDepend. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addTestToolDepend"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addTestToolDepend. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addTestToolDepend.html",
    "excerpt": "pkgs.haskell.lib.addTestToolDepend. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/dontStrip.html",
    "content": "pkgs.haskell.lib.dontStrip. Stop Nix from stripping the binary files. This keeps debugging symbols. Edit source.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.dontStrip"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.dontStrip. Stop Nix from stripping the binary files. This keeps debugging symbols. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/dontStrip.html",
    "excerpt": "pkgs.haskell.lib.dontStrip. Stop Nix from stripping the binary files. This keeps debugging symbols. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addExtraLibrary.html",
    "content": "pkgs.haskell.lib.addExtraLibrary. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addExtraLibrary"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addExtraLibrary. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addExtraLibrary.html",
    "excerpt": "pkgs.haskell.lib.addExtraLibrary. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/dontBenchmark.html",
    "content": "pkgs.haskell.lib.dontBenchmark. dontBenchmark disables dependency checking, compilation and execution for benchmarks listed in the package description file. Edit source.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.dontBenchmark"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.dontBenchmark. dontBenchmark disables dependency checking, compilation and execution for benchmarks listed in the package description file. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/dontBenchmark.html",
    "excerpt": "pkgs.haskell.lib.dontBenchmark. dontBenchmark disables dependency checking, compilation and execution for benchmarks listed in the package description file. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/dontDistribute.html",
    "content": "pkgs.haskell.lib.dontDistribute. dontDistribute disables the distribution of binaries for the package via hydra. Edit source. Noogle also knows. Aliases. lib.dontDistribute. lib.meta.dontDistribute.",
    "word_count": 20,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.dontDistribute"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.dontDistribute. dontDistribute disables the distribution of binaries for the package via hydra. Edit source. Noogle also knows. Aliases. lib.dontDistribute. lib.meta.dontDistribute.",
    "raw_url": "/f/pkgs/haskell/lib/dontDistribute.html",
    "excerpt": "pkgs.haskell.lib.dontDistribute. dontDistribute disables the distribution of binaries for the package via hydra. Edit source. Noogle also knows. Aliases. lib.dontDistribute. lib.meta.dontDistribute.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addBuildDepends.html",
    "content": "pkgs.haskell.lib.addBuildDepends. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addBuildDepends"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addBuildDepends. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addBuildDepends.html",
    "excerpt": "pkgs.haskell.lib.addBuildDepends. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/doHyperlinkSource.html",
    "content": "pkgs.haskell.lib.doHyperlinkSource.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.doHyperlinkSource"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.doHyperlinkSource.",
    "raw_url": "/f/pkgs/haskell/lib/doHyperlinkSource.html",
    "excerpt": "pkgs.haskell.lib.doHyperlinkSource.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/markUnbroken.html",
    "content": "pkgs.haskell.lib.markUnbroken.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.markUnbroken"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.markUnbroken.",
    "raw_url": "/f/pkgs/haskell/lib/markUnbroken.html",
    "excerpt": "pkgs.haskell.lib.markUnbroken.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/packageSourceOverrides.html",
    "content": "pkgs.haskell.lib.packageSourceOverrides. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.packageSourceOverrides"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.packageSourceOverrides. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/packageSourceOverrides.html",
    "excerpt": "pkgs.haskell.lib.packageSourceOverrides. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/disableDeadCodeElimination.html",
    "content": "pkgs.haskell.lib.disableDeadCodeElimination.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.disableDeadCodeElimination"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.disableDeadCodeElimination.",
    "raw_url": "/f/pkgs/haskell/lib/disableDeadCodeElimination.html",
    "excerpt": "pkgs.haskell.lib.disableDeadCodeElimination.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addExtraLibraries.html",
    "content": "pkgs.haskell.lib.addExtraLibraries. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addExtraLibraries"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addExtraLibraries. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addExtraLibraries.html",
    "excerpt": "pkgs.haskell.lib.addExtraLibraries. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/disableCabalFlag.html",
    "content": "pkgs.haskell.lib.disableCabalFlag. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.disableCabalFlag"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.disableCabalFlag. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/disableCabalFlag.html",
    "excerpt": "pkgs.haskell.lib.disableCabalFlag. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/doHaddock.html",
    "content": "pkgs.haskell.lib.doHaddock. doHaddock modifies a haskell package to enable the generation and installation of API documentation from code comments using the haddock tool. Edit source.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.doHaddock"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.doHaddock. doHaddock modifies a haskell package to enable the generation and installation of API documentation from code comments using the haddock tool. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/doHaddock.html",
    "excerpt": "pkgs.haskell.lib.doHaddock. doHaddock modifies a haskell package to enable the generation and installation of API documentation from code comments using the haddock tool. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/appendConfigureFlag.html",
    "content": "pkgs.haskell.lib.appendConfigureFlag. appendConfigureFlag adds a single argument that will be passed to the cabal configure command, after the arguments that have been defined in the initial declaration or previous overrides. Example. > haskell.lib.appendConfigureFlag haskellPackages.servant \"--profiling-detail=all-functions\" Arguments. [drv] [x] Edit source.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.appendConfigureFlag"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 29
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 34
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.appendConfigureFlag. appendConfigureFlag adds a single argument that will be passed to the cabal configure command, after the arguments that have been defined in the initial declaration or previous overrides. Example. &gt; haskell.lib.appendConfigureFlag haskellPackages.servant \"--profiling-detail=all-functions\" Arguments. [drv] [x] Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/appendConfigureFlag.html",
    "excerpt": "pkgs.haskell.lib.appendConfigureFlag. appendConfigureFlag adds a single argument that will be passed to the cabal configure command, after the arguments that have been defined in the initial declaration or previous overrides. Example.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/doCoverage.html",
    "content": "pkgs.haskell.lib.doCoverage. doCoverage modifies a haskell package to enable the generation and installation of a coverage report. See https://wiki.haskell.org/Haskell_program_coverage. Edit source.",
    "word_count": 20,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.doCoverage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.doCoverage. doCoverage modifies a haskell package to enable the generation and installation of a coverage report. See https://wiki.haskell.org/Haskell_program_coverage. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/doCoverage.html",
    "excerpt": "pkgs.haskell.lib.doCoverage. doCoverage modifies a haskell package to enable the generation and installation of a coverage report. See https://wiki.haskell.org/Haskell_program_coverage. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/dontJailbreak.html",
    "content": "pkgs.haskell.lib.dontJailbreak. dontJailbreak restores the use of the version bounds the check the use of dependencies in the package description. Edit source.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.dontJailbreak"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.dontJailbreak. dontJailbreak restores the use of the version bounds the check the use of dependencies in the package description. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/dontJailbreak.html",
    "excerpt": "pkgs.haskell.lib.dontJailbreak. dontJailbreak restores the use of the version bounds the check the use of dependencies in the package description. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addPkgconfigDepends.html",
    "content": "pkgs.haskell.lib.addPkgconfigDepends. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addPkgconfigDepends"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addPkgconfigDepends. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addPkgconfigDepends.html",
    "excerpt": "pkgs.haskell.lib.addPkgconfigDepends. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/dontHaddock.html",
    "content": "pkgs.haskell.lib.dontHaddock. dontHaddock modifies a haskell package to disable the generation and installation of API documentation from code comments using the haddock tool. Edit source.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.dontHaddock"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.dontHaddock. dontHaddock modifies a haskell package to disable the generation and installation of API documentation from code comments using the haddock tool. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/dontHaddock.html",
    "excerpt": "pkgs.haskell.lib.dontHaddock. dontHaddock modifies a haskell package to disable the generation and installation of API documentation from code comments using the haddock tool. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/sdistTarball.html",
    "content": "pkgs.haskell.lib.sdistTarball. Create a source distribution tarball like those found on hackage, instead of building the package. Edit source.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.sdistTarball"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.sdistTarball. Create a source distribution tarball like those found on hackage, instead of building the package. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/sdistTarball.html",
    "excerpt": "pkgs.haskell.lib.sdistTarball. Create a source distribution tarball like those found on hackage, instead of building the package. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/documentationTarball.html",
    "content": "pkgs.haskell.lib.documentationTarball. Create a documentation tarball suitable for uploading to Hackage instead of building the package. Edit source.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.documentationTarball"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.documentationTarball. Create a documentation tarball suitable for uploading to Hackage instead of building the package. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/documentationTarball.html",
    "excerpt": "pkgs.haskell.lib.documentationTarball. Create a documentation tarball suitable for uploading to Hackage instead of building the package. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/markBroken.html",
    "content": "pkgs.haskell.lib.markBroken.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.markBroken"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.markBroken.",
    "raw_url": "/f/pkgs/haskell/lib/markBroken.html",
    "excerpt": "pkgs.haskell.lib.markBroken.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/enableStaticLibraries.html",
    "content": "pkgs.haskell.lib.enableStaticLibraries.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.enableStaticLibraries"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.enableStaticLibraries.",
    "raw_url": "/f/pkgs/haskell/lib/enableStaticLibraries.html",
    "excerpt": "pkgs.haskell.lib.enableStaticLibraries.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/allowInconsistentDependencies.html",
    "content": "pkgs.haskell.lib.allowInconsistentDependencies.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.allowInconsistentDependencies"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.allowInconsistentDependencies.",
    "raw_url": "/f/pkgs/haskell/lib/allowInconsistentDependencies.html",
    "excerpt": "pkgs.haskell.lib.allowInconsistentDependencies.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/justStaticExecutables.html",
    "content": "pkgs.haskell.lib.justStaticExecutables. link executables statically against haskell libs to reduce closure size. Edit source.",
    "word_count": 13,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.justStaticExecutables"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.justStaticExecutables. link executables statically against haskell libs to reduce closure size. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/justStaticExecutables.html",
    "excerpt": "pkgs.haskell.lib.justStaticExecutables. link executables statically against haskell libs to reduce closure size. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/disableExecutableProfiling.html",
    "content": "pkgs.haskell.lib.disableExecutableProfiling.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.disableExecutableProfiling"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.disableExecutableProfiling.",
    "raw_url": "/f/pkgs/haskell/lib/disableExecutableProfiling.html",
    "excerpt": "pkgs.haskell.lib.disableExecutableProfiling.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/doDistribute.html",
    "content": "pkgs.haskell.lib.doDistribute. doDistribute enables the distribution of binaries for the package via hydra. Edit source.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.doDistribute"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.doDistribute. doDistribute enables the distribution of binaries for the package via hydra. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/doDistribute.html",
    "excerpt": "pkgs.haskell.lib.doDistribute. doDistribute enables the distribution of binaries for the package via hydra. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/makePackageSet.html",
    "content": "pkgs.haskell.lib.makePackageSet. This function takes a file like hackage-packages.nix and constructs a full package set out of that. Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.makePackageSet"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.makePackageSet. This function takes a file like hackage-packages.nix and constructs a full package set out of that. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/makePackageSet.html",
    "excerpt": "pkgs.haskell.lib.makePackageSet. This function takes a file like hackage-packages.nix and constructs a full package set out of that. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/disableHardening.html",
    "content": "pkgs.haskell.lib.disableHardening. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.disableHardening"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.disableHardening. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/disableHardening.html",
    "excerpt": "pkgs.haskell.lib.disableHardening. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addSetupDepend.html",
    "content": "pkgs.haskell.lib.addSetupDepend. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addSetupDepend"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addSetupDepend. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addSetupDepend.html",
    "excerpt": "pkgs.haskell.lib.addSetupDepend. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/linkWithGold.html",
    "content": "pkgs.haskell.lib.linkWithGold. Use the gold linker. It is a linker for ELF that is designed \"to run as fast as possible on modern systems\" Edit source.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.linkWithGold"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.linkWithGold. Use the gold linker. It is a linker for ELF that is designed \"to run as fast as possible on modern systems\" Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/linkWithGold.html",
    "excerpt": "pkgs.haskell.lib.linkWithGold. Use the gold linker. It is a linker for ELF that is designed \"to run as fast as possible on modern systems\" Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/packagesFromDirectory.html",
    "content": "pkgs.haskell.lib.packagesFromDirectory. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.packagesFromDirectory"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.packagesFromDirectory. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/packagesFromDirectory.html",
    "excerpt": "pkgs.haskell.lib.packagesFromDirectory. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/unmarkBroken.html",
    "content": "pkgs.haskell.lib.unmarkBroken.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.unmarkBroken"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.unmarkBroken.",
    "raw_url": "/f/pkgs/haskell/lib/unmarkBroken.html",
    "excerpt": "pkgs.haskell.lib.unmarkBroken.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/addBuildDepend.html",
    "content": "pkgs.haskell.lib.addBuildDepend. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.addBuildDepend"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.addBuildDepend. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/addBuildDepend.html",
    "excerpt": "pkgs.haskell.lib.addBuildDepend. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/appendBuildFlag.html",
    "content": "pkgs.haskell.lib.appendBuildFlag. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.appendBuildFlag"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.appendBuildFlag. Edit source.",
    "raw_url": "/f/pkgs/haskell/lib/appendBuildFlag.html",
    "excerpt": "pkgs.haskell.lib.appendBuildFlag. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/haskell/lib/enableSharedExecutables.html",
    "content": "pkgs.haskell.lib.enableSharedExecutables.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.haskell.lib.enableSharedExecutables"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.haskell.lib.enableSharedExecutables.",
    "raw_url": "/f/pkgs/haskell/lib/enableSharedExecutables.html",
    "excerpt": "pkgs.haskell.lib.enableSharedExecutables.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeTextFile.html",
    "content": "pkgs.writeTextFile. Writes a text file to the nix store. The contents of text is added to the file in the store. Example. # Writes my-file to /nix/store/<store path> writeTextFile { name = \"my-file\"; text = '' Contents of File ''; } See also the `writeText` helper function below. # Writes executable my-file to /nix/store/<store path>/bin/my-file writeTextFile { name = \"my-file\"; text = '' Contents of File ''; executable = true; destination = \"/bin/my-file\"; } Arguments. Edit source.",
    "word_count": 77,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeTextFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 74
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeTextFile. Writes a text file to the nix store. The contents of text is added to the file in the store. Example. # Writes my-file to /nix/store/&lt;store path&gt; writeTextFile { name = \"my-file\"; text = '' Contents of File ''; } See also the `writeText` helper function below. # Writes executable my-file to /nix/store/&lt;store path&gt;/bin/my-file writeTextFile { name = \"my-file\"; text = '' Contents of File ''; executable = true; destination = \"/bin/my-file\"; } Arguments. Edit source.",
    "raw_url": "/f/pkgs/writeTextFile.html",
    "excerpt": "pkgs.writeTextFile. Writes a text file to the nix store. The contents of text is added to the file in the store. Example. # Writes my-file to /nix/store/&lt;store path&gt; writeTextFile {",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/overrideCC.html",
    "content": "pkgs.overrideCC. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.overrideCC"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.overrideCC. Edit source.",
    "raw_url": "/f/pkgs/overrideCC.html",
    "excerpt": "pkgs.overrideCC. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/clwrapperFunction.html",
    "content": "pkgs.clwrapperFunction.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.clwrapperFunction"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.clwrapperFunction.",
    "raw_url": "/f/pkgs/clwrapperFunction.html",
    "excerpt": "pkgs.clwrapperFunction.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildGo120Package.html",
    "content": "pkgs.buildGo120Package.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildGo120Package"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildGo120Package.",
    "raw_url": "/f/pkgs/buildGo120Package.html",
    "excerpt": "pkgs.buildGo120Package.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchDockerConfig.html",
    "content": "pkgs.fetchDockerConfig.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchDockerConfig"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchDockerConfig.",
    "raw_url": "/f/pkgs/fetchDockerConfig.html",
    "excerpt": "pkgs.fetchDockerConfig.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/overrideLibcxx.html",
    "content": "pkgs.overrideLibcxx. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.overrideLibcxx"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.overrideLibcxx. Edit source.",
    "raw_url": "/f/pkgs/overrideLibcxx.html",
    "excerpt": "pkgs.overrideLibcxx. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/runCommandNoCC.html",
    "content": "pkgs.runCommandNoCC. Run the shell command buildCommand' to produce a store path named name'. The attributes in env' are added to the environment prior to running the command. By default runCommandruns in a stdenv with no compiler environment.runCommandCCuses the default stdenv,pkgs.stdenv`. Example. runCommand \"name\" {envVariable = true;} ''echo hello > $out'' runCommandCC \"name\" {} ''gcc -o myfile myfile.c; cp myfile $out''; The `*Local` variants force a derivation to be built locally, it is not substituted. This is intended for very cheap commands (<1s execution time). It saves on the network roundrip and can speed up a build. It is the same as adding the special fields `preferLocalBuild = true;` `allowSubstitutes = false;` to a derivation’s attributes. Arguments. [name] [env] Edit source.",
    "word_count": 120,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.runCommandNoCC"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 40
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 115
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.runCommandNoCC. Run the shell command buildCommand' to produce a store path named name'. The attributes in env' are added to the environment prior to running the command. By default runCommandruns in a stdenv with no compiler environment.runCommandCCuses the default stdenv,pkgs.stdenv`. Example. runCommand \"name\" {envVariable = true;} ''echo hello &gt; $out'' runCommandCC \"name\" {} ''gcc -o myfile myfile.c; cp myfile $out''; The `*Local` variants force a derivation to be built locally, it is not substituted. This is intended for very cheap commands (&lt;1s execution time). It saves on the network roundrip and can speed up a build. It is the same as adding the special fields `preferLocalBuild = true;` `allowSubstitutes = false;` to a derivation’s attributes. Arguments. [name] [env] Edit source.",
    "raw_url": "/f/pkgs/runCommandNoCC.html",
    "excerpt": "pkgs.runCommandNoCC. Run the shell command buildCommand' to produce a store path named name'. The attributes in env' are added to the environment prior to running the command. By default runCommandruns",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildDotnetPackage.html",
    "content": "pkgs.buildDotnetPackage.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildDotnetPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildDotnetPackage.",
    "raw_url": "/f/pkgs/buildDotnetPackage.html",
    "excerpt": "pkgs.buildDotnetPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/concatText.html",
    "content": "pkgs.concatText. Writes a text file to nix store with no optional parameters available. Example. # Writes contents of files to /nix/store/<store path> concatText \"my-file\" [ file1 file2 ] Arguments. [name] [files] Edit source.",
    "word_count": 33,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.concatText"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 28
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.concatText. Writes a text file to nix store with no optional parameters available. Example. # Writes contents of files to /nix/store/&lt;store path&gt; concatText \"my-file\" [ file1 file2 ] Arguments. [name] [files] Edit source.",
    "raw_url": "/f/pkgs/concatText.html",
    "excerpt": "pkgs.concatText. Writes a text file to nix store with no optional parameters available. Example. # Writes contents of files to /nix/store/&lt;store path&gt; concatText \"my-file\" [ file1 file2 ] Arguments. [name]",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeShellScriptBin.html",
    "content": "pkgs.writeShellScriptBin. Similar to writeShellScript and writeScriptBin. Writes an executable Shell script to /nix/store//bin/ and checks its syntax. Automatically includes interpreter above the contents passed. Example. # Writes my-file to /nix/store/<store path>/bin/my-file and makes executable. writeShellScriptBin \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeShellScriptBin"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeShellScriptBin. Similar to writeShellScript and writeScriptBin. Writes an executable Shell script to /nix/store//bin/ and checks its syntax. Automatically includes interpreter above the contents passed. Example. # Writes my-file to /nix/store/&lt;store path&gt;/bin/my-file and makes executable. writeShellScriptBin \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source.",
    "raw_url": "/f/pkgs/writeShellScriptBin.html",
    "excerpt": "pkgs.writeShellScriptBin. Similar to writeShellScript and writeScriptBin. Writes an executable Shell script to /nix/store//bin/ and checks its syntax. Automatically includes interpreter above the contents passed. Example. # Writes my-file to /nix/store/&lt;store",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/threadsCrossFor.html",
    "content": "pkgs.threadsCrossFor. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.threadsCrossFor"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.threadsCrossFor. Edit source.",
    "raw_url": "/f/pkgs/threadsCrossFor.html",
    "excerpt": "pkgs.threadsCrossFor. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/concatTextFile.html",
    "content": "pkgs.concatTextFile. concat a list of files to the nix store. The contents of files are added to the file in the store. Example. # Writes my-file to /nix/store/<store path> concatTextFile { name = \"my-file\"; files = [ drv1 \"${drv2}/path/to/file\" ]; } See also the `concatText` helper function below. # Writes executable my-file to /nix/store/<store path>/bin/my-file concatTextFile { name = \"my-file\"; files = [ drv1 \"${drv2}/path/to/file\" ]; executable = true; destination = \"/bin/my-file\"; } Arguments. Edit source.",
    "word_count": 76,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.concatTextFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 73
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.concatTextFile. concat a list of files to the nix store. The contents of files are added to the file in the store. Example. # Writes my-file to /nix/store/&lt;store path&gt; concatTextFile { name = \"my-file\"; files = [ drv1 \"${drv2}/path/to/file\" ]; } See also the `concatText` helper function below. # Writes executable my-file to /nix/store/&lt;store path&gt;/bin/my-file concatTextFile { name = \"my-file\"; files = [ drv1 \"${drv2}/path/to/file\" ]; executable = true; destination = \"/bin/my-file\"; } Arguments. Edit source.",
    "raw_url": "/f/pkgs/concatTextFile.html",
    "excerpt": "pkgs.concatTextFile. concat a list of files to the nix store. The contents of files are added to the file in the store. Example. # Writes my-file to /nix/store/&lt;store path&gt; concatTextFile",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildFHSUserEnvBubblewrap.html",
    "content": "pkgs.buildFHSUserEnvBubblewrap.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildFHSUserEnvBubblewrap"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildFHSUserEnvBubblewrap.",
    "raw_url": "/f/pkgs/buildFHSUserEnvBubblewrap.html",
    "excerpt": "pkgs.buildFHSUserEnvBubblewrap.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildGo119Module.html",
    "content": "pkgs.buildGo119Module.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildGo119Module"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildGo119Module.",
    "raw_url": "/f/pkgs/buildGo119Module.html",
    "excerpt": "pkgs.buildGo119Module.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/blender-with-packages.html",
    "content": "pkgs.blender-with-packages. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.blender-with-packages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.blender-with-packages. Edit source.",
    "raw_url": "/f/pkgs/blender-with-packages.html",
    "excerpt": "pkgs.blender-with-packages. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildPgxExtension.html",
    "content": "pkgs.buildPgxExtension.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildPgxExtension"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildPgxExtension.",
    "raw_url": "/f/pkgs/buildPgxExtension.html",
    "excerpt": "pkgs.buildPgxExtension.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchFromGitiles.html",
    "content": "pkgs.fetchFromGitiles.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchFromGitiles"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchFromGitiles.",
    "raw_url": "/f/pkgs/fetchFromGitiles.html",
    "excerpt": "pkgs.fetchFromGitiles.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapClangMulti.html",
    "content": "pkgs.wrapClangMulti. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapClangMulti"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapClangMulti. Edit source.",
    "raw_url": "/f/pkgs/wrapClangMulti.html",
    "excerpt": "pkgs.wrapClangMulti. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/requireFile.html",
    "content": "pkgs.requireFile. Print an error message if the file with the specified name and hash doesn't exist in the Nix store. This function should only be used by non-redistributable software with an unfree license that we need to require the user to download manually. It produces packages that cannot be built automatically. Example. requireFile { name = \"my-file\"; url = \"http://example.com/download/\"; sha256 = \"ffffffffffffffffffffffffffffffffffffffffffffffffffff\"; } Arguments. Edit source.",
    "word_count": 67,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.requireFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 51
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 64
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.requireFile. Print an error message if the file with the specified name and hash doesn't exist in the Nix store. This function should only be used by non-redistributable software with an unfree license that we need to require the user to download manually. It produces packages that cannot be built automatically. Example. requireFile { name = \"my-file\"; url = \"http://example.com/download/\"; sha256 = \"ffffffffffffffffffffffffffffffffffffffffffffffffffff\"; } Arguments. Edit source.",
    "raw_url": "/f/pkgs/requireFile.html",
    "excerpt": "pkgs.requireFile. Print an error message if the file with the specified name and hash doesn't exist in the Nix store. This function should only be used by non-redistributable software with",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchtorrent.html",
    "content": "pkgs.fetchtorrent.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchtorrent"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchtorrent.",
    "raw_url": "/f/pkgs/fetchtorrent.html",
    "excerpt": "pkgs.fetchtorrent.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/resolveMirrorURLs.html",
    "content": "pkgs.resolveMirrorURLs. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.resolveMirrorURLs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.resolveMirrorURLs. Edit source.",
    "raw_url": "/f/pkgs/resolveMirrorURLs.html",
    "excerpt": "pkgs.resolveMirrorURLs. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/emacsWithPackages.html",
    "content": "pkgs.emacsWithPackages. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.emacsWithPackages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.emacsWithPackages. Edit source.",
    "raw_url": "/f/pkgs/emacsWithPackages.html",
    "excerpt": "pkgs.emacsWithPackages. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchDartDeps.html",
    "content": "pkgs.fetchDartDeps.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchDartDeps"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchDartDeps.",
    "raw_url": "/f/pkgs/fetchDartDeps.html",
    "excerpt": "pkgs.fetchDartDeps.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/runCommandWith.html",
    "content": "pkgs.runCommandWith. Generalized version of the runCommand-variants which does customized behavior via a single attribute set passed as the first argument instead of having a lot of variants like runCommand*. Additionally it allows changing the used stdenv freely and has a more explicit approach to changing the arguments passed to stdenv.mkDerivation. Edit source.",
    "word_count": 52,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.runCommandWith"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.runCommandWith. Generalized version of the runCommand-variants which does customized behavior via a single attribute set passed as the first argument instead of having a lot of variants like runCommand*. Additionally it allows changing the used stdenv freely and has a more explicit approach to changing the arguments passed to stdenv.mkDerivation. Edit source.",
    "raw_url": "/f/pkgs/runCommandWith.html",
    "excerpt": "pkgs.runCommandWith. Generalized version of the runCommand-variants which does customized behavior via a single attribute set passed as the first argument instead of having a lot of variants like runCommand*. Additionally",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchpatch.html",
    "content": "pkgs.fetchpatch.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchpatch"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchpatch.",
    "raw_url": "/f/pkgs/fetchpatch.html",
    "excerpt": "pkgs.fetchpatch.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/eggDerivation.html",
    "content": "pkgs.eggDerivation.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.eggDerivation"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.eggDerivation.",
    "raw_url": "/f/pkgs/eggDerivation.html",
    "excerpt": "pkgs.eggDerivation.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/generateSplicesForMkScope.html",
    "content": "pkgs.generateSplicesForMkScope. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.generateSplicesForMkScope"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.generateSplicesForMkScope. Edit source.",
    "raw_url": "/f/pkgs/generateSplicesForMkScope.html",
    "excerpt": "pkgs.generateSplicesForMkScope. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapNonDeterministicGcc.html",
    "content": "pkgs.wrapNonDeterministicGcc. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapNonDeterministicGcc"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapNonDeterministicGcc. Edit source.",
    "raw_url": "/f/pkgs/wrapNonDeterministicGcc.html",
    "excerpt": "pkgs.wrapNonDeterministicGcc. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mpdWithFeatures.html",
    "content": "pkgs.mpdWithFeatures.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mpdWithFeatures"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mpdWithFeatures.",
    "raw_url": "/f/pkgs/mpdWithFeatures.html",
    "excerpt": "pkgs.mpdWithFeatures.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapLisp.html",
    "content": "pkgs.wrapLisp.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapLisp"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapLisp.",
    "raw_url": "/f/pkgs/wrapLisp.html",
    "excerpt": "pkgs.wrapLisp.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/diffPlugins.html",
    "content": "pkgs.diffPlugins. Takes a list of expected plugin names. and compares it to the found plugins given in the file, one plugin per line. If the lists differ, the build fails with a nice message. This is helpful to ensure maintainers don’t miss. the addition or removal of a plugin. Arguments. [expectedPlugins] [foundPluginsFilePath] Edit source.",
    "word_count": 54,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.diffPlugins"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 49
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.diffPlugins. Takes a list of expected plugin names. and compares it to the found plugins given in the file, one plugin per line. If the lists differ, the build fails with a nice message. This is helpful to ensure maintainers don’t miss. the addition or removal of a plugin. Arguments. [expectedPlugins] [foundPluginsFilePath] Edit source.",
    "raw_url": "/f/pkgs/diffPlugins.html",
    "excerpt": "pkgs.diffPlugins. Takes a list of expected plugin names. and compares it to the found plugins given in the file, one plugin per line. If the lists differ, the build fails",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/enableDebugging.html",
    "content": "pkgs.enableDebugging. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.enableDebugging"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.enableDebugging. Edit source.",
    "raw_url": "/f/pkgs/enableDebugging.html",
    "excerpt": "pkgs.enableDebugging. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/quake3wrapper.html",
    "content": "pkgs.quake3wrapper.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.quake3wrapper"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.quake3wrapper.",
    "raw_url": "/f/pkgs/quake3wrapper.html",
    "excerpt": "pkgs.quake3wrapper.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchbzr.html",
    "content": "pkgs.fetchbzr.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchbzr"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchbzr.",
    "raw_url": "/f/pkgs/fetchbzr.html",
    "excerpt": "pkgs.fetchbzr.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeStaticLibraries.html",
    "content": "pkgs.makeStaticLibraries. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeStaticLibraries"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeStaticLibraries. Edit source.",
    "raw_url": "/f/pkgs/makeStaticLibraries.html",
    "excerpt": "pkgs.makeStaticLibraries. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkYarnPackage.html",
    "content": "pkgs.mkYarnPackage. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkYarnPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkYarnPackage. Edit source.",
    "raw_url": "/f/pkgs/mkYarnPackage.html",
    "excerpt": "pkgs.mkYarnPackage. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rebar3WithPlugins.html",
    "content": "pkgs.rebar3WithPlugins. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rebar3WithPlugins"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rebar3WithPlugins. Edit source.",
    "raw_url": "/f/pkgs/rebar3WithPlugins.html",
    "excerpt": "pkgs.rebar3WithPlugins. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapRetroArch.html",
    "content": "pkgs.wrapRetroArch. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapRetroArch"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapRetroArch. Edit source.",
    "raw_url": "/f/pkgs/wrapRetroArch.html",
    "excerpt": "pkgs.wrapRetroArch. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchRepoProject.html",
    "content": "pkgs.fetchRepoProject.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchRepoProject"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchRepoProject.",
    "raw_url": "/f/pkgs/fetchRepoProject.html",
    "excerpt": "pkgs.fetchRepoProject.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildGoModule.html",
    "content": "pkgs.buildGoModule.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildGoModule"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildGoModule.",
    "raw_url": "/f/pkgs/buildGoModule.html",
    "excerpt": "pkgs.buildGoModule.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildGraalvmNativeImage.html",
    "content": "pkgs.buildGraalvmNativeImage.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildGraalvmNativeImage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildGraalvmNativeImage.",
    "raw_url": "/f/pkgs/buildGraalvmNativeImage.html",
    "excerpt": "pkgs.buildGraalvmNativeImage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeCueValidator.html",
    "content": "pkgs.writeCueValidator.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeCueValidator"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeCueValidator.",
    "raw_url": "/f/pkgs/writeCueValidator.html",
    "excerpt": "pkgs.writeCueValidator.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dictDBCollector.html",
    "content": "pkgs.dictDBCollector.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dictDBCollector"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dictDBCollector.",
    "raw_url": "/f/pkgs/dictDBCollector.html",
    "excerpt": "pkgs.dictDBCollector.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchFromSourcehut.html",
    "content": "pkgs.fetchFromSourcehut.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchFromSourcehut"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchFromSourcehut.",
    "raw_url": "/f/pkgs/fetchFromSourcehut.html",
    "excerpt": "pkgs.fetchFromSourcehut.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/lispPackagesFor.html",
    "content": "pkgs.lispPackagesFor. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.lispPackagesFor"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.lispPackagesFor. Edit source.",
    "raw_url": "/f/pkgs/lispPackagesFor.html",
    "excerpt": "pkgs.lispPackagesFor. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildDotnetModule.html",
    "content": "pkgs.buildDotnetModule.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildDotnetModule"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildDotnetModule.",
    "raw_url": "/f/pkgs/buildDotnetModule.html",
    "excerpt": "pkgs.buildDotnetModule.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/hunspellWithDicts.html",
    "content": "pkgs.hunspellWithDicts. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.hunspellWithDicts"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.hunspellWithDicts. Edit source.",
    "raw_url": "/f/pkgs/hunspellWithDicts.html",
    "excerpt": "pkgs.hunspellWithDicts. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/callPackage_i686.html",
    "content": "pkgs.callPackage_i686.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.callPackage_i686"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.callPackage_i686.",
    "raw_url": "/f/pkgs/callPackage_i686.html",
    "excerpt": "pkgs.callPackage_i686.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/apacheHttpdPackagesFor.html",
    "content": "pkgs.apacheHttpdPackagesFor. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.apacheHttpdPackagesFor"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.apacheHttpdPackagesFor. Edit source.",
    "raw_url": "/f/pkgs/apacheHttpdPackagesFor.html",
    "excerpt": "pkgs.apacheHttpdPackagesFor. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchgit.html",
    "content": "pkgs.fetchgit.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchgit"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchgit.",
    "raw_url": "/f/pkgs/fetchgit.html",
    "excerpt": "pkgs.fetchgit.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/apparmorRulesFromClosure.html",
    "content": "pkgs.apparmorRulesFromClosure.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.apparmorRulesFromClosure"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.apparmorRulesFromClosure.",
    "raw_url": "/f/pkgs/apparmorRulesFromClosure.html",
    "excerpt": "pkgs.apparmorRulesFromClosure.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/callPackages.html",
    "content": "pkgs.callPackages.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.callPackages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.callPackages.",
    "raw_url": "/f/pkgs/callPackages.html",
    "excerpt": "pkgs.callPackages.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/appendOverlays.html",
    "content": "pkgs.appendOverlays. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.appendOverlays"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.appendOverlays. Edit source.",
    "raw_url": "/f/pkgs/appendOverlays.html",
    "excerpt": "pkgs.appendOverlays. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchsvnrevision.html",
    "content": "pkgs.fetchsvnrevision.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchsvnrevision"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchsvnrevision.",
    "raw_url": "/f/pkgs/fetchsvnrevision.html",
    "excerpt": "pkgs.fetchsvnrevision.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/replaceDependency.html",
    "content": "pkgs.replaceDependency.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.replaceDependency"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.replaceDependency.",
    "raw_url": "/f/pkgs/replaceDependency.html",
    "excerpt": "pkgs.replaceDependency.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/runCommand.html",
    "content": "pkgs.runCommand. Run the shell command buildCommand' to produce a store path named name'. The attributes in env' are added to the environment prior to running the command. By default runCommandruns in a stdenv with no compiler environment.runCommandCCuses the default stdenv,pkgs.stdenv`. Example. runCommand \"name\" {envVariable = true;} ''echo hello > $out'' runCommandCC \"name\" {} ''gcc -o myfile myfile.c; cp myfile $out''; The `*Local` variants force a derivation to be built locally, it is not substituted. This is intended for very cheap commands (<1s execution time). It saves on the network roundrip and can speed up a build. It is the same as adding the special fields `preferLocalBuild = true;` `allowSubstitutes = false;` to a derivation’s attributes. Arguments. [name] [env] Edit source.",
    "word_count": 120,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.runCommand"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 40
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 115
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.runCommand. Run the shell command buildCommand' to produce a store path named name'. The attributes in env' are added to the environment prior to running the command. By default runCommandruns in a stdenv with no compiler environment.runCommandCCuses the default stdenv,pkgs.stdenv`. Example. runCommand \"name\" {envVariable = true;} ''echo hello &gt; $out'' runCommandCC \"name\" {} ''gcc -o myfile myfile.c; cp myfile $out''; The `*Local` variants force a derivation to be built locally, it is not substituted. This is intended for very cheap commands (&lt;1s execution time). It saves on the network roundrip and can speed up a build. It is the same as adding the special fields `preferLocalBuild = true;` `allowSubstitutes = false;` to a derivation’s attributes. Arguments. [name] [env] Edit source.",
    "raw_url": "/f/pkgs/runCommand.html",
    "excerpt": "pkgs.runCommand. Run the shell command buildCommand' to produce a store path named name'. The attributes in env' are added to the environment prior to running the command. By default runCommandruns",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapFirefox.html",
    "content": "pkgs.wrapFirefox.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapFirefox"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapFirefox.",
    "raw_url": "/f/pkgs/wrapFirefox.html",
    "excerpt": "pkgs.wrapFirefox.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchFromSavannah.html",
    "content": "pkgs.fetchFromSavannah.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchFromSavannah"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchFromSavannah.",
    "raw_url": "/f/pkgs/fetchFromSavannah.html",
    "excerpt": "pkgs.fetchFromSavannah.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/winePackagesFor.html",
    "content": "pkgs.winePackagesFor. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.winePackagesFor"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.winePackagesFor. Edit source.",
    "raw_url": "/f/pkgs/winePackagesFor.html",
    "excerpt": "pkgs.winePackagesFor. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeScopeWithSplicing.html",
    "content": "pkgs.makeScopeWithSplicing. backward compatibility with old uncurried form; deprecated. Arguments. [splicePackages] [newScope] [otherSplices] [keep] [extra] [f] Edit source. Noogle also knows. Aliases. lib.makeScopeWithSplicing. lib.customisation.makeScopeWithSplicing.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeScopeWithSplicing"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeScopeWithSplicing. backward compatibility with old uncurried form; deprecated. Arguments. [splicePackages] [newScope] [otherSplices] [keep] [extra] [f] Edit source. Noogle also knows. Aliases. lib.makeScopeWithSplicing. lib.customisation.makeScopeWithSplicing.",
    "raw_url": "/f/pkgs/makeScopeWithSplicing.html",
    "excerpt": "pkgs.makeScopeWithSplicing. backward compatibility with old uncurried form; deprecated. Arguments. [splicePackages] [newScope] [otherSplices] [keep] [extra] [f] Edit source. Noogle also knows. Aliases. lib.makeScopeWithSplicing. lib.customisation.makeScopeWithSplicing.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/aggregateModules.html",
    "content": "pkgs.aggregateModules. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.aggregateModules"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.aggregateModules. Edit source.",
    "raw_url": "/f/pkgs/aggregateModules.html",
    "excerpt": "pkgs.aggregateModules. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/newScope.html",
    "content": "pkgs.newScope. Edit source. Noogle also knows. Aliases. pkgs.pythonPackages.newScope. pkgs.rustPackages.newScope. pkgs.rustPackages.buildRustPackages.newScope.",
    "word_count": 10,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.newScope"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.newScope. Edit source. Noogle also knows. Aliases. pkgs.pythonPackages.newScope. pkgs.rustPackages.newScope. pkgs.rustPackages.buildRustPackages.newScope.",
    "raw_url": "/f/pkgs/newScope.html",
    "excerpt": "pkgs.newScope. Edit source. Noogle also knows. Aliases. pkgs.pythonPackages.newScope. pkgs.rustPackages.newScope. pkgs.rustPackages.buildRustPackages.newScope.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/setupSystemdUnits.html",
    "content": "pkgs.setupSystemdUnits.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.setupSystemdUnits"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.setupSystemdUnits.",
    "raw_url": "/f/pkgs/setupSystemdUnits.html",
    "excerpt": "pkgs.setupSystemdUnits.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildArmTrustedFirmware.html",
    "content": "pkgs.buildArmTrustedFirmware. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildArmTrustedFirmware"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildArmTrustedFirmware. Edit source.",
    "raw_url": "/f/pkgs/buildArmTrustedFirmware.html",
    "excerpt": "pkgs.buildArmTrustedFirmware. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeDirectReferencesToFile.html",
    "content": "pkgs.writeDirectReferencesToFile. Write the set of references to a file, that is, their immediate dependencies. This produces the equivalent of nix-store -q --references. Arguments. [path] Edit source.",
    "word_count": 26,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeDirectReferencesToFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 22
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeDirectReferencesToFile. Write the set of references to a file, that is, their immediate dependencies. This produces the equivalent of nix-store -q --references. Arguments. [path] Edit source.",
    "raw_url": "/f/pkgs/writeDirectReferencesToFile.html",
    "excerpt": "pkgs.writeDirectReferencesToFile. Write the set of references to a file, that is, their immediate dependencies. This produces the equivalent of nix-store -q --references. Arguments. [path] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchdocker.html",
    "content": "pkgs.fetchdocker.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchdocker"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchdocker.",
    "raw_url": "/f/pkgs/fetchdocker.html",
    "excerpt": "pkgs.fetchdocker.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/invalidateFetcherByDrvHash.html",
    "content": "pkgs.invalidateFetcherByDrvHash. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.invalidateFetcherByDrvHash"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.invalidateFetcherByDrvHash. Edit source.",
    "raw_url": "/f/pkgs/invalidateFetcherByDrvHash.html",
    "excerpt": "pkgs.invalidateFetcherByDrvHash. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeStringReferencesToFile.html",
    "content": "pkgs.writeStringReferencesToFile. Extract a string's references to derivations and paths (its context) and write them to a text file, removing the input string itself from the dependency graph. This is useful when you want to make a derivation depend on the string's references, but not its contents (to avoid unnecessary rebuilds, for example). Note that this only works as intended on Nix >= 2.3. Arguments. [string] Edit source.",
    "word_count": 67,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeStringReferencesToFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 63
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeStringReferencesToFile. Extract a string's references to derivations and paths (its context) and write them to a text file, removing the input string itself from the dependency graph. This is useful when you want to make a derivation depend on the string's references, but not its contents (to avoid unnecessary rebuilds, for example). Note that this only works as intended on Nix &gt;= 2.3. Arguments. [string] Edit source.",
    "raw_url": "/f/pkgs/writeStringReferencesToFile.html",
    "excerpt": "pkgs.writeStringReferencesToFile. Extract a string's references to derivations and paths (its context) and write them to a text file, removing the input string itself from the dependency graph. This is useful",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/useGoldLinker.html",
    "content": "pkgs.useGoldLinker. Modify a stdenv so that it uses the Gold linker. Arguments. [stdenv] Edit source.",
    "word_count": 15,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.useGoldLinker"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.useGoldLinker. Modify a stdenv so that it uses the Gold linker. Arguments. [stdenv] Edit source.",
    "raw_url": "/f/pkgs/useGoldLinker.html",
    "excerpt": "pkgs.useGoldLinker. Modify a stdenv so that it uses the Gold linker. Arguments. [stdenv] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makePkgconfigItem.html",
    "content": "pkgs.makePkgconfigItem.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makePkgconfigItem"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makePkgconfigItem.",
    "raw_url": "/f/pkgs/makePkgconfigItem.html",
    "excerpt": "pkgs.makePkgconfigItem.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/gccFun.html",
    "content": "pkgs.gccFun.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.gccFun"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.gccFun.",
    "raw_url": "/f/pkgs/gccFun.html",
    "excerpt": "pkgs.gccFun.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildDotnetGlobalTool.html",
    "content": "pkgs.buildDotnetGlobalTool.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildDotnetGlobalTool"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildDotnetGlobalTool.",
    "raw_url": "/f/pkgs/buildDotnetGlobalTool.html",
    "excerpt": "pkgs.buildDotnetGlobalTool.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeImpureTest.html",
    "content": "pkgs.makeImpureTest.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeImpureTest"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeImpureTest.",
    "raw_url": "/f/pkgs/makeImpureTest.html",
    "excerpt": "pkgs.makeImpureTest.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeTextDir.html",
    "content": "pkgs.writeTextDir. Writes a text file to nix store in a specific directory with no optional parameters available. Example. # Writes contents of file to /nix/store/<store path>/share/my-file writeTextDir \"share/my-file\" '' Contents of File ''; Arguments. [path] [text] Edit source.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeTextDir"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 33
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeTextDir. Writes a text file to nix store in a specific directory with no optional parameters available. Example. # Writes contents of file to /nix/store/&lt;store path&gt;/share/my-file writeTextDir \"share/my-file\" '' Contents of File ''; Arguments. [path] [text] Edit source.",
    "raw_url": "/f/pkgs/writeTextDir.html",
    "excerpt": "pkgs.writeTextDir. Writes a text file to nix store in a specific directory with no optional parameters available. Example. # Writes contents of file to /nix/store/&lt;store path&gt;/share/my-file writeTextDir \"share/my-file\" '' Contents",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildGo120Module.html",
    "content": "pkgs.buildGo120Module.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildGo120Module"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildGo120Module.",
    "raw_url": "/f/pkgs/buildGo120Module.html",
    "excerpt": "pkgs.buildGo120Module.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/substituteAll.html",
    "content": "pkgs.substituteAll.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.substituteAll"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.substituteAll.",
    "raw_url": "/f/pkgs/substituteAll.html",
    "excerpt": "pkgs.substituteAll.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapLisp_old.html",
    "content": "pkgs.wrapLisp_old. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapLisp_old"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapLisp_old. Edit source.",
    "raw_url": "/f/pkgs/wrapLisp_old.html",
    "excerpt": "pkgs.wrapLisp_old. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/testVersion.html",
    "content": "pkgs.testVersion. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.testVersion"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.testVersion. Edit source.",
    "raw_url": "/f/pkgs/testVersion.html",
    "excerpt": "pkgs.testVersion. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/srcOnly.html",
    "content": "pkgs.srcOnly.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.srcOnly"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.srcOnly.",
    "raw_url": "/f/pkgs/srcOnly.html",
    "excerpt": "pkgs.srcOnly.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/closureInfo.html",
    "content": "pkgs.closureInfo.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.closureInfo"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.closureInfo.",
    "raw_url": "/f/pkgs/closureInfo.html",
    "excerpt": "pkgs.closureInfo.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapBintoolsWith.html",
    "content": "pkgs.wrapBintoolsWith. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapBintoolsWith"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapBintoolsWith. Edit source.",
    "raw_url": "/f/pkgs/wrapBintoolsWith.html",
    "excerpt": "pkgs.wrapBintoolsWith. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchpatch2.html",
    "content": "pkgs.fetchpatch2.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchpatch2"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchpatch2.",
    "raw_url": "/f/pkgs/fetchpatch2.html",
    "excerpt": "pkgs.fetchpatch2.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dhallToNix.html",
    "content": "pkgs.dhallToNix.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dhallToNix"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dhallToNix.",
    "raw_url": "/f/pkgs/dhallToNix.html",
    "excerpt": "pkgs.dhallToNix.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchCrate.html",
    "content": "pkgs.fetchCrate.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchCrate"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchCrate.",
    "raw_url": "/f/pkgs/fetchCrate.html",
    "excerpt": "pkgs.fetchCrate.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/packages.html",
    "content": "pkgs.pythonPackages.packages. Noogle also knows. Aliases. pkgs.rustPackages.packages. pkgs.rustPackages.buildRustPackages.packages.",
    "word_count": 7,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.packages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.packages. Noogle also knows. Aliases. pkgs.rustPackages.packages. pkgs.rustPackages.buildRustPackages.packages.",
    "raw_url": "/f/pkgs/pythonPackages/packages.html",
    "excerpt": "pkgs.pythonPackages.packages. Noogle also knows. Aliases. pkgs.rustPackages.packages. pkgs.rustPackages.buildRustPackages.packages.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/disabled.html",
    "content": "pkgs.pythonPackages.disabled. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.disabled"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.disabled. Edit source.",
    "raw_url": "/f/pkgs/pythonPackages/disabled.html",
    "excerpt": "pkgs.pythonPackages.disabled. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/makePythonPath.html",
    "content": "pkgs.pythonPackages.makePythonPath. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.makePythonPath"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.makePythonPath. Edit source.",
    "raw_url": "/f/pkgs/pythonPackages/makePythonPath.html",
    "excerpt": "pkgs.pythonPackages.makePythonPath. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/pythonAtLeast.html",
    "content": "pkgs.pythonPackages.pythonAtLeast.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.pythonAtLeast"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.pythonAtLeast.",
    "raw_url": "/f/pkgs/pythonPackages/pythonAtLeast.html",
    "excerpt": "pkgs.pythonPackages.pythonAtLeast.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/newScope.html",
    "content": "pkgs.pythonPackages.newScope. Edit source. Noogle also knows. Aliases. pkgs.newScope. pkgs.rustPackages.newScope. pkgs.rustPackages.buildRustPackages.newScope.",
    "word_count": 10,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.newScope"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.newScope. Edit source. Noogle also knows. Aliases. pkgs.newScope. pkgs.rustPackages.newScope. pkgs.rustPackages.buildRustPackages.newScope.",
    "raw_url": "/f/pkgs/pythonPackages/newScope.html",
    "excerpt": "pkgs.pythonPackages.newScope. Edit source. Noogle also knows. Aliases. pkgs.newScope. pkgs.rustPackages.newScope. pkgs.rustPackages.buildRustPackages.newScope.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/disabledIf.html",
    "content": "pkgs.pythonPackages.disabledIf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.disabledIf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.disabledIf. Edit source.",
    "raw_url": "/f/pkgs/pythonPackages/disabledIf.html",
    "excerpt": "pkgs.pythonPackages.disabledIf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/hasPythonModule.html",
    "content": "pkgs.pythonPackages.hasPythonModule. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.hasPythonModule"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.hasPythonModule. Edit source.",
    "raw_url": "/f/pkgs/pythonPackages/hasPythonModule.html",
    "excerpt": "pkgs.pythonPackages.hasPythonModule. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/override.html",
    "content": "pkgs.pythonPackages.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.override"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "raw_url": "/f/pkgs/pythonPackages/override.html",
    "excerpt": "pkgs.pythonPackages.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/pythonOlder.html",
    "content": "pkgs.pythonPackages.pythonOlder.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.pythonOlder"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.pythonOlder.",
    "raw_url": "/f/pkgs/pythonPackages/pythonOlder.html",
    "excerpt": "pkgs.pythonPackages.pythonOlder.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/requiredPythonModules.html",
    "content": "pkgs.pythonPackages.requiredPythonModules. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.requiredPythonModules"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.requiredPythonModules. Edit source.",
    "raw_url": "/f/pkgs/pythonPackages/requiredPythonModules.html",
    "excerpt": "pkgs.pythonPackages.requiredPythonModules. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/buildPythonApplication.html",
    "content": "pkgs.pythonPackages.buildPythonApplication.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.buildPythonApplication"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.buildPythonApplication.",
    "raw_url": "/f/pkgs/pythonPackages/buildPythonApplication.html",
    "excerpt": "pkgs.pythonPackages.buildPythonApplication.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/buildSetupcfg.html",
    "content": "pkgs.pythonPackages.buildSetupcfg.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.buildSetupcfg"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.buildSetupcfg.",
    "raw_url": "/f/pkgs/pythonPackages/buildSetupcfg.html",
    "excerpt": "pkgs.pythonPackages.buildSetupcfg.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/makePythonHook.html",
    "content": "pkgs.pythonPackages.makePythonHook. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.makePythonHook"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.makePythonHook. Edit source.",
    "raw_url": "/f/pkgs/pythonPackages/makePythonHook.html",
    "excerpt": "pkgs.pythonPackages.makePythonHook. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/toPythonApplication.html",
    "content": "pkgs.pythonPackages.toPythonApplication. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.toPythonApplication"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.toPythonApplication. Edit source.",
    "raw_url": "/f/pkgs/pythonPackages/toPythonApplication.html",
    "excerpt": "pkgs.pythonPackages.toPythonApplication. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/fetchPypi.html",
    "content": "pkgs.pythonPackages.fetchPypi. Noogle also knows. Aliases. pkgs.fetchPypi.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.fetchPypi"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.fetchPypi. Noogle also knows. Aliases. pkgs.fetchPypi.",
    "raw_url": "/f/pkgs/pythonPackages/fetchPypi.html",
    "excerpt": "pkgs.pythonPackages.fetchPypi. Noogle also knows. Aliases. pkgs.fetchPypi.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/overrideScope.html",
    "content": "pkgs.pythonPackages.overrideScope. Edit source. Noogle also knows. Aliases. pkgs.rustPackages.overrideScope. pkgs.rustPackages.buildRustPackages.overrideScope.",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.overrideScope"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.overrideScope. Edit source. Noogle also knows. Aliases. pkgs.rustPackages.overrideScope. pkgs.rustPackages.buildRustPackages.overrideScope.",
    "raw_url": "/f/pkgs/pythonPackages/overrideScope.html",
    "excerpt": "pkgs.pythonPackages.overrideScope. Edit source. Noogle also knows. Aliases. pkgs.rustPackages.overrideScope. pkgs.rustPackages.buildRustPackages.overrideScope.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/overrideDerivation.html",
    "content": "pkgs.pythonPackages.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -> ( Derivation -> AttrSet ) -> Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. pkgs.dockerTools.overrideDerivation. lib.overrideDerivation. lib.customisation.overrideDerivation. pkgs.stdenv.overrideDerivation. pkgs.writers.overrideDerivation.",
    "word_count": 208,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.overrideDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 157
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 182
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 194
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -&gt; ( Derivation -&gt; AttrSet ) -&gt; Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. pkgs.dockerTools.overrideDerivation. lib.overrideDerivation. lib.customisation.overrideDerivation. pkgs.stdenv.overrideDerivation. pkgs.writers.overrideDerivation.",
    "raw_url": "/f/pkgs/pythonPackages/overrideDerivation.html",
    "excerpt": "pkgs.pythonPackages.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/toPythonModule.html",
    "content": "pkgs.pythonPackages.toPythonModule. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.toPythonModule"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.toPythonModule. Edit source.",
    "raw_url": "/f/pkgs/pythonPackages/toPythonModule.html",
    "excerpt": "pkgs.pythonPackages.toPythonModule. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/callPackage.html",
    "content": "pkgs.pythonPackages.callPackage. Noogle also knows. Aliases. pkgs.callPackage. pkgs.rustPackages.callPackage. pkgs.rustPackages.buildRustPackages.callPackage.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.callPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.callPackage. Noogle also knows. Aliases. pkgs.callPackage. pkgs.rustPackages.callPackage. pkgs.rustPackages.buildRustPackages.callPackage.",
    "raw_url": "/f/pkgs/pythonPackages/callPackage.html",
    "excerpt": "pkgs.pythonPackages.callPackage. Noogle also knows. Aliases. pkgs.callPackage. pkgs.rustPackages.callPackage. pkgs.rustPackages.buildRustPackages.callPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pythonPackages/buildPythonPackage.html",
    "content": "pkgs.pythonPackages.buildPythonPackage.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pythonPackages.buildPythonPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pythonPackages.buildPythonPackage.",
    "raw_url": "/f/pkgs/pythonPackages/buildPythonPackage.html",
    "excerpt": "pkgs.pythonPackages.buildPythonPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/genericUpdater.html",
    "content": "pkgs.genericUpdater.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.genericUpdater"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.genericUpdater.",
    "raw_url": "/f/pkgs/genericUpdater.html",
    "excerpt": "pkgs.genericUpdater.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchurl.html",
    "content": "pkgs.fetchurl.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchurl"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchurl.",
    "raw_url": "/f/pkgs/fetchurl.html",
    "excerpt": "pkgs.fetchurl.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkRuby.html",
    "content": "pkgs.mkRuby. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkRuby"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkRuby. Edit source.",
    "raw_url": "/f/pkgs/mkRuby.html",
    "excerpt": "pkgs.mkRuby. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkRubyVersion.html",
    "content": "pkgs.mkRubyVersion. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkRubyVersion"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkRubyVersion. Edit source.",
    "raw_url": "/f/pkgs/mkRubyVersion.html",
    "excerpt": "pkgs.mkRubyVersion. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/splicePackages.html",
    "content": "pkgs.splicePackages. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.splicePackages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.splicePackages. Edit source.",
    "raw_url": "/f/pkgs/splicePackages.html",
    "excerpt": "pkgs.splicePackages. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapCCWith.html",
    "content": "pkgs.wrapCCWith. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapCCWith"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapCCWith. Edit source.",
    "raw_url": "/f/pkgs/wrapCCWith.html",
    "excerpt": "pkgs.wrapCCWith. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkNvidiaContainerPkg.html",
    "content": "pkgs.mkNvidiaContainerPkg. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkNvidiaContainerPkg"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkNvidiaContainerPkg. Edit source.",
    "raw_url": "/f/pkgs/mkNvidiaContainerPkg.html",
    "excerpt": "pkgs.mkNvidiaContainerPkg. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/jdkdistro.html",
    "content": "pkgs.jdkdistro. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.jdkdistro"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.jdkdistro. Edit source.",
    "raw_url": "/f/pkgs/jdkdistro.html",
    "excerpt": "pkgs.jdkdistro. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/bundlerUpdateScript.html",
    "content": "pkgs.bundlerUpdateScript.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.bundlerUpdateScript"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.bundlerUpdateScript.",
    "raw_url": "/f/pkgs/bundlerUpdateScript.html",
    "excerpt": "pkgs.bundlerUpdateScript.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapQemuBinfmtP.html",
    "content": "pkgs.wrapQemuBinfmtP.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapQemuBinfmtP"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapQemuBinfmtP.",
    "raw_url": "/f/pkgs/wrapQemuBinfmtP.html",
    "excerpt": "pkgs.wrapQemuBinfmtP.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/stdenv/override.html",
    "content": "pkgs.stdenv.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.writers.override.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.stdenv.override"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.stdenv.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.writers.override.",
    "raw_url": "/f/pkgs/stdenv/override.html",
    "excerpt": "pkgs.stdenv.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.writers.override.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/stdenv/fetchurlBoot.html",
    "content": "pkgs.stdenv.fetchurlBoot.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.stdenv.fetchurlBoot"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.stdenv.fetchurlBoot.",
    "raw_url": "/f/pkgs/stdenv/fetchurlBoot.html",
    "excerpt": "pkgs.stdenv.fetchurlBoot.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/stdenv/overrides.html",
    "content": "pkgs.stdenv.overrides. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.stdenv.overrides"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.stdenv.overrides. Edit source.",
    "raw_url": "/f/pkgs/stdenv/overrides.html",
    "excerpt": "pkgs.stdenv.overrides. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/stdenv/mkDerivation.html",
    "content": "pkgs.stdenv.mkDerivation. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.stdenv.mkDerivation"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.stdenv.mkDerivation. Edit source.",
    "raw_url": "/f/pkgs/stdenv/mkDerivation.html",
    "excerpt": "pkgs.stdenv.mkDerivation. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/stdenv/overrideDerivation.html",
    "content": "pkgs.stdenv.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -> ( Derivation -> AttrSet ) -> Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. pkgs.dockerTools.overrideDerivation. lib.overrideDerivation. lib.customisation.overrideDerivation. pkgs.pythonPackages.overrideDerivation. pkgs.writers.overrideDerivation.",
    "word_count": 208,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.stdenv.overrideDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 157
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 182
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 194
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.stdenv.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -&gt; ( Derivation -&gt; AttrSet ) -&gt; Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. pkgs.dockerTools.overrideDerivation. lib.overrideDerivation. lib.customisation.overrideDerivation. pkgs.pythonPackages.overrideDerivation. pkgs.writers.overrideDerivation.",
    "raw_url": "/f/pkgs/stdenv/overrideDerivation.html",
    "excerpt": "pkgs.stdenv.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/themes.html",
    "content": "pkgs.themes. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.themes"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.themes. Edit source.",
    "raw_url": "/f/pkgs/themes.html",
    "excerpt": "pkgs.themes. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/useMoldLinker.html",
    "content": "pkgs.useMoldLinker. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.useMoldLinker"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.useMoldLinker. Edit source.",
    "raw_url": "/f/pkgs/useMoldLinker.html",
    "excerpt": "pkgs.useMoldLinker. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkKops.html",
    "content": "pkgs.mkKops. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkKops"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkKops. Edit source.",
    "raw_url": "/f/pkgs/mkKops.html",
    "excerpt": "pkgs.mkKops. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkTerraform.html",
    "content": "pkgs.mkTerraform. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkTerraform"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkTerraform. Edit source.",
    "raw_url": "/f/pkgs/mkTerraform.html",
    "excerpt": "pkgs.mkTerraform. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchs3.html",
    "content": "pkgs.fetchs3.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchs3"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchs3.",
    "raw_url": "/f/pkgs/fetchs3.html",
    "excerpt": "pkgs.fetchs3.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/linkFarmFromDrvs.html",
    "content": "pkgs.linkFarmFromDrvs. Easily create a linkFarm from a set of derivations. This calls linkFarm with a list of entries created from the list of input derivations. It turns each input derivation into an attribute set like { name = drv.name ; path = drv }, and passes this to linkFarm. Example. # Symlinks the hello, gcc, and ghc derivations in $out linkFarmFromDrvs \"myexample\" [ pkgs.hello pkgs.gcc pkgs.ghc ] This creates a derivation with a directory structure like the following: /nix/store/m3s6wkjy9c3wy830201bqsb91nk2yj8c-myexample |-- gcc-wrapper-9.2.0 -> /nix/store/fqhjxf9ii4w4gqcsx59fyw2vvj91486a-gcc-wrapper-9.2.0 |-- ghc-8.6.5 -> /nix/store/gnf3s07bglhbbk4y6m76sbh42siym0s6-ghc-8.6.5 `-- hello-2.10 -> /nix/store/k0ll91c4npk4lg8lqhx00glg2m735g74-hello-2.10 Arguments. [name] [drvs] Edit source.",
    "word_count": 96,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.linkFarmFromDrvs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 49
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 91
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.linkFarmFromDrvs. Easily create a linkFarm from a set of derivations. This calls linkFarm with a list of entries created from the list of input derivations. It turns each input derivation into an attribute set like { name = drv.name ; path = drv }, and passes this to linkFarm. Example. # Symlinks the hello, gcc, and ghc derivations in $out linkFarmFromDrvs \"myexample\" [ pkgs.hello pkgs.gcc pkgs.ghc ] This creates a derivation with a directory structure like the following: /nix/store/m3s6wkjy9c3wy830201bqsb91nk2yj8c-myexample |-- gcc-wrapper-9.2.0 -&gt; /nix/store/fqhjxf9ii4w4gqcsx59fyw2vvj91486a-gcc-wrapper-9.2.0 |-- ghc-8.6.5 -&gt; /nix/store/gnf3s07bglhbbk4y6m76sbh42siym0s6-ghc-8.6.5 `-- hello-2.10 -&gt; /nix/store/k0ll91c4npk4lg8lqhx00glg2m735g74-hello-2.10 Arguments. [name] [drvs] Edit source.",
    "raw_url": "/f/pkgs/linkFarmFromDrvs.html",
    "excerpt": "pkgs.linkFarmFromDrvs. Easily create a linkFarm from a set of derivations. This calls linkFarm with a list of entries created from the list of input derivations. It turns each input derivation",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapLispi686Linux.html",
    "content": "pkgs.wrapLispi686Linux.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapLispi686Linux"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapLispi686Linux.",
    "raw_url": "/f/pkgs/wrapLispi686Linux.html",
    "excerpt": "pkgs.wrapLispi686Linux.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapHelm.html",
    "content": "pkgs.wrapHelm.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapHelm"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapHelm.",
    "raw_url": "/f/pkgs/wrapHelm.html",
    "excerpt": "pkgs.wrapHelm.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/streamNixShellImage.html",
    "content": "pkgs.dockerTools.streamNixShellImage. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.streamNixShellImage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.streamNixShellImage. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/streamNixShellImage.html",
    "excerpt": "pkgs.dockerTools.streamNixShellImage. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/buildLayeredImageWithNixDb.html",
    "content": "pkgs.dockerTools.buildLayeredImageWithNixDb. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.buildLayeredImageWithNixDb"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.buildLayeredImageWithNixDb. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/buildLayeredImageWithNixDb.html",
    "excerpt": "pkgs.dockerTools.buildLayeredImageWithNixDb. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/buildImageWithNixDb.html",
    "content": "pkgs.dockerTools.buildImageWithNixDb. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.buildImageWithNixDb"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.buildImageWithNixDb. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/buildImageWithNixDb.html",
    "excerpt": "pkgs.dockerTools.buildImageWithNixDb. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/buildLayeredImage.html",
    "content": "pkgs.dockerTools.buildLayeredImage.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.buildLayeredImage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.buildLayeredImage.",
    "raw_url": "/f/pkgs/dockerTools/buildLayeredImage.html",
    "excerpt": "pkgs.dockerTools.buildLayeredImage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/override.html",
    "content": "pkgs.dockerTools.override. Noogle also knows. Aliases. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.override"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.override. Noogle also knows. Aliases. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "raw_url": "/f/pkgs/dockerTools/override.html",
    "excerpt": "pkgs.dockerTools.override. Noogle also knows. Aliases. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/mkPureLayer.html",
    "content": "pkgs.dockerTools.mkPureLayer. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.mkPureLayer"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.mkPureLayer. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/mkPureLayer.html",
    "excerpt": "pkgs.dockerTools.mkPureLayer. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/runWithOverlay.html",
    "content": "pkgs.dockerTools.runWithOverlay. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.runWithOverlay"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.runWithOverlay. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/runWithOverlay.html",
    "excerpt": "pkgs.dockerTools.runWithOverlay. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/mkRootLayer.html",
    "content": "pkgs.dockerTools.mkRootLayer. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.mkRootLayer"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.mkRootLayer. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/mkRootLayer.html",
    "excerpt": "pkgs.dockerTools.mkRootLayer. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/buildNixShellImage.html",
    "content": "pkgs.dockerTools.buildNixShellImage. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.buildNixShellImage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.buildNixShellImage. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/buildNixShellImage.html",
    "excerpt": "pkgs.dockerTools.buildNixShellImage. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/pullImage.html",
    "content": "pkgs.dockerTools.pullImage. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.pullImage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.pullImage. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/pullImage.html",
    "excerpt": "pkgs.dockerTools.pullImage. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/mergeDrvs.html",
    "content": "pkgs.dockerTools.mergeDrvs. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.mergeDrvs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.mergeDrvs. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/mergeDrvs.html",
    "excerpt": "pkgs.dockerTools.mergeDrvs. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/buildImage.html",
    "content": "pkgs.dockerTools.buildImage.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.buildImage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.buildImage.",
    "raw_url": "/f/pkgs/dockerTools/buildImage.html",
    "excerpt": "pkgs.dockerTools.buildImage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/overrideDerivation.html",
    "content": "pkgs.dockerTools.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -> ( Derivation -> AttrSet ) -> Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. lib.overrideDerivation. lib.customisation.overrideDerivation. pkgs.pythonPackages.overrideDerivation. pkgs.stdenv.overrideDerivation. pkgs.writers.overrideDerivation.",
    "word_count": 208,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.overrideDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 157
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 182
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 194
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -&gt; ( Derivation -&gt; AttrSet ) -&gt; Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. lib.overrideDerivation. lib.customisation.overrideDerivation. pkgs.pythonPackages.overrideDerivation. pkgs.stdenv.overrideDerivation. pkgs.writers.overrideDerivation.",
    "raw_url": "/f/pkgs/dockerTools/overrideDerivation.html",
    "excerpt": "pkgs.dockerTools.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/streamLayeredImage.html",
    "content": "pkgs.dockerTools.streamLayeredImage.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.streamLayeredImage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.streamLayeredImage.",
    "raw_url": "/f/pkgs/dockerTools/streamLayeredImage.html",
    "excerpt": "pkgs.dockerTools.streamLayeredImage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/shellScript.html",
    "content": "pkgs.dockerTools.shellScript. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.shellScript"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.shellScript. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/shellScript.html",
    "excerpt": "pkgs.dockerTools.shellScript. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/exportImage.html",
    "content": "pkgs.dockerTools.exportImage. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.exportImage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.exportImage. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/exportImage.html",
    "excerpt": "pkgs.dockerTools.exportImage. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dockerTools/mergeImages.html",
    "content": "pkgs.dockerTools.mergeImages. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dockerTools.mergeImages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dockerTools.mergeImages. Edit source.",
    "raw_url": "/f/pkgs/dockerTools/mergeImages.html",
    "excerpt": "pkgs.dockerTools.mergeImages. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/copyPathToStore.html",
    "content": "pkgs.copyPathToStore. Copy a path to the Nix store. Nix automatically copies files to the store before stringifying paths. If you need the store path of a file, ${copyPathToStore } can be shortened to ${}. Edit source.",
    "word_count": 36,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.copyPathToStore"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.copyPathToStore. Copy a path to the Nix store. Nix automatically copies files to the store before stringifying paths. If you need the store path of a file, ${copyPathToStore } can be shortened to ${}. Edit source.",
    "raw_url": "/f/pkgs/copyPathToStore.html",
    "excerpt": "pkgs.copyPathToStore. Copy a path to the Nix store. Nix automatically copies files to the store before stringifying paths. If you need the store path of a file, ${copyPathToStore } can",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/emacs28WithPackages.html",
    "content": "pkgs.emacs28WithPackages. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.emacs28WithPackages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.emacs28WithPackages. Edit source.",
    "raw_url": "/f/pkgs/emacs28WithPackages.html",
    "excerpt": "pkgs.emacs28WithPackages. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/qtEnv.html",
    "content": "pkgs.qtEnv.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.qtEnv"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.qtEnv.",
    "raw_url": "/f/pkgs/qtEnv.html",
    "excerpt": "pkgs.qtEnv.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeStatic.html",
    "content": "pkgs.makeStatic. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeStatic"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeStatic. Edit source.",
    "raw_url": "/f/pkgs/makeStatic.html",
    "excerpt": "pkgs.makeStatic. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/applyPatches.html",
    "content": "pkgs.applyPatches. Applies a list of patches to a source directory. Example. # Patching nixpkgs: applyPatches { src = pkgs.path; patches = [ (pkgs.fetchpatch { url = \"https://github.com/NixOS/nixpkgs/commit/1f770d20550a413e508e081ddc08464e9d08ba3d.patch\"; sha256 = \"1nlzx171y3r3jbk0qhvnl711kmdk57jlq4na8f8bs8wz2pbffymr\"; }) ]; } Arguments. Edit source.",
    "word_count": 36,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.applyPatches"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 33
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.applyPatches. Applies a list of patches to a source directory. Example. # Patching nixpkgs: applyPatches { src = pkgs.path; patches = [ (pkgs.fetchpatch { url = \"https://github.com/NixOS/nixpkgs/commit/1f770d20550a413e508e081ddc08464e9d08ba3d.patch\"; sha256 = \"1nlzx171y3r3jbk0qhvnl711kmdk57jlq4na8f8bs8wz2pbffymr\"; }) ]; } Arguments. Edit source.",
    "raw_url": "/f/pkgs/applyPatches.html",
    "excerpt": "pkgs.applyPatches. Applies a list of patches to a source directory. Example. # Patching nixpkgs: applyPatches { src = pkgs.path; patches = [ (pkgs.fetchpatch { url = \"https://github.com/NixOS/nixpkgs/commit/1f770d20550a413e508e081ddc08464e9d08ba3d.patch\"; sha256 = \"1nlzx171y3r3jbk0qhvnl711kmdk57jlq4na8f8bs8wz2pbffymr\";",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/bundlerApp.html",
    "content": "pkgs.bundlerApp.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.bundlerApp"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.bundlerApp.",
    "raw_url": "/f/pkgs/bundlerApp.html",
    "excerpt": "pkgs.bundlerApp.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/nixosTest.html",
    "content": "pkgs.nixosTest. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.nixosTest"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.nixosTest. Edit source.",
    "raw_url": "/f/pkgs/nixosTest.html",
    "excerpt": "pkgs.nixosTest. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/puredata-with-plugins.html",
    "content": "pkgs.puredata-with-plugins. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.puredata-with-plugins"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.puredata-with-plugins. Edit source.",
    "raw_url": "/f/pkgs/puredata-with-plugins.html",
    "excerpt": "pkgs.puredata-with-plugins. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkShell.html",
    "content": "pkgs.mkShell.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkShell"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkShell.",
    "raw_url": "/f/pkgs/mkShell.html",
    "excerpt": "pkgs.mkShell.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildGo121Package.html",
    "content": "pkgs.buildGo121Package.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildGo121Package"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildGo121Package.",
    "raw_url": "/f/pkgs/buildGo121Package.html",
    "excerpt": "pkgs.buildGo121Package.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchgitLocal.html",
    "content": "pkgs.fetchgitLocal.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchgitLocal"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchgitLocal.",
    "raw_url": "/f/pkgs/fetchgitLocal.html",
    "excerpt": "pkgs.fetchgitLocal.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchNextcloudApp.html",
    "content": "pkgs.fetchNextcloudApp.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchNextcloudApp"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchNextcloudApp.",
    "raw_url": "/f/pkgs/fetchNextcloudApp.html",
    "excerpt": "pkgs.fetchNextcloudApp.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildEnv.html",
    "content": "pkgs.buildEnv.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildEnv"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildEnv.",
    "raw_url": "/f/pkgs/buildEnv.html",
    "excerpt": "pkgs.buildEnv.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchegg.html",
    "content": "pkgs.fetchegg. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchegg"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchegg. Edit source.",
    "raw_url": "/f/pkgs/fetchegg.html",
    "excerpt": "pkgs.fetchegg. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/aspellWithDicts.html",
    "content": "pkgs.aspellWithDicts.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.aspellWithDicts"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.aspellWithDicts.",
    "raw_url": "/f/pkgs/aspellWithDicts.html",
    "excerpt": "pkgs.aspellWithDicts.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapKakoune.html",
    "content": "pkgs.wrapKakoune. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapKakoune"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapKakoune. Edit source.",
    "raw_url": "/f/pkgs/wrapKakoune.html",
    "excerpt": "pkgs.wrapKakoune. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildLinux.html",
    "content": "pkgs.buildLinux. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildLinux"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildLinux. Edit source.",
    "raw_url": "/f/pkgs/buildLinux.html",
    "excerpt": "pkgs.buildLinux. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeShellScript.html",
    "content": "pkgs.writeShellScript. Similar to writeScript. Writes a Shell script and checks its syntax. Automatically includes interpreter above the contents passed. Example. # Writes my-file to /nix/store/<store path> and makes executable. writeShellScript \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeShellScript"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 36
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeShellScript. Similar to writeScript. Writes a Shell script and checks its syntax. Automatically includes interpreter above the contents passed. Example. # Writes my-file to /nix/store/&lt;store path&gt; and makes executable. writeShellScript \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source.",
    "raw_url": "/f/pkgs/writeShellScript.html",
    "excerpt": "pkgs.writeShellScript. Similar to writeScript. Writes a Shell script and checks its syntax. Automatically includes interpreter above the contents passed. Example. # Writes my-file to /nix/store/&lt;store path&gt; and makes executable. writeShellScript",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/referencesByPopularity.html",
    "content": "pkgs.referencesByPopularity.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.referencesByPopularity"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.referencesByPopularity.",
    "raw_url": "/f/pkgs/referencesByPopularity.html",
    "excerpt": "pkgs.referencesByPopularity.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchFirefoxAddon.html",
    "content": "pkgs.fetchFirefoxAddon.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchFirefoxAddon"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchFirefoxAddon.",
    "raw_url": "/f/pkgs/fetchFirefoxAddon.html",
    "excerpt": "pkgs.fetchFirefoxAddon.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchHex.html",
    "content": "pkgs.fetchHex.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchHex"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchHex.",
    "raw_url": "/f/pkgs/fetchHex.html",
    "excerpt": "pkgs.fetchHex.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/python-setup-hook.html",
    "content": "pkgs.python-setup-hook.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.python-setup-hook"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.python-setup-hook.",
    "raw_url": "/f/pkgs/python-setup-hook.html",
    "excerpt": "pkgs.python-setup-hook.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchsvn.html",
    "content": "pkgs.fetchsvn.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchsvn"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchsvn.",
    "raw_url": "/f/pkgs/fetchsvn.html",
    "excerpt": "pkgs.fetchsvn.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/overrideInStdenv.html",
    "content": "pkgs.overrideInStdenv. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.overrideInStdenv"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.overrideInStdenv. Edit source.",
    "raw_url": "/f/pkgs/overrideInStdenv.html",
    "excerpt": "pkgs.overrideInStdenv. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/gradleGen.html",
    "content": "pkgs.gradleGen. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.gradleGen"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.gradleGen. Edit source.",
    "raw_url": "/f/pkgs/gradleGen.html",
    "excerpt": "pkgs.gradleGen. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildDartApplication.html",
    "content": "pkgs.buildDartApplication.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildDartApplication"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildDartApplication.",
    "raw_url": "/f/pkgs/buildDartApplication.html",
    "excerpt": "pkgs.buildDartApplication.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchdarcs.html",
    "content": "pkgs.fetchdarcs.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchdarcs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchdarcs.",
    "raw_url": "/f/pkgs/fetchdarcs.html",
    "excerpt": "pkgs.fetchdarcs.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchipfs.html",
    "content": "pkgs.fetchipfs.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchipfs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchipfs.",
    "raw_url": "/f/pkgs/fetchipfs.html",
    "excerpt": "pkgs.fetchipfs.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeSetupHook.html",
    "content": "pkgs.makeSetupHook. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeSetupHook"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeSetupHook. Edit source.",
    "raw_url": "/f/pkgs/makeSetupHook.html",
    "excerpt": "pkgs.makeSetupHook. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/datadog-integrations-core.html",
    "content": "pkgs.datadog-integrations-core. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.datadog-integrations-core"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.datadog-integrations-core. Edit source.",
    "raw_url": "/f/pkgs/datadog-integrations-core.html",
    "excerpt": "pkgs.datadog-integrations-core. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/keepDebugInfo.html",
    "content": "pkgs.keepDebugInfo. Modify a stdenv so that it produces debug builds; that is, binaries have debug info, and compiler optimisations are disabled. Arguments. [stdenv] Edit source.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.keepDebugInfo"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 21
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.keepDebugInfo. Modify a stdenv so that it produces debug builds; that is, binaries have debug info, and compiler optimisations are disabled. Arguments. [stdenv] Edit source.",
    "raw_url": "/f/pkgs/keepDebugInfo.html",
    "excerpt": "pkgs.keepDebugInfo. Modify a stdenv so that it produces debug builds; that is, binaries have debug info, and compiler optimisations are disabled. Arguments. [stdenv] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeInitrdNG.html",
    "content": "pkgs.makeInitrdNG.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeInitrdNG"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeInitrdNG.",
    "raw_url": "/f/pkgs/makeInitrdNG.html",
    "excerpt": "pkgs.makeInitrdNG.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/ghc-standalone-archive.html",
    "content": "pkgs.ghc-standalone-archive.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.ghc-standalone-archive"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.ghc-standalone-archive.",
    "raw_url": "/f/pkgs/ghc-standalone-archive.html",
    "excerpt": "pkgs.ghc-standalone-archive.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchFromRepoOrCz.html",
    "content": "pkgs.fetchFromRepoOrCz.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchFromRepoOrCz"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchFromRepoOrCz.",
    "raw_url": "/f/pkgs/fetchFromRepoOrCz.html",
    "excerpt": "pkgs.fetchFromRepoOrCz.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/gitUpdater.html",
    "content": "pkgs.gitUpdater.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.gitUpdater"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.gitUpdater.",
    "raw_url": "/f/pkgs/gitUpdater.html",
    "excerpt": "pkgs.gitUpdater.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/bundlerEnv.html",
    "content": "pkgs.bundlerEnv.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.bundlerEnv"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.bundlerEnv.",
    "raw_url": "/f/pkgs/bundlerEnv.html",
    "excerpt": "pkgs.bundlerEnv.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapWatcom.html",
    "content": "pkgs.wrapWatcom.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapWatcom"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapWatcom.",
    "raw_url": "/f/pkgs/wrapWatcom.html",
    "excerpt": "pkgs.wrapWatcom.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/quicklispPackagesFor.html",
    "content": "pkgs.quicklispPackagesFor. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.quicklispPackagesFor"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.quicklispPackagesFor. Edit source.",
    "raw_url": "/f/pkgs/quicklispPackagesFor.html",
    "excerpt": "pkgs.quicklispPackagesFor. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchMavenArtifact.html",
    "content": "pkgs.fetchMavenArtifact.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchMavenArtifact"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchMavenArtifact.",
    "raw_url": "/f/pkgs/fetchMavenArtifact.html",
    "excerpt": "pkgs.fetchMavenArtifact.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchFromBitbucket.html",
    "content": "pkgs.fetchFromBitbucket.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchFromBitbucket"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchFromBitbucket.",
    "raw_url": "/f/pkgs/fetchFromBitbucket.html",
    "excerpt": "pkgs.fetchFromBitbucket.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapCCMulti.html",
    "content": "pkgs.wrapCCMulti. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapCCMulti"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapCCMulti. Edit source.",
    "raw_url": "/f/pkgs/wrapCCMulti.html",
    "excerpt": "pkgs.wrapCCMulti. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeStaticBinaries.html",
    "content": "pkgs.makeStaticBinaries. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeStaticBinaries"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeStaticBinaries. Edit source.",
    "raw_url": "/f/pkgs/makeStaticBinaries.html",
    "excerpt": "pkgs.makeStaticBinaries. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchgx.html",
    "content": "pkgs.fetchgx.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchgx"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchgx.",
    "raw_url": "/f/pkgs/fetchgx.html",
    "excerpt": "pkgs.fetchgx.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeAutostartItem.html",
    "content": "pkgs.makeAutostartItem.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeAutostartItem"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeAutostartItem.",
    "raw_url": "/f/pkgs/makeAutostartItem.html",
    "excerpt": "pkgs.makeAutostartItem.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/substitute.html",
    "content": "pkgs.substitute.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.substitute"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.substitute.",
    "raw_url": "/f/pkgs/substitute.html",
    "excerpt": "pkgs.substitute.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeReferencesToFile.html",
    "content": "pkgs.writeReferencesToFile. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeReferencesToFile"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeReferencesToFile. Edit source.",
    "raw_url": "/f/pkgs/writeReferencesToFile.html",
    "excerpt": "pkgs.writeReferencesToFile. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchFromGitHub.html",
    "content": "pkgs.fetchFromGitHub.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchFromGitHub"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchFromGitHub.",
    "raw_url": "/f/pkgs/fetchFromGitHub.html",
    "excerpt": "pkgs.fetchFromGitHub.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/hardenedLinuxPackagesFor.html",
    "content": "pkgs.hardenedLinuxPackagesFor. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.hardenedLinuxPackagesFor"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.hardenedLinuxPackagesFor. Edit source.",
    "raw_url": "/f/pkgs/hardenedLinuxPackagesFor.html",
    "excerpt": "pkgs.hardenedLinuxPackagesFor. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/myEnvFun.html",
    "content": "pkgs.myEnvFun.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.myEnvFun"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.myEnvFun.",
    "raw_url": "/f/pkgs/myEnvFun.html",
    "excerpt": "pkgs.myEnvFun.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkStdenvNoLibs.html",
    "content": "pkgs.mkStdenvNoLibs. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkStdenvNoLibs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkStdenvNoLibs. Edit source.",
    "raw_url": "/f/pkgs/mkStdenvNoLibs.html",
    "excerpt": "pkgs.mkStdenvNoLibs. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dhallPackageToNix.html",
    "content": "pkgs.dhallPackageToNix.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dhallPackageToNix"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dhallPackageToNix.",
    "raw_url": "/f/pkgs/dhallPackageToNix.html",
    "excerpt": "pkgs.dhallPackageToNix.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapMpv.html",
    "content": "pkgs.wrapMpv.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapMpv"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapMpv.",
    "raw_url": "/f/pkgs/wrapMpv.html",
    "excerpt": "pkgs.wrapMpv.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchpijul.html",
    "content": "pkgs.fetchpijul.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchpijul"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchpijul.",
    "raw_url": "/f/pkgs/fetchpijul.html",
    "excerpt": "pkgs.fetchpijul.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/zabbixFor.html",
    "content": "pkgs.zabbixFor. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.zabbixFor"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.zabbixFor. Edit source.",
    "raw_url": "/f/pkgs/zabbixFor.html",
    "excerpt": "pkgs.zabbixFor. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/compressFirmwareXz.html",
    "content": "pkgs.compressFirmwareXz.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.compressFirmwareXz"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.compressFirmwareXz.",
    "raw_url": "/f/pkgs/compressFirmwareXz.html",
    "excerpt": "pkgs.compressFirmwareXz.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeStaticDarwin.html",
    "content": "pkgs.makeStaticDarwin. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeStaticDarwin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeStaticDarwin. Edit source.",
    "raw_url": "/f/pkgs/makeStaticDarwin.html",
    "excerpt": "pkgs.makeStaticDarwin. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapNeovim.html",
    "content": "pkgs.wrapNeovim. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapNeovim"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapNeovim. Edit source.",
    "raw_url": "/f/pkgs/wrapNeovim.html",
    "excerpt": "pkgs.wrapNeovim. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchFrom9Front.html",
    "content": "pkgs.fetchFrom9Front.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchFrom9Front"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchFrom9Front.",
    "raw_url": "/f/pkgs/fetchFrom9Front.html",
    "excerpt": "pkgs.fetchFrom9Front.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildPgrxExtension.html",
    "content": "pkgs.buildPgrxExtension.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildPgrxExtension"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildPgrxExtension.",
    "raw_url": "/f/pkgs/buildPgrxExtension.html",
    "excerpt": "pkgs.buildPgrxExtension.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/recurseIntoAttrs.html",
    "content": "pkgs.recurseIntoAttrs. Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc. This function only affects a single attribute set; it does not apply itself recursively for nested attribute sets. Example. { pkgs ? import <nixpkgs> {} }: { myTools = pkgs.lib.recurseIntoAttrs { inherit (pkgs) hello figlet; }; } Type. recurseIntoAttrs :: AttrSet -> AttrSet Arguments. [attrs] An attribute set to scan for derivations. Edit source. Noogle also knows. Aliases. lib.recurseIntoAttrs. lib.attrsets.recurseIntoAttrs.",
    "word_count": 81,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.recurseIntoAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 39
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 58
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 64
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.recurseIntoAttrs. Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc. This function only affects a single attribute set; it does not apply itself recursively for nested attribute sets. Example. { pkgs ? import &lt;nixpkgs&gt; {} }: { myTools = pkgs.lib.recurseIntoAttrs { inherit (pkgs) hello figlet; }; } Type. recurseIntoAttrs :: AttrSet -&gt; AttrSet Arguments. [attrs] An attribute set to scan for derivations. Edit source. Noogle also knows. Aliases. lib.recurseIntoAttrs. lib.attrsets.recurseIntoAttrs.",
    "raw_url": "/f/pkgs/recurseIntoAttrs.html",
    "excerpt": "pkgs.recurseIntoAttrs. Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc. This function only affects a single attribute set; it",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkBinaryCache.html",
    "content": "pkgs.mkBinaryCache.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkBinaryCache"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkBinaryCache.",
    "raw_url": "/f/pkgs/mkBinaryCache.html",
    "excerpt": "pkgs.mkBinaryCache.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/_internalCallByNamePackageFile.html",
    "content": "pkgs._internalCallByNamePackageFile. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs._internalCallByNamePackageFile"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs._internalCallByNamePackageFile. Edit source.",
    "raw_url": "/f/pkgs/_internalCallByNamePackageFile.html",
    "excerpt": "pkgs._internalCallByNamePackageFile. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildMozillaMach.html",
    "content": "pkgs.buildMozillaMach. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildMozillaMach"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildMozillaMach. Edit source.",
    "raw_url": "/f/pkgs/buildMozillaMach.html",
    "excerpt": "pkgs.buildMozillaMach. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapCC.html",
    "content": "pkgs.wrapCC. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapCC"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapCC. Edit source.",
    "raw_url": "/f/pkgs/wrapCC.html",
    "excerpt": "pkgs.wrapCC. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/overrideSetup.html",
    "content": "pkgs.overrideSetup. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.overrideSetup"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.overrideSetup. Edit source.",
    "raw_url": "/f/pkgs/overrideSetup.html",
    "excerpt": "pkgs.overrideSetup. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/oraclejdk8distro.html",
    "content": "pkgs.oraclejdk8distro. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.oraclejdk8distro"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.oraclejdk8distro. Edit source.",
    "raw_url": "/f/pkgs/oraclejdk8distro.html",
    "excerpt": "pkgs.oraclejdk8distro. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/withCFlags.html",
    "content": "pkgs.withCFlags. Modify a stdenv so that it builds binaries with the specified list of compilerFlags appended and passed to the compiler. This example would recompile every derivation on the system with -funroll-loops and -O3 passed to each gcc invocation. Example. nixpkgs.overlays = [ (self: super: { stdenv = super.withCFlags [ \"-funroll-loops\" \"-O3\" ] super.stdenv; }) ]; Arguments. [compilerFlags] [stdenv] Edit source.",
    "word_count": 61,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.withCFlags"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 39
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 56
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.withCFlags. Modify a stdenv so that it builds binaries with the specified list of compilerFlags appended and passed to the compiler. This example would recompile every derivation on the system with -funroll-loops and -O3 passed to each gcc invocation. Example. nixpkgs.overlays = [ (self: super: { stdenv = super.withCFlags [ \"-funroll-loops\" \"-O3\" ] super.stdenv; }) ]; Arguments. [compilerFlags] [stdenv] Edit source.",
    "raw_url": "/f/pkgs/withCFlags.html",
    "excerpt": "pkgs.withCFlags. Modify a stdenv so that it builds binaries with the specified list of compilerFlags appended and passed to the compiler. This example would recompile every derivation on the system",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildNpmPackage.html",
    "content": "pkgs.buildNpmPackage.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildNpmPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildNpmPackage.",
    "raw_url": "/f/pkgs/buildNpmPackage.html",
    "excerpt": "pkgs.buildNpmPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchsvnssh.html",
    "content": "pkgs.fetchsvnssh.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchsvnssh"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchsvnssh.",
    "raw_url": "/f/pkgs/fetchsvnssh.html",
    "excerpt": "pkgs.fetchsvnssh.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeShellApplication.html",
    "content": "pkgs.writeShellApplication. Similar to writeShellScriptBin and writeScriptBin. Writes an executable Shell script to /nix/store//bin/ and checks its syntax with shellcheck and the shell's -n option. Individual checks can be foregone by putting them in the excludeShellChecks list, e.g. [ \"SC2016\" ]. Automatically includes sane set of shellopts (errexit, nounset, pipefail) and handles creation of PATH based on runtimeInputs Note that the checkPhase uses stdenv.shell for the test run of the script, while the generated shebang uses runtimeShell. If, for whatever reason, those were to mismatch you might lose fidelity in the default checks. Example. Writes my-file to /nix/store/<store path>/bin/my-file and makes executable. writeShellApplication { name = \"my-file\"; runtimeInputs = [ curl w3m ]; text = '' curl -s 'https://nixos.org' | w3m -dump -T text/html ''; } Arguments. Edit source.",
    "word_count": 128,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeShellApplication"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 92
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 125
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeShellApplication. Similar to writeShellScriptBin and writeScriptBin. Writes an executable Shell script to /nix/store//bin/ and checks its syntax with shellcheck and the shell's -n option. Individual checks can be foregone by putting them in the excludeShellChecks list, e.g. [ \"SC2016\" ]. Automatically includes sane set of shellopts (errexit, nounset, pipefail) and handles creation of PATH based on runtimeInputs Note that the checkPhase uses stdenv.shell for the test run of the script, while the generated shebang uses runtimeShell. If, for whatever reason, those were to mismatch you might lose fidelity in the default checks. Example. Writes my-file to /nix/store/&lt;store path&gt;/bin/my-file and makes executable. writeShellApplication { name = \"my-file\"; runtimeInputs = [ curl w3m ]; text = '' curl -s 'https://nixos.org' | w3m -dump -T text/html ''; } Arguments. Edit source.",
    "raw_url": "/f/pkgs/writeShellApplication.html",
    "excerpt": "pkgs.writeShellApplication. Similar to writeShellScriptBin and writeScriptBin. Writes an executable Shell script to /nix/store//bin/ and checks its syntax with shellcheck and the shell's -n option. Individual checks can be foregone by",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeRustPlatform.html",
    "content": "pkgs.makeRustPlatform.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeRustPlatform"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeRustPlatform.",
    "raw_url": "/f/pkgs/makeRustPlatform.html",
    "excerpt": "pkgs.makeRustPlatform.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/hiPrio.html",
    "content": "pkgs.hiPrio. Increase the nix-env priority of the package, i.e., this version/variant of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.hiPrio. lib.meta.hiPrio.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.hiPrio"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.hiPrio. Increase the nix-env priority of the package, i.e., this version/variant of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.hiPrio. lib.meta.hiPrio.",
    "raw_url": "/f/pkgs/hiPrio.html",
    "excerpt": "pkgs.hiPrio. Increase the nix-env priority of the package, i.e., this version/variant of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.hiPrio. lib.meta.hiPrio.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildFHSEnv.html",
    "content": "pkgs.buildFHSEnv.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildFHSEnv"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildFHSEnv.",
    "raw_url": "/f/pkgs/buildFHSEnv.html",
    "excerpt": "pkgs.buildFHSEnv.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/substituteAllFiles.html",
    "content": "pkgs.substituteAllFiles.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.substituteAllFiles"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.substituteAllFiles.",
    "raw_url": "/f/pkgs/substituteAllFiles.html",
    "excerpt": "pkgs.substituteAllFiles.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildRustCrate.html",
    "content": "pkgs.buildRustCrate.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildRustCrate"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildRustCrate.",
    "raw_url": "/f/pkgs/buildRustCrate.html",
    "excerpt": "pkgs.buildRustCrate.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/bitlbee-plugins.html",
    "content": "pkgs.bitlbee-plugins.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.bitlbee-plugins"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.bitlbee-plugins.",
    "raw_url": "/f/pkgs/bitlbee-plugins.html",
    "excerpt": "pkgs.bitlbee-plugins.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/packages.html",
    "content": "pkgs.rustPackages.packages. Edit source. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.packages. pkgs.pythonPackages.packages.",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.packages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.packages. Edit source. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.packages. pkgs.pythonPackages.packages.",
    "raw_url": "/f/pkgs/rustPackages/packages.html",
    "excerpt": "pkgs.rustPackages.packages. Edit source. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.packages. pkgs.pythonPackages.packages.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/newScope.html",
    "content": "pkgs.rustPackages.newScope. Edit source. Noogle also knows. Aliases. pkgs.newScope. pkgs.pythonPackages.newScope. pkgs.rustPackages.buildRustPackages.newScope.",
    "word_count": 10,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.newScope"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.newScope. Edit source. Noogle also knows. Aliases. pkgs.newScope. pkgs.pythonPackages.newScope. pkgs.rustPackages.buildRustPackages.newScope.",
    "raw_url": "/f/pkgs/rustPackages/newScope.html",
    "excerpt": "pkgs.rustPackages.newScope. Edit source. Noogle also knows. Aliases. pkgs.newScope. pkgs.pythonPackages.newScope. pkgs.rustPackages.buildRustPackages.newScope.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/packages.html",
    "content": "pkgs.rustPackages.buildRustPackages.packages. Edit source. Noogle also knows. Aliases. pkgs.rustPackages.packages. pkgs.pythonPackages.packages.",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.packages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.packages. Edit source. Noogle also knows. Aliases. pkgs.rustPackages.packages. pkgs.pythonPackages.packages.",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/packages.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.packages. Edit source. Noogle also knows. Aliases. pkgs.rustPackages.packages. pkgs.pythonPackages.packages.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/newScope.html",
    "content": "pkgs.rustPackages.buildRustPackages.newScope. Edit source. Noogle also knows. Aliases. pkgs.newScope. pkgs.pythonPackages.newScope. pkgs.rustPackages.newScope.",
    "word_count": 10,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.newScope"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.newScope. Edit source. Noogle also knows. Aliases. pkgs.newScope. pkgs.pythonPackages.newScope. pkgs.rustPackages.newScope.",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/newScope.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.newScope. Edit source. Noogle also knows. Aliases. pkgs.newScope. pkgs.pythonPackages.newScope. pkgs.rustPackages.newScope.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/overrideScope'.html",
    "content": "pkgs.rustPackages.buildRustPackages.overrideScope' (Prime). Edit source. Noogle also knows. Aliases. pkgs.rustPackages.overrideScope'",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.overrideScope' (Prime)"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.overrideScope' (Prime). Edit source. Noogle also knows. Aliases. pkgs.rustPackages.overrideScope'",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/overrideScope'.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.overrideScope' (Prime). Edit source. Noogle also knows. Aliases. pkgs.rustPackages.overrideScope'",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/overrideScope.html",
    "content": "pkgs.rustPackages.buildRustPackages.overrideScope. Edit source. Noogle also knows. Aliases. pkgs.pythonPackages.overrideScope. pkgs.rustPackages.overrideScope.",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.overrideScope"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.overrideScope. Edit source. Noogle also knows. Aliases. pkgs.pythonPackages.overrideScope. pkgs.rustPackages.overrideScope.",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/overrideScope.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.overrideScope. Edit source. Noogle also knows. Aliases. pkgs.pythonPackages.overrideScope. pkgs.rustPackages.overrideScope.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/callPackage.html",
    "content": "pkgs.rustPackages.buildRustPackages.callPackage. Noogle also knows. Aliases. pkgs.callPackage. pkgs.pythonPackages.callPackage. pkgs.rustPackages.callPackage.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.callPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.callPackage. Noogle also knows. Aliases. pkgs.callPackage. pkgs.pythonPackages.callPackage. pkgs.rustPackages.callPackage.",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/callPackage.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.callPackage. Noogle also knows. Aliases. pkgs.callPackage. pkgs.pythonPackages.callPackage. pkgs.rustPackages.callPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/fetchCargoTarball.html",
    "content": "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball. Noogle also knows. Aliases. pkgs.rustPackages.rustPlatform.fetchCargoTarball.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball. Noogle also knows. Aliases. pkgs.rustPackages.rustPlatform.fetchCargoTarball.",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/fetchCargoTarball.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball. Noogle also knows. Aliases. pkgs.rustPackages.rustPlatform.fetchCargoTarball.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/fetchCargoTarball/override.html",
    "content": "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/fetchCargoTarball/override.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/importCargoLock.html",
    "content": "pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock. Noogle also knows. Aliases. pkgs.rustPackages.rustPlatform.importCargoLock.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock. Noogle also knows. Aliases. pkgs.rustPackages.rustPlatform.importCargoLock.",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/importCargoLock.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock. Noogle also knows. Aliases. pkgs.rustPackages.rustPlatform.importCargoLock.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/buildRustPackage.html",
    "content": "pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage. Noogle also knows. Aliases. pkgs.rustPackages.rustPlatform.buildRustPackage.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage. Noogle also knows. Aliases. pkgs.rustPackages.rustPlatform.buildRustPackage.",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/buildRustPackage.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage. Noogle also knows. Aliases. pkgs.rustPackages.rustPlatform.buildRustPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/importCargoLock/override.html",
    "content": "pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.stdenv.override. pkgs.writers.override.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.stdenv.override. pkgs.writers.override.",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/importCargoLock/override.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.stdenv.override. pkgs.writers.override.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/buildRustPackage/override.html",
    "content": "pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "raw_url": "/f/pkgs/rustPackages/buildRustPackages/rustPlatform/buildRustPackage/override.html",
    "excerpt": "pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/overrideScope'.html",
    "content": "pkgs.rustPackages.overrideScope' (Prime). Edit source. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.overrideScope'",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.overrideScope' (Prime)"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.overrideScope' (Prime). Edit source. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.overrideScope'",
    "raw_url": "/f/pkgs/rustPackages/overrideScope'.html",
    "excerpt": "pkgs.rustPackages.overrideScope' (Prime). Edit source. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.overrideScope'",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/overrideScope.html",
    "content": "pkgs.rustPackages.overrideScope. Edit source. Noogle also knows. Aliases. pkgs.pythonPackages.overrideScope. pkgs.rustPackages.buildRustPackages.overrideScope.",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.overrideScope"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.overrideScope. Edit source. Noogle also knows. Aliases. pkgs.pythonPackages.overrideScope. pkgs.rustPackages.buildRustPackages.overrideScope.",
    "raw_url": "/f/pkgs/rustPackages/overrideScope.html",
    "excerpt": "pkgs.rustPackages.overrideScope. Edit source. Noogle also knows. Aliases. pkgs.pythonPackages.overrideScope. pkgs.rustPackages.buildRustPackages.overrideScope.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/callPackage.html",
    "content": "pkgs.rustPackages.callPackage. Noogle also knows. Aliases. pkgs.callPackage. pkgs.pythonPackages.callPackage. pkgs.rustPackages.buildRustPackages.callPackage.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.callPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.callPackage. Noogle also knows. Aliases. pkgs.callPackage. pkgs.pythonPackages.callPackage. pkgs.rustPackages.buildRustPackages.callPackage.",
    "raw_url": "/f/pkgs/rustPackages/callPackage.html",
    "excerpt": "pkgs.rustPackages.callPackage. Noogle also knows. Aliases. pkgs.callPackage. pkgs.pythonPackages.callPackage. pkgs.rustPackages.buildRustPackages.callPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/rustPlatform/fetchCargoTarball.html",
    "content": "pkgs.rustPackages.rustPlatform.fetchCargoTarball. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.rustPlatform.fetchCargoTarball"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.rustPlatform.fetchCargoTarball. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.",
    "raw_url": "/f/pkgs/rustPackages/rustPlatform/fetchCargoTarball.html",
    "excerpt": "pkgs.rustPackages.rustPlatform.fetchCargoTarball. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/rustPlatform/fetchCargoTarball/override.html",
    "content": "pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.rustPlatform.fetchCargoTarball.override"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "raw_url": "/f/pkgs/rustPackages/rustPlatform/fetchCargoTarball/override.html",
    "excerpt": "pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/rustPlatform/importCargoLock.html",
    "content": "pkgs.rustPackages.rustPlatform.importCargoLock. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.rustPlatform.importCargoLock"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.rustPlatform.importCargoLock. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.",
    "raw_url": "/f/pkgs/rustPackages/rustPlatform/importCargoLock.html",
    "excerpt": "pkgs.rustPackages.rustPlatform.importCargoLock. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/rustPlatform/buildRustPackage.html",
    "content": "pkgs.rustPackages.rustPlatform.buildRustPackage. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.rustPlatform.buildRustPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.rustPlatform.buildRustPackage. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.",
    "raw_url": "/f/pkgs/rustPackages/rustPlatform/buildRustPackage.html",
    "excerpt": "pkgs.rustPackages.rustPlatform.buildRustPackage. Noogle also knows. Aliases. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/rustPlatform/importCargoLock/override.html",
    "content": "pkgs.rustPackages.rustPlatform.importCargoLock.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.rustPlatform.importCargoLock.override"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.rustPlatform.importCargoLock.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "raw_url": "/f/pkgs/rustPackages/rustPlatform/importCargoLock/override.html",
    "excerpt": "pkgs.rustPackages.rustPlatform.importCargoLock.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/rustPackages/rustPlatform/buildRustPackage/override.html",
    "content": "pkgs.rustPackages.rustPlatform.buildRustPackage.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.rustPackages.rustPlatform.buildRustPackage.override"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.rustPackages.rustPlatform.buildRustPackage.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "raw_url": "/f/pkgs/rustPackages/rustPlatform/buildRustPackage/override.html",
    "excerpt": "pkgs.rustPackages.rustPlatform.buildRustPackage.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override. pkgs.writers.override.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkNoto.html",
    "content": "pkgs.mkNoto.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkNoto"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkNoto.",
    "raw_url": "/f/pkgs/mkNoto.html",
    "excerpt": "pkgs.mkNoto.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/impureUseNativeOptimizations.html",
    "content": "pkgs.impureUseNativeOptimizations. Modify a stdenv so that it builds binaries optimized specifically for the machine they are built on. WARNING: this breaks purity! Arguments. [stdenv] Edit source.",
    "word_count": 26,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.impureUseNativeOptimizations"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 22
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.impureUseNativeOptimizations. Modify a stdenv so that it builds binaries optimized specifically for the machine they are built on. WARNING: this breaks purity! Arguments. [stdenv] Edit source.",
    "raw_url": "/f/pkgs/impureUseNativeOptimizations.html",
    "excerpt": "pkgs.impureUseNativeOptimizations. Modify a stdenv so that it builds binaries optimized specifically for the machine they are built on. WARNING: this breaks purity! Arguments. [stdenv] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapNeovimUnstable.html",
    "content": "pkgs.wrapNeovimUnstable.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapNeovimUnstable"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapNeovimUnstable.",
    "raw_url": "/f/pkgs/wrapNeovimUnstable.html",
    "excerpt": "pkgs.wrapNeovimUnstable.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/libcIconv.html",
    "content": "pkgs.libcIconv. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.libcIconv"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.libcIconv. Edit source.",
    "raw_url": "/f/pkgs/libcIconv.html",
    "excerpt": "pkgs.libcIconv. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/directoryListingUpdater.html",
    "content": "pkgs.directoryListingUpdater.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.directoryListingUpdater"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.directoryListingUpdater.",
    "raw_url": "/f/pkgs/directoryListingUpdater.html",
    "excerpt": "pkgs.directoryListingUpdater.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkCoqPackages.html",
    "content": "pkgs.mkCoqPackages. The function mkCoqPackages takes as input a derivation for Coq and produces. a set of libraries built with that specific Coq. More libraries are known to. this function than what is compatible with that version of Coq. Therefore, libraries that are not known to be compatible are removed (filtered out) from. the resulting set. For meta-programming purposes (inpecting the derivations. rather than building the libraries) this filtering can be disabled by setting. a dontFilter attribute into the Coq derivation. Arguments. [coq] Edit source.",
    "word_count": 84,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkCoqPackages"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 80
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkCoqPackages. The function mkCoqPackages takes as input a derivation for Coq and produces. a set of libraries built with that specific Coq. More libraries are known to. this function than what is compatible with that version of Coq. Therefore, libraries that are not known to be compatible are removed (filtered out) from. the resulting set. For meta-programming purposes (inpecting the derivations. rather than building the libraries) this filtering can be disabled by setting. a dontFilter attribute into the Coq derivation. Arguments. [coq] Edit source.",
    "raw_url": "/f/pkgs/mkCoqPackages.html",
    "excerpt": "pkgs.mkCoqPackages. The function mkCoqPackages takes as input a derivation for Coq and produces. a set of libraries built with that specific Coq. More libraries are known to. this function than",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildMaven.html",
    "content": "pkgs.buildMaven.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildMaven"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildMaven.",
    "raw_url": "/f/pkgs/buildMaven.html",
    "excerpt": "pkgs.buildMaven.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchzip.html",
    "content": "pkgs.fetchzip.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchzip"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchzip.",
    "raw_url": "/f/pkgs/fetchzip.html",
    "excerpt": "pkgs.fetchzip.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchmtn.html",
    "content": "pkgs.fetchmtn.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchmtn"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchmtn.",
    "raw_url": "/f/pkgs/fetchmtn.html",
    "excerpt": "pkgs.fetchmtn.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/vscodium-fhsWithPackages.html",
    "content": "pkgs.vscodium-fhsWithPackages. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.vscodium-fhsWithPackages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.vscodium-fhsWithPackages. Edit source.",
    "raw_url": "/f/pkgs/vscodium-fhsWithPackages.html",
    "excerpt": "pkgs.vscodium-fhsWithPackages. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildFHSUserEnv.html",
    "content": "pkgs.buildFHSUserEnv.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildFHSUserEnv"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildFHSUserEnv.",
    "raw_url": "/f/pkgs/buildFHSUserEnv.html",
    "excerpt": "pkgs.buildFHSUserEnv.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/propagateBuildInputs.html",
    "content": "pkgs.propagateBuildInputs. Modify a stdenv so that all buildInputs are implicitly propagated to consuming derivations. Arguments. [stdenv] Edit source.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.propagateBuildInputs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.propagateBuildInputs. Modify a stdenv so that all buildInputs are implicitly propagated to consuming derivations. Arguments. [stdenv] Edit source.",
    "raw_url": "/f/pkgs/propagateBuildInputs.html",
    "excerpt": "pkgs.propagateBuildInputs. Modify a stdenv so that all buildInputs are implicitly propagated to consuming derivations. Arguments. [stdenv] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkNugetDeps.html",
    "content": "pkgs.mkNugetDeps.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkNugetDeps"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkNugetDeps.",
    "raw_url": "/f/pkgs/mkNugetDeps.html",
    "excerpt": "pkgs.mkNugetDeps.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/forceSystem.html",
    "content": "pkgs.forceSystem. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.forceSystem"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.forceSystem. Edit source.",
    "raw_url": "/f/pkgs/forceSystem.html",
    "excerpt": "pkgs.forceSystem. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeScript.html",
    "content": "pkgs.writeScript. Writes a text file to /nix/store/ and marks the file as executable. If passed as a build input, will be used as a setup hook. This makes setup hooks more efficient to create: you don't need a derivation that copies them to $out/nix-support/setup-hook, instead you can use the file as is. Example. # Writes my-file to /nix/store/<store path> and makes executable writeScript \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source.",
    "word_count": 74,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeScript"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 52
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 69
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeScript. Writes a text file to /nix/store/ and marks the file as executable. If passed as a build input, will be used as a setup hook. This makes setup hooks more efficient to create: you don't need a derivation that copies them to $out/nix-support/setup-hook, instead you can use the file as is. Example. # Writes my-file to /nix/store/&lt;store path&gt; and makes executable writeScript \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source.",
    "raw_url": "/f/pkgs/writeScript.html",
    "excerpt": "pkgs.writeScript. Writes a text file to /nix/store/ and marks the file as executable. If passed as a build input, will be used as a setup hook. This makes setup hooks",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildGo121Module.html",
    "content": "pkgs.buildGo121Module.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildGo121Module"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildGo121Module.",
    "raw_url": "/f/pkgs/buildGo121Module.html",
    "excerpt": "pkgs.buildGo121Module.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeDesktopItem.html",
    "content": "pkgs.makeDesktopItem.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeDesktopItem"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeDesktopItem.",
    "raw_url": "/f/pkgs/makeDesktopItem.html",
    "excerpt": "pkgs.makeDesktopItem.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/runCommandNoCCLocal.html",
    "content": "pkgs.runCommandNoCCLocal. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.runCommandNoCCLocal"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.runCommandNoCCLocal. Edit source.",
    "raw_url": "/f/pkgs/runCommandNoCCLocal.html",
    "excerpt": "pkgs.runCommandNoCCLocal. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeText.html",
    "content": "pkgs.writeText. Writes a text file to nix store with no optional parameters available. Example. # Writes contents of file to /nix/store/<store path> writeText \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source. Noogle also knows. Aliases. pkgs.writers.writeText.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeText"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeText. Writes a text file to nix store with no optional parameters available. Example. # Writes contents of file to /nix/store/&lt;store path&gt; writeText \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source. Noogle also knows. Aliases. pkgs.writers.writeText.",
    "raw_url": "/f/pkgs/writeText.html",
    "excerpt": "pkgs.writeText. Writes a text file to nix store with no optional parameters available. Example. # Writes contents of file to /nix/store/&lt;store path&gt; writeText \"my-file\" '' Contents of File ''; Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/prefer-remote-fetch.html",
    "content": "pkgs.prefer-remote-fetch. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.prefer-remote-fetch"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.prefer-remote-fetch. Edit source.",
    "raw_url": "/f/pkgs/prefer-remote-fetch.html",
    "excerpt": "pkgs.prefer-remote-fetch. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/extend.html",
    "content": "pkgs.extend. Edit source. Noogle also knows. Aliases. lib.extend.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.extend"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.extend. Edit source. Noogle also knows. Aliases. lib.extend.",
    "raw_url": "/f/pkgs/extend.html",
    "excerpt": "pkgs.extend. Edit source. Noogle also knows. Aliases. lib.extend.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeDarwinBundle.html",
    "content": "pkgs.makeDarwinBundle.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeDarwinBundle"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeDarwinBundle.",
    "raw_url": "/f/pkgs/makeDarwinBundle.html",
    "excerpt": "pkgs.makeDarwinBundle.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildHomeAssistantComponent.html",
    "content": "pkgs.buildHomeAssistantComponent.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildHomeAssistantComponent"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildHomeAssistantComponent.",
    "raw_url": "/f/pkgs/buildHomeAssistantComponent.html",
    "excerpt": "pkgs.buildHomeAssistantComponent.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeScopeWithSplicing'.html",
    "content": "pkgs.makeScopeWithSplicing' (Prime). Like makeScope, but aims to support cross compilation. It's still ugly, but hopefully it helps a little bit. Type. makeScopeWithSplicing' :: { splicePackages :: Splice -> AttrSet , newScope :: AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a } -> { otherSplices :: Splice, keep :: AttrSet -> AttrSet, extra :: AttrSet -> AttrSet } -> AttrSet Splice :: { pkgsBuildBuild :: AttrSet , pkgsBuildHost :: AttrSet , pkgsBuildTarget :: AttrSet , pkgsHostHost :: AttrSet , pkgsHostTarget :: AttrSet , pkgsTargetTarget :: AttrSet } Arguments. Edit source. Noogle also knows. Aliases. lib.makeScopeWithSplicing' lib.customisation.makeScopeWithSplicing'",
    "word_count": 98,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeScopeWithSplicing' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 89
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeScopeWithSplicing' (Prime). Like makeScope, but aims to support cross compilation. It's still ugly, but hopefully it helps a little bit. Type. makeScopeWithSplicing' :: { splicePackages :: Splice -&gt; AttrSet , newScope :: AttrSet -&gt; ((AttrSet -&gt; a) | Path) -&gt; AttrSet -&gt; a } -&gt; { otherSplices :: Splice, keep :: AttrSet -&gt; AttrSet, extra :: AttrSet -&gt; AttrSet } -&gt; AttrSet Splice :: { pkgsBuildBuild :: AttrSet , pkgsBuildHost :: AttrSet , pkgsBuildTarget :: AttrSet , pkgsHostHost :: AttrSet , pkgsHostTarget :: AttrSet , pkgsTargetTarget :: AttrSet } Arguments. Edit source. Noogle also knows. Aliases. lib.makeScopeWithSplicing' lib.customisation.makeScopeWithSplicing'",
    "raw_url": "/f/pkgs/makeScopeWithSplicing'.html",
    "excerpt": "pkgs.makeScopeWithSplicing' (Prime). Like makeScope, but aims to support cross compilation. It's still ugly, but hopefully it helps a little bit. Type. makeScopeWithSplicing' :: { splicePackages :: Splice -&gt; AttrSet ,",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkShellNoCC.html",
    "content": "pkgs.mkShellNoCC.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkShellNoCC"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkShellNoCC.",
    "raw_url": "/f/pkgs/mkShellNoCC.html",
    "excerpt": "pkgs.mkShellNoCC.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/unstableGitUpdater.html",
    "content": "pkgs.unstableGitUpdater.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.unstableGitUpdater"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.unstableGitUpdater.",
    "raw_url": "/f/pkgs/unstableGitUpdater.html",
    "excerpt": "pkgs.unstableGitUpdater.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/portableService.html",
    "content": "pkgs.portableService.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.portableService"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.portableService.",
    "raw_url": "/f/pkgs/portableService.html",
    "excerpt": "pkgs.portableService.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchPypi.html",
    "content": "pkgs.fetchPypi. Noogle also knows. Aliases. pkgs.pythonPackages.fetchPypi.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchPypi"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchPypi. Noogle also knows. Aliases. pkgs.pythonPackages.fetchPypi.",
    "raw_url": "/f/pkgs/fetchPypi.html",
    "excerpt": "pkgs.fetchPypi. Noogle also knows. Aliases. pkgs.pythonPackages.fetchPypi.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchNuGet.html",
    "content": "pkgs.fetchNuGet.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchNuGet"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchNuGet.",
    "raw_url": "/f/pkgs/fetchNuGet.html",
    "excerpt": "pkgs.fetchNuGet.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchhg.html",
    "content": "pkgs.fetchhg.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchhg"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchhg.",
    "raw_url": "/f/pkgs/fetchhg.html",
    "excerpt": "pkgs.fetchhg.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/nix-update-script.html",
    "content": "pkgs.nix-update-script.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.nix-update-script"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.nix-update-script.",
    "raw_url": "/f/pkgs/nix-update-script.html",
    "excerpt": "pkgs.nix-update-script.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildUBoot.html",
    "content": "pkgs.buildUBoot.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildUBoot"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildUBoot.",
    "raw_url": "/f/pkgs/buildUBoot.html",
    "excerpt": "pkgs.buildUBoot.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/nuspellWithDicts.html",
    "content": "pkgs.nuspellWithDicts. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.nuspellWithDicts"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.nuspellWithDicts. Edit source.",
    "raw_url": "/f/pkgs/nuspellWithDicts.html",
    "excerpt": "pkgs.nuspellWithDicts. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/linuxPackages_custom.html",
    "content": "pkgs.linuxPackages_custom. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.linuxPackages_custom"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.linuxPackages_custom. Edit source.",
    "raw_url": "/f/pkgs/linuxPackages_custom.html",
    "excerpt": "pkgs.linuxPackages_custom. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeInitrd.html",
    "content": "pkgs.makeInitrd.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeInitrd"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeInitrd.",
    "raw_url": "/f/pkgs/makeInitrd.html",
    "excerpt": "pkgs.makeInitrd.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/ensureNewerSourcesHook.html",
    "content": "pkgs.ensureNewerSourcesHook. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.ensureNewerSourcesHook"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.ensureNewerSourcesHook. Edit source.",
    "raw_url": "/f/pkgs/ensureNewerSourcesHook.html",
    "excerpt": "pkgs.ensureNewerSourcesHook. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/lowPrio.html",
    "content": "pkgs.lowPrio. Decrease the nix-env priority of the package, i.e., other versions/variants of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.lowPrio. lib.meta.lowPrio.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.lowPrio"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.lowPrio. Decrease the nix-env priority of the package, i.e., other versions/variants of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.lowPrio. lib.meta.lowPrio.",
    "raw_url": "/f/pkgs/lowPrio.html",
    "excerpt": "pkgs.lowPrio. Decrease the nix-env priority of the package, i.e., other versions/variants of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.lowPrio. lib.meta.lowPrio.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeFontsCache.html",
    "content": "pkgs.makeFontsCache. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeFontsCache"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeFontsCache. Edit source.",
    "raw_url": "/f/pkgs/makeFontsCache.html",
    "excerpt": "pkgs.makeFontsCache. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/overrideSDK.html",
    "content": "pkgs.overrideSDK. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.overrideSDK"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.overrideSDK. Edit source.",
    "raw_url": "/f/pkgs/overrideSDK.html",
    "excerpt": "pkgs.overrideSDK. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeCBin.html",
    "content": "pkgs.writeCBin. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeCBin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeCBin. Edit source.",
    "raw_url": "/f/pkgs/writeCBin.html",
    "excerpt": "pkgs.writeCBin. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeFontsConf.html",
    "content": "pkgs.makeFontsConf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeFontsConf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeFontsConf. Edit source.",
    "raw_url": "/f/pkgs/makeFontsConf.html",
    "excerpt": "pkgs.makeFontsConf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapThunderbird.html",
    "content": "pkgs.wrapThunderbird.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapThunderbird"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapThunderbird.",
    "raw_url": "/f/pkgs/wrapThunderbird.html",
    "excerpt": "pkgs.wrapThunderbird.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildRubyGem.html",
    "content": "pkgs.buildRubyGem.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildRubyGem"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildRubyGem.",
    "raw_url": "/f/pkgs/buildRubyGem.html",
    "excerpt": "pkgs.buildRubyGem.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchNpmDeps.html",
    "content": "pkgs.fetchNpmDeps.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchNpmDeps"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchNpmDeps.",
    "raw_url": "/f/pkgs/fetchNpmDeps.html",
    "excerpt": "pkgs.fetchNpmDeps.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapFish.html",
    "content": "pkgs.wrapFish.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapFish"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapFish.",
    "raw_url": "/f/pkgs/wrapFish.html",
    "excerpt": "pkgs.wrapFish.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/concatScript.html",
    "content": "pkgs.concatScript. Writes a text file to nix store with and mark it as executable. Example. # Writes contents of files to /nix/store/<store path> concatScript \"my-file\" [ file1 file2 ] Arguments. [name] [files] Edit source.",
    "word_count": 34,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.concatScript"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.concatScript. Writes a text file to nix store with and mark it as executable. Example. # Writes contents of files to /nix/store/&lt;store path&gt; concatScript \"my-file\" [ file1 file2 ] Arguments. [name] [files] Edit source.",
    "raw_url": "/f/pkgs/concatScript.html",
    "excerpt": "pkgs.concatScript. Writes a text file to nix store with and mark it as executable. Example. # Writes contents of files to /nix/store/&lt;store path&gt; concatScript \"my-file\" [ file1 file2 ] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapWeechat.html",
    "content": "pkgs.wrapWeechat.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapWeechat"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapWeechat.",
    "raw_url": "/f/pkgs/wrapWeechat.html",
    "excerpt": "pkgs.wrapWeechat.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/traceDrvLicenses.html",
    "content": "pkgs.traceDrvLicenses. Use the trace output to report all processed derivations with their license name. Arguments. [stdenv] Edit source.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.traceDrvLicenses"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.traceDrvLicenses. Use the trace output to report all processed derivations with their license name. Arguments. [stdenv] Edit source.",
    "raw_url": "/f/pkgs/traceDrvLicenses.html",
    "excerpt": "pkgs.traceDrvLicenses. Use the trace output to report all processed derivations with their license name. Arguments. [stdenv] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/runCommandCC.html",
    "content": "pkgs.runCommandCC. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.runCommandCC"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.runCommandCC. Edit source.",
    "raw_url": "/f/pkgs/runCommandCC.html",
    "excerpt": "pkgs.runCommandCC. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/nixos.html",
    "content": "pkgs.nixos. Evaluate a NixOS configuration using this evaluation of Nixpkgs. With this function you can write, for example, a package that depends on a custom virtual machine image. Parameter: A module, path or list of those that represent the configuration of the NixOS system to be constructed. Result: An attribute set containing packages produced by this evaluation of NixOS, such as toplevel, kernel and initialRamdisk. The result can be extended in the modules by defining extra attributes in system.build. Alternatively, you may use the result's config and options attributes to query any option. Example. let myOS = pkgs.nixos ({ lib, pkgs, config, ... }: { config.services.nginx = { enable = true; # ... }; # Use config.system.build to exports relevant parts of a # configuration. The runner attribute should not be # considered a fully general replacement for systemd # functionality. config.system.build.run-nginx = config.systemd.services.nginx.runner; }); in myOS.run-nginx Unlike in plain NixOS, the nixpkgs.config and nixpkgs.system options will be ignored by default. Instead, nixpkgs.pkgs will have the default value of pkgs as it was constructed right after invoking the nixpkgs function (e.g. the value of import <nixpkgs> { overlays = [./my-overlay.nix]; } but not the value of (import <nixpkgs> {} // { extra = ...; }). If you do want to use the config.nixpkgs options, you are probably better off by calling nixos/lib/eval-config.nix directly, even though it is possible to set config.nixpkgs.pkgs. For more information about writing NixOS modules, see https://nixos.org/nixos/manual/index.html#sec-writing-modules Note that you will need to have called Nixpkgs with the system parameter set to the right value for your deployment target. Arguments. [configuration] Edit source.",
    "word_count": 266,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.nixos"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 93
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 262
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.nixos. Evaluate a NixOS configuration using this evaluation of Nixpkgs. With this function you can write, for example, a package that depends on a custom virtual machine image. Parameter: A module, path or list of those that represent the configuration of the NixOS system to be constructed. Result: An attribute set containing packages produced by this evaluation of NixOS, such as toplevel, kernel and initialRamdisk. The result can be extended in the modules by defining extra attributes in system.build. Alternatively, you may use the result's config and options attributes to query any option. Example. let myOS = pkgs.nixos ({ lib, pkgs, config, ... }: { config.services.nginx = { enable = true; # ... }; # Use config.system.build to exports relevant parts of a # configuration. The runner attribute should not be # considered a fully general replacement for systemd # functionality. config.system.build.run-nginx = config.systemd.services.nginx.runner; }); in myOS.run-nginx Unlike in plain NixOS, the nixpkgs.config and nixpkgs.system options will be ignored by default. Instead, nixpkgs.pkgs will have the default value of pkgs as it was constructed right after invoking the nixpkgs function (e.g. the value of import &lt;nixpkgs&gt; { overlays = [./my-overlay.nix]; } but not the value of (import &lt;nixpkgs&gt; {} // { extra = ...; }). If you do want to use the config.nixpkgs options, you are probably better off by calling nixos/lib/eval-config.nix directly, even though it is possible to set config.nixpkgs.pkgs. For more information about writing NixOS modules, see https://nixos.org/nixos/manual/index.html#sec-writing-modules Note that you will need to have called Nixpkgs with the system parameter set to the right value for your deployment target. Arguments. [configuration] Edit source.",
    "raw_url": "/f/pkgs/nixos.html",
    "excerpt": "pkgs.nixos. Evaluate a NixOS configuration using this evaluation of Nixpkgs. With this function you can write, for example, a package that depends on a custom virtual machine image. Parameter: A",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeLinuxHeaders.html",
    "content": "pkgs.makeLinuxHeaders.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeLinuxHeaders"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeLinuxHeaders.",
    "raw_url": "/f/pkgs/makeLinuxHeaders.html",
    "excerpt": "pkgs.makeLinuxHeaders.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/pkgsModule.html",
    "content": "pkgs.pkgsModule. A NixOS/home-manager/arion/... module that sets the pkgs module argument. Arguments. Edit source.",
    "word_count": 13,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.pkgsModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 10
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.pkgsModule. A NixOS/home-manager/arion/... module that sets the pkgs module argument. Arguments. Edit source.",
    "raw_url": "/f/pkgs/pkgsModule.html",
    "excerpt": "pkgs.pkgsModule. A NixOS/home-manager/arion/... module that sets the pkgs module argument. Arguments. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeOverridable.html",
    "content": "pkgs.makeOverridable. makeOverridable takes a function from attribute set to attribute set and injects override attribute which can be used to override arguments of the function. Please refer to documentation on <pkg>.overrideDerivation to learn about overrideDerivation and caveats related to its use. Example. nix-repl> x = {a, b}: { result = a + b; } nix-repl> y = lib.makeOverridable x { a = 1; b = 2; } nix-repl> y { override = «lambda»; overrideDerivation = «lambda»; result = 3; } nix-repl> y.override { a = 10; } { override = «lambda»; overrideDerivation = «lambda»; result = 12; } Type. makeOverridable :: (AttrSet -> a) -> AttrSet -> a Arguments. [f] Edit source. Noogle also knows. Aliases. lib.makeOverridable. lib.customisation.makeOverridable.",
    "word_count": 118,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeOverridable"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 41
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 98
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 108
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeOverridable. makeOverridable takes a function from attribute set to attribute set and injects override attribute which can be used to override arguments of the function. Please refer to documentation on &lt;pkg&gt;.overrideDerivation to learn about overrideDerivation and caveats related to its use. Example. nix-repl&gt; x = {a, b}: { result = a + b; } nix-repl&gt; y = lib.makeOverridable x { a = 1; b = 2; } nix-repl&gt; y { override = «lambda»; overrideDerivation = «lambda»; result = 3; } nix-repl&gt; y.override { a = 10; } { override = «lambda»; overrideDerivation = «lambda»; result = 12; } Type. makeOverridable :: (AttrSet -&gt; a) -&gt; AttrSet -&gt; a Arguments. [f] Edit source. Noogle also knows. Aliases. lib.makeOverridable. lib.customisation.makeOverridable.",
    "raw_url": "/f/pkgs/makeOverridable.html",
    "excerpt": "pkgs.makeOverridable. makeOverridable takes a function from attribute set to attribute set and injects override attribute which can be used to override arguments of the function. Please refer to documentation on",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeModulesClosure.html",
    "content": "pkgs.makeModulesClosure. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeModulesClosure"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeModulesClosure. Edit source.",
    "raw_url": "/f/pkgs/makeModulesClosure.html",
    "excerpt": "pkgs.makeModulesClosure. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildGo119Package.html",
    "content": "pkgs.buildGo119Package.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildGo119Package"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildGo119Package.",
    "raw_url": "/f/pkgs/buildGo119Package.html",
    "excerpt": "pkgs.buildGo119Package.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchDockerLayer.html",
    "content": "pkgs.fetchDockerLayer.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchDockerLayer"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchDockerLayer.",
    "raw_url": "/f/pkgs/fetchDockerLayer.html",
    "excerpt": "pkgs.fetchDockerLayer.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildFHSEnvChroot.html",
    "content": "pkgs.buildFHSEnvChroot.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildFHSEnvChroot"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildFHSEnvChroot.",
    "raw_url": "/f/pkgs/buildFHSEnvChroot.html",
    "excerpt": "pkgs.buildFHSEnvChroot.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildBarebox.html",
    "content": "pkgs.buildBarebox. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildBarebox"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildBarebox. Edit source.",
    "raw_url": "/f/pkgs/buildBarebox.html",
    "excerpt": "pkgs.buildBarebox. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildBowerComponents.html",
    "content": "pkgs.buildBowerComponents.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildBowerComponents"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildBowerComponents.",
    "raw_url": "/f/pkgs/buildBowerComponents.html",
    "excerpt": "pkgs.buildBowerComponents.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/linuxPackagesFor.html",
    "content": "pkgs.linuxPackagesFor. Linux kernel modules are inherently tied to a specific kernel. So rather than provide specific instances of those packages for a specific kernel, we have a function that builds those packages for a specific kernel. This function can then be called for whatever kernel you're using. Arguments. [kernel_] Edit source.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.linuxPackagesFor"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.linuxPackagesFor. Linux kernel modules are inherently tied to a specific kernel. So rather than provide specific instances of those packages for a specific kernel, we have a function that builds those packages for a specific kernel. This function can then be called for whatever kernel you're using. Arguments. [kernel_] Edit source.",
    "raw_url": "/f/pkgs/linuxPackagesFor.html",
    "excerpt": "pkgs.linuxPackagesFor. Linux kernel modules are inherently tied to a specific kernel. So rather than provide specific instances of those packages for a specific kernel, we have a function that builds",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/sourceFromHead.html",
    "content": "pkgs.sourceFromHead.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.sourceFromHead"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.sourceFromHead.",
    "raw_url": "/f/pkgs/sourceFromHead.html",
    "excerpt": "pkgs.sourceFromHead.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/emacsPackagesFor.html",
    "content": "pkgs.emacsPackagesFor. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.emacsPackagesFor"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.emacsPackagesFor. Edit source.",
    "raw_url": "/f/pkgs/emacsPackagesFor.html",
    "excerpt": "pkgs.emacsPackagesFor. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/linuxConfig.html",
    "content": "pkgs.linuxConfig. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.linuxConfig"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.linuxConfig. Edit source.",
    "raw_url": "/f/pkgs/linuxConfig.html",
    "excerpt": "pkgs.linuxConfig. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/callPackage.html",
    "content": "pkgs.callPackage. Noogle also knows. Aliases. pkgs.pythonPackages.callPackage. pkgs.rustPackages.callPackage. pkgs.rustPackages.buildRustPackages.callPackage.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.callPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.callPackage. Noogle also knows. Aliases. pkgs.pythonPackages.callPackage. pkgs.rustPackages.callPackage. pkgs.rustPackages.buildRustPackages.callPackage.",
    "raw_url": "/f/pkgs/callPackage.html",
    "excerpt": "pkgs.callPackage. Noogle also knows. Aliases. pkgs.pythonPackages.callPackage. pkgs.rustPackages.callPackage. pkgs.rustPackages.buildRustPackages.callPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writeScriptBin.html",
    "content": "pkgs.writeScriptBin. Writes a text file to /nix/store//bin/ and marks the file as executable. Example. # Writes my-file to /nix/store/<store path>/bin/my-file and makes executable. writeScriptBin \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writeScriptBin"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 30
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writeScriptBin. Writes a text file to /nix/store//bin/ and marks the file as executable. Example. # Writes my-file to /nix/store/&lt;store path&gt;/bin/my-file and makes executable. writeScriptBin \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source.",
    "raw_url": "/f/pkgs/writeScriptBin.html",
    "excerpt": "pkgs.writeScriptBin. Writes a text file to /nix/store//bin/ and marks the file as executable. Example. # Writes my-file to /nix/store/&lt;store path&gt;/bin/my-file and makes executable. writeScriptBin \"my-file\" '' Contents of File '';",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeHardcodeGsettingsPatch.html",
    "content": "pkgs.makeHardcodeGsettingsPatch.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeHardcodeGsettingsPatch"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeHardcodeGsettingsPatch.",
    "raw_url": "/f/pkgs/makeHardcodeGsettingsPatch.html",
    "excerpt": "pkgs.makeHardcodeGsettingsPatch.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildFHSEnvBubblewrap.html",
    "content": "pkgs.buildFHSEnvBubblewrap.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildFHSEnvBubblewrap"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildFHSEnvBubblewrap.",
    "raw_url": "/f/pkgs/buildFHSEnvBubblewrap.html",
    "excerpt": "pkgs.buildFHSEnvBubblewrap.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkYarnModules.html",
    "content": "pkgs.mkYarnModules. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkYarnModules"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkYarnModules. Edit source.",
    "raw_url": "/f/pkgs/mkYarnModules.html",
    "excerpt": "pkgs.mkYarnModules. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/linkFarm.html",
    "content": "pkgs.linkFarm. Quickly create a set of symlinks to derivations. This creates a simple derivation with symlinks to all inputs. entries can be a list of attribute sets like [ { name = \"name\" ; path = \"/nix/store/...\"; } ] or an attribute set name -> path like: { name = \"/nix/store/...\"; other = \"/nix/store/...\"; } Example. # Symlinks hello and stack paths in store to current $out/hello-test and # $out/foobar. linkFarm \"myexample\" [ { name = \"hello-test\"; path = pkgs.hello; } { name = \"foobar\"; path = pkgs.stack; } ] This creates a derivation with a directory structure like the following: /nix/store/qc5728m4sa344mbks99r3q05mymwm4rw-myexample |-- foobar -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1 `-- hello-test -> /nix/store/qy93dp4a3rqyn2mz63fbxjg228hffwyw-hello-2.10 See the note on symlinkJoin for the difference between linkFarm and symlinkJoin. Arguments. [name] [entries] Edit source.",
    "word_count": 127,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.linkFarm"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 55
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 122
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.linkFarm. Quickly create a set of symlinks to derivations. This creates a simple derivation with symlinks to all inputs. entries can be a list of attribute sets like [ { name = \"name\" ; path = \"/nix/store/...\"; } ] or an attribute set name -&gt; path like: { name = \"/nix/store/...\"; other = \"/nix/store/...\"; } Example. # Symlinks hello and stack paths in store to current $out/hello-test and # $out/foobar. linkFarm \"myexample\" [ { name = \"hello-test\"; path = pkgs.hello; } { name = \"foobar\"; path = pkgs.stack; } ] This creates a derivation with a directory structure like the following: /nix/store/qc5728m4sa344mbks99r3q05mymwm4rw-myexample |-- foobar -&gt; /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1 `-- hello-test -&gt; /nix/store/qy93dp4a3rqyn2mz63fbxjg228hffwyw-hello-2.10 See the note on symlinkJoin for the difference between linkFarm and symlinkJoin. Arguments. [name] [entries] Edit source.",
    "raw_url": "/f/pkgs/linkFarm.html",
    "excerpt": "pkgs.linkFarm. Quickly create a set of symlinks to derivations. This creates a simple derivation with symlinks to all inputs. entries can be a list of attribute sets like [ {",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/makeDBusConf.html",
    "content": "pkgs.makeDBusConf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.makeDBusConf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.makeDBusConf. Edit source.",
    "raw_url": "/f/pkgs/makeDBusConf.html",
    "excerpt": "pkgs.makeDBusConf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/addAttrsToDerivation.html",
    "content": "pkgs.addAttrsToDerivation. Modify a stdenv so that the specified attributes are added to every derivation returned by its mkDerivation function. Example. stdenvNoOptimise = addAttrsToDerivation { env.NIX_CFLAGS_COMPILE = \"-O0\"; } stdenv; Arguments. [extraAttrs] [stdenv] Edit source.",
    "word_count": 34,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.addAttrsToDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.addAttrsToDerivation. Modify a stdenv so that the specified attributes are added to every derivation returned by its mkDerivation function. Example. stdenvNoOptimise = addAttrsToDerivation { env.NIX_CFLAGS_COMPILE = \"-O0\"; } stdenv; Arguments. [extraAttrs] [stdenv] Edit source.",
    "raw_url": "/f/pkgs/addAttrsToDerivation.html",
    "excerpt": "pkgs.addAttrsToDerivation. Modify a stdenv so that the specified attributes are added to every derivation returned by its mkDerivation function. Example. stdenvNoOptimise = addAttrsToDerivation { env.NIX_CFLAGS_COMPILE = \"-O0\"; } stdenv; Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchYarnDeps.html",
    "content": "pkgs.fetchYarnDeps.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchYarnDeps"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchYarnDeps.",
    "raw_url": "/f/pkgs/fetchYarnDeps.html",
    "excerpt": "pkgs.fetchYarnDeps.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchcvs.html",
    "content": "pkgs.fetchcvs.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchcvs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchcvs.",
    "raw_url": "/f/pkgs/fetchcvs.html",
    "excerpt": "pkgs.fetchcvs.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/httpTwoLevelsUpdater.html",
    "content": "pkgs.httpTwoLevelsUpdater.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.httpTwoLevelsUpdater"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.httpTwoLevelsUpdater.",
    "raw_url": "/f/pkgs/httpTwoLevelsUpdater.html",
    "excerpt": "pkgs.httpTwoLevelsUpdater.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildFHSUserEnvChroot.html",
    "content": "pkgs.buildFHSUserEnvChroot.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildFHSUserEnvChroot"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildFHSUserEnvChroot.",
    "raw_url": "/f/pkgs/buildFHSUserEnvChroot.html",
    "excerpt": "pkgs.buildFHSUserEnvChroot.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/runCommandLocal.html",
    "content": "pkgs.runCommandLocal. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.runCommandLocal"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.runCommandLocal. Edit source.",
    "raw_url": "/f/pkgs/runCommandLocal.html",
    "excerpt": "pkgs.runCommandLocal. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/libcCrossChooser.html",
    "content": "pkgs.libcCrossChooser. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.libcCrossChooser"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.libcCrossChooser. Edit source.",
    "raw_url": "/f/pkgs/libcCrossChooser.html",
    "excerpt": "pkgs.libcCrossChooser. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dhallDirectoryToNix.html",
    "content": "pkgs.dhallDirectoryToNix.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dhallDirectoryToNix"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dhallDirectoryToNix.",
    "raw_url": "/f/pkgs/dhallDirectoryToNix.html",
    "excerpt": "pkgs.dhallDirectoryToNix.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeDashBin.html",
    "content": "pkgs.writers.writeDashBin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeDashBin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeDashBin.",
    "raw_url": "/f/pkgs/writers/writeDashBin.html",
    "excerpt": "pkgs.writers.writeDashBin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeDash.html",
    "content": "pkgs.writers.writeDash.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeDash"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeDash.",
    "raw_url": "/f/pkgs/writers/writeDash.html",
    "excerpt": "pkgs.writers.writeDash.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeBash.html",
    "content": "pkgs.writers.writeBash.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeBash"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeBash.",
    "raw_url": "/f/pkgs/writers/writeBash.html",
    "excerpt": "pkgs.writers.writeBash.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeRust.html",
    "content": "pkgs.writers.writeRust.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeRust"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeRust.",
    "raw_url": "/f/pkgs/writers/writeRust.html",
    "excerpt": "pkgs.writers.writeRust.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeJSON.html",
    "content": "pkgs.writers.writeJSON.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeJSON"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeJSON.",
    "raw_url": "/f/pkgs/writers/writeJSON.html",
    "excerpt": "pkgs.writers.writeJSON.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writePyPy3.html",
    "content": "pkgs.writers.writePyPy3.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writePyPy3"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writePyPy3.",
    "raw_url": "/f/pkgs/writers/writePyPy3.html",
    "excerpt": "pkgs.writers.writePyPy3.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writePython3Bin.html",
    "content": "pkgs.writers.writePython3Bin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writePython3Bin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writePython3Bin.",
    "raw_url": "/f/pkgs/writers/writePython3Bin.html",
    "excerpt": "pkgs.writers.writePython3Bin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writePerl.html",
    "content": "pkgs.writers.writePerl.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writePerl"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writePerl.",
    "raw_url": "/f/pkgs/writers/writePerl.html",
    "excerpt": "pkgs.writers.writePerl.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeHaskellBin.html",
    "content": "pkgs.writers.writeHaskellBin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeHaskellBin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeHaskellBin.",
    "raw_url": "/f/pkgs/writers/writeHaskellBin.html",
    "excerpt": "pkgs.writers.writeHaskellBin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writePerlBin.html",
    "content": "pkgs.writers.writePerlBin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writePerlBin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writePerlBin.",
    "raw_url": "/f/pkgs/writers/writePerlBin.html",
    "excerpt": "pkgs.writers.writePerlBin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeBashBin.html",
    "content": "pkgs.writers.writeBashBin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeBashBin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeBashBin.",
    "raw_url": "/f/pkgs/writers/writeBashBin.html",
    "excerpt": "pkgs.writers.writeBashBin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writePyPy3Bin.html",
    "content": "pkgs.writers.writePyPy3Bin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writePyPy3Bin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writePyPy3Bin.",
    "raw_url": "/f/pkgs/writers/writePyPy3Bin.html",
    "excerpt": "pkgs.writers.writePyPy3Bin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/makePythonWriter.html",
    "content": "pkgs.writers.makePythonWriter.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.makePythonWriter"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.makePythonWriter.",
    "raw_url": "/f/pkgs/writers/makePythonWriter.html",
    "excerpt": "pkgs.writers.makePythonWriter.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/makeFSharpWriter.html",
    "content": "pkgs.writers.makeFSharpWriter.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.makeFSharpWriter"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.makeFSharpWriter.",
    "raw_url": "/f/pkgs/writers/makeFSharpWriter.html",
    "excerpt": "pkgs.writers.makeFSharpWriter.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeYAML.html",
    "content": "pkgs.writers.writeYAML.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeYAML"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeYAML.",
    "raw_url": "/f/pkgs/writers/writeYAML.html",
    "excerpt": "pkgs.writers.writeYAML.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/override.html",
    "content": "pkgs.writers.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.override"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override.",
    "raw_url": "/f/pkgs/writers/override.html",
    "excerpt": "pkgs.writers.override. Noogle also knows. Aliases. pkgs.dockerTools.override. pkgs.pythonPackages.override. pkgs.rustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.rustPlatform.importCargoLock.override. pkgs.rustPackages.buildRustPackages.rustPlatform.buildRustPackage.override. pkgs.rustPackages.buildRustPackages.rustPlatform.fetchCargoTarball.override. pkgs.rustPackages.buildRustPackages.rustPlatform.importCargoLock.override. pkgs.stdenv.override.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writePython3.html",
    "content": "pkgs.writers.writePython3.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writePython3"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writePython3.",
    "raw_url": "/f/pkgs/writers/writePython3.html",
    "excerpt": "pkgs.writers.writePython3.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeHaskell.html",
    "content": "pkgs.writers.writeHaskell.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeHaskell"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeHaskell.",
    "raw_url": "/f/pkgs/writers/writeHaskell.html",
    "excerpt": "pkgs.writers.writeHaskell.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writePyPy2Bin.html",
    "content": "pkgs.writers.writePyPy2Bin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writePyPy2Bin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writePyPy2Bin.",
    "raw_url": "/f/pkgs/writers/writePyPy2Bin.html",
    "excerpt": "pkgs.writers.writePyPy2Bin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeFish.html",
    "content": "pkgs.writers.writeFish.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeFish"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeFish.",
    "raw_url": "/f/pkgs/writers/writeFish.html",
    "excerpt": "pkgs.writers.writeFish.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeNginxConfig.html",
    "content": "pkgs.writers.writeNginxConfig.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeNginxConfig"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeNginxConfig.",
    "raw_url": "/f/pkgs/writers/writeNginxConfig.html",
    "excerpt": "pkgs.writers.writeNginxConfig.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeText.html",
    "content": "pkgs.writers.writeText. Writes a text file to nix store with no optional parameters available. Example. # Writes contents of file to /nix/store/<store path> writeText \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source. Noogle also knows. Aliases. pkgs.writeText.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeText"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeText. Writes a text file to nix store with no optional parameters available. Example. # Writes contents of file to /nix/store/&lt;store path&gt; writeText \"my-file\" '' Contents of File ''; Arguments. [name] [text] Edit source. Noogle also knows. Aliases. pkgs.writeText.",
    "raw_url": "/f/pkgs/writers/writeText.html",
    "excerpt": "pkgs.writers.writeText. Writes a text file to nix store with no optional parameters available. Example. # Writes contents of file to /nix/store/&lt;store path&gt; writeText \"my-file\" '' Contents of File ''; Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeFSharp.html",
    "content": "pkgs.writers.writeFSharp.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeFSharp"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeFSharp.",
    "raw_url": "/f/pkgs/writers/writeFSharp.html",
    "excerpt": "pkgs.writers.writeFSharp.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/makeDataWriter.html",
    "content": "pkgs.writers.makeDataWriter.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.makeDataWriter"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.makeDataWriter.",
    "raw_url": "/f/pkgs/writers/makeDataWriter.html",
    "excerpt": "pkgs.writers.makeDataWriter.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/makeBinWriter.html",
    "content": "pkgs.writers.makeBinWriter.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.makeBinWriter"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.makeBinWriter.",
    "raw_url": "/f/pkgs/writers/makeBinWriter.html",
    "excerpt": "pkgs.writers.makeBinWriter.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/overrideDerivation.html",
    "content": "pkgs.writers.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -> ( Derivation -> AttrSet ) -> Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. pkgs.dockerTools.overrideDerivation. lib.overrideDerivation. lib.customisation.overrideDerivation. pkgs.pythonPackages.overrideDerivation. pkgs.stdenv.overrideDerivation.",
    "word_count": 208,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.overrideDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 157
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 182
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 194
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -&gt; ( Derivation -&gt; AttrSet ) -&gt; Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. pkgs.dockerTools.overrideDerivation. lib.overrideDerivation. lib.customisation.overrideDerivation. pkgs.pythonPackages.overrideDerivation. pkgs.stdenv.overrideDerivation.",
    "raw_url": "/f/pkgs/writers/overrideDerivation.html",
    "excerpt": "pkgs.writers.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeTOML.html",
    "content": "pkgs.writers.writeTOML.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeTOML"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeTOML.",
    "raw_url": "/f/pkgs/writers/writeTOML.html",
    "excerpt": "pkgs.writers.writeTOML.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writePyPy2.html",
    "content": "pkgs.writers.writePyPy2.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writePyPy2"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writePyPy2.",
    "raw_url": "/f/pkgs/writers/writePyPy2.html",
    "excerpt": "pkgs.writers.writePyPy2.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeRustBin.html",
    "content": "pkgs.writers.writeRustBin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeRustBin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeRustBin.",
    "raw_url": "/f/pkgs/writers/writeRustBin.html",
    "excerpt": "pkgs.writers.writeRustBin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeJSBin.html",
    "content": "pkgs.writers.writeJSBin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeJSBin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeJSBin.",
    "raw_url": "/f/pkgs/writers/writeJSBin.html",
    "excerpt": "pkgs.writers.writeJSBin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeJS.html",
    "content": "pkgs.writers.writeJS.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeJS"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeJS.",
    "raw_url": "/f/pkgs/writers/writeJS.html",
    "excerpt": "pkgs.writers.writeJS.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/makeScriptWriter.html",
    "content": "pkgs.writers.makeScriptWriter.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.makeScriptWriter"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.makeScriptWriter.",
    "raw_url": "/f/pkgs/writers/makeScriptWriter.html",
    "excerpt": "pkgs.writers.makeScriptWriter.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeFishBin.html",
    "content": "pkgs.writers.writeFishBin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeFishBin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeFishBin.",
    "raw_url": "/f/pkgs/writers/writeFishBin.html",
    "excerpt": "pkgs.writers.writeFishBin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/writers/writeFSharpBin.html",
    "content": "pkgs.writers.writeFSharpBin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.writers.writeFSharpBin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.writers.writeFSharpBin.",
    "raw_url": "/f/pkgs/writers/writeFSharpBin.html",
    "excerpt": "pkgs.writers.writeFSharpBin.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchFromGitea.html",
    "content": "pkgs.fetchFromGitea.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchFromGitea"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchFromGitea.",
    "raw_url": "/f/pkgs/fetchFromGitea.html",
    "excerpt": "pkgs.fetchFromGitea.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/nixosOptionsDoc.html",
    "content": "pkgs.nixosOptionsDoc. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.nixosOptionsDoc"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.nixosOptionsDoc. Edit source.",
    "raw_url": "/f/pkgs/nixosOptionsDoc.html",
    "excerpt": "pkgs.nixosOptionsDoc. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/wrapOBS.html",
    "content": "pkgs.wrapOBS.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.wrapOBS"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.wrapOBS.",
    "raw_url": "/f/pkgs/wrapOBS.html",
    "excerpt": "pkgs.wrapOBS.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkNugetSource.html",
    "content": "pkgs.mkNugetSource.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkNugetSource"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkNugetSource.",
    "raw_url": "/f/pkgs/mkNugetSource.html",
    "excerpt": "pkgs.mkNugetSource.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchbower.html",
    "content": "pkgs.fetchbower.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchbower"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchbower.",
    "raw_url": "/f/pkgs/fetchbower.html",
    "excerpt": "pkgs.fetchbower.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/mkSaneConfig.html",
    "content": "pkgs.mkSaneConfig.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.mkSaneConfig"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.mkSaneConfig.",
    "raw_url": "/f/pkgs/mkSaneConfig.html",
    "excerpt": "pkgs.mkSaneConfig.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/vscode-fhsWithPackages.html",
    "content": "pkgs.vscode-fhsWithPackages. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.vscode-fhsWithPackages"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.vscode-fhsWithPackages. Edit source.",
    "raw_url": "/f/pkgs/vscode-fhsWithPackages.html",
    "excerpt": "pkgs.vscode-fhsWithPackages. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/copyPathsToStore.html",
    "content": "pkgs.copyPathsToStore. Copy a list of paths to the Nix store. Edit source.",
    "word_count": 12,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.copyPathsToStore"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.copyPathsToStore. Copy a list of paths to the Nix store. Edit source.",
    "raw_url": "/f/pkgs/copyPathsToStore.html",
    "excerpt": "pkgs.copyPathsToStore. Copy a list of paths to the Nix store. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchfossil.html",
    "content": "pkgs.fetchfossil.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchfossil"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchfossil.",
    "raw_url": "/f/pkgs/fetchfossil.html",
    "excerpt": "pkgs.fetchfossil.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchFromGitLab.html",
    "content": "pkgs.fetchFromGitLab.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchFromGitLab"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchFromGitLab.",
    "raw_url": "/f/pkgs/fetchFromGitLab.html",
    "excerpt": "pkgs.fetchFromGitLab.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/symlinkJoin.html",
    "content": "pkgs.symlinkJoin. Create a forest of symlinks to the files in `paths'. This creates a single derivation that replicates the directory structure of all the input paths. BEWARE: it may not \"work right\" when the passed paths contain symlinks to directories. Example. # adds symlinks of hello to current build. symlinkJoin { name = \"myhello\"; paths = [ pkgs.hello ]; } # adds symlinks of hello and stack to current build and prints \"links added\" symlinkJoin { name = \"myexample\"; paths = [ pkgs.hello pkgs.stack ]; postBuild = \"echo links added\"; } This creates a derivation with a directory structure like the following: /nix/store/sglsr5g079a5235hy29da3mq3hv8sjmm-myexample |-- bin | |-- hello -> /nix/store/qy93dp4a3rqyn2mz63fbxjg228hffwyw-hello-2.10/bin/hello | `-- stack -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/bin/stack `-- share |-- bash-completion | `-- completions | `-- stack -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/share/bash-completion/completions/stack |-- fish | `-- vendor_completions.d | `-- stack.fish -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/share/fish/vendor_completions.d/stack.fish ... symlinkJoin and linkFarm are similar functions, but they output derivations with different structure. symlinkJoin is used to create a derivation with a familiar directory structure (top-level bin/, share/, etc), but with all actual files being symlinks to the files in the input derivations. symlinkJoin is used many places in nixpkgs to create a single derivation that appears to contain binaries, libraries, documentation, etc from multiple input derivations. linkFarm is instead used to create a simple derivation with symlinks to other derivations. A derivation created with linkFarm is often used in CI as a easy way to build multiple derivations at once. Arguments. Edit source.",
    "word_count": 242,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.symlinkJoin"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 40
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 239
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.symlinkJoin. Create a forest of symlinks to the files in `paths'. This creates a single derivation that replicates the directory structure of all the input paths. BEWARE: it may not \"work right\" when the passed paths contain symlinks to directories. Example. # adds symlinks of hello to current build. symlinkJoin { name = \"myhello\"; paths = [ pkgs.hello ]; } # adds symlinks of hello and stack to current build and prints \"links added\" symlinkJoin { name = \"myexample\"; paths = [ pkgs.hello pkgs.stack ]; postBuild = \"echo links added\"; } This creates a derivation with a directory structure like the following: /nix/store/sglsr5g079a5235hy29da3mq3hv8sjmm-myexample |-- bin | |-- hello -&gt; /nix/store/qy93dp4a3rqyn2mz63fbxjg228hffwyw-hello-2.10/bin/hello | `-- stack -&gt; /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/bin/stack `-- share |-- bash-completion | `-- completions | `-- stack -&gt; /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/share/bash-completion/completions/stack |-- fish | `-- vendor_completions.d | `-- stack.fish -&gt; /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/share/fish/vendor_completions.d/stack.fish ... symlinkJoin and linkFarm are similar functions, but they output derivations with different structure. symlinkJoin is used to create a derivation with a familiar directory structure (top-level bin/, share/, etc), but with all actual files being symlinks to the files in the input derivations. symlinkJoin is used many places in nixpkgs to create a single derivation that appears to contain binaries, libraries, documentation, etc from multiple input derivations. linkFarm is instead used to create a simple derivation with symlinks to other derivations. A derivation created with linkFarm is often used in CI as a easy way to build multiple derivations at once. Arguments. Edit source.",
    "raw_url": "/f/pkgs/symlinkJoin.html",
    "excerpt": "pkgs.symlinkJoin. Create a forest of symlinks to the files in `paths'. This creates a single derivation that replicates the directory structure of all the input paths. BEWARE: it may not",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/dontRecurseIntoAttrs.html",
    "content": "pkgs.dontRecurseIntoAttrs. Undo the effect of recurseIntoAttrs. Type. dontRecurseIntoAttrs :: AttrSet -> AttrSet Arguments. [attrs] An attribute set to not scan for derivations. Edit source. Noogle also knows. Aliases. lib.dontRecurseIntoAttrs. lib.attrsets.dontRecurseIntoAttrs.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.dontRecurseIntoAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 6
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.dontRecurseIntoAttrs. Undo the effect of recurseIntoAttrs. Type. dontRecurseIntoAttrs :: AttrSet -&gt; AttrSet Arguments. [attrs] An attribute set to not scan for derivations. Edit source. Noogle also knows. Aliases. lib.dontRecurseIntoAttrs. lib.attrsets.dontRecurseIntoAttrs.",
    "raw_url": "/f/pkgs/dontRecurseIntoAttrs.html",
    "excerpt": "pkgs.dontRecurseIntoAttrs. Undo the effect of recurseIntoAttrs. Type. dontRecurseIntoAttrs :: AttrSet -&gt; AttrSet Arguments. [attrs] An attribute set to not scan for derivations. Edit source. Noogle also knows. Aliases. lib.dontRecurseIntoAttrs. lib.attrsets.dontRecurseIntoAttrs.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/fetchDebianPatch.html",
    "content": "pkgs.fetchDebianPatch.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.fetchDebianPatch"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.fetchDebianPatch.",
    "raw_url": "/f/pkgs/fetchDebianPatch.html",
    "excerpt": "pkgs.fetchDebianPatch.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/buildBazelPackage.html",
    "content": "pkgs.buildBazelPackage.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.buildBazelPackage"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.buildBazelPackage.",
    "raw_url": "/f/pkgs/buildBazelPackage.html",
    "excerpt": "pkgs.buildBazelPackage.",
    "sub_results": []
  },
  {
    "url": "/f/pkgs/linuxManualConfig.html",
    "content": "pkgs.linuxManualConfig.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "pkgs.linuxManualConfig"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "pkgs.linuxManualConfig.",
    "raw_url": "/f/pkgs/linuxManualConfig.html",
    "excerpt": "pkgs.linuxManualConfig.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkRenamedOptionModule.html",
    "content": "lib.mkRenamedOptionModule. Return a module that causes a warning to be shown if the specified \"from\" option is defined; the defined value is however forwarded to the \"to\" option. This can be used to rename options while providing backward compatibility. For example, mkRenamedOptionModule [ \"boot\" \"copyKernels\" ] [ \"boot\" \"loader\" \"grub\" \"copyKernels\" ] forwards any definitions of boot.copyKernels to boot.loader.grub.copyKernels while printing a warning. This also copies over the priority from the aliased option to the non-aliased option. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.modules.mkRenamedOptionModule.",
    "word_count": 87,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkRenamedOptionModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 77
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkRenamedOptionModule. Return a module that causes a warning to be shown if the specified \"from\" option is defined; the defined value is however forwarded to the \"to\" option. This can be used to rename options while providing backward compatibility. For example, mkRenamedOptionModule [ \"boot\" \"copyKernels\" ] [ \"boot\" \"loader\" \"grub\" \"copyKernels\" ] forwards any definitions of boot.copyKernels to boot.loader.grub.copyKernels while printing a warning. This also copies over the priority from the aliased option to the non-aliased option. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.modules.mkRenamedOptionModule.",
    "raw_url": "/f/lib/mkRenamedOptionModule.html",
    "excerpt": "lib.mkRenamedOptionModule. Return a module that causes a warning to be shown if the specified \"from\" option is defined; the defined value is however forwarded to the \"to\" option. This can",
    "sub_results": []
  },
  {
    "url": "/f/lib/escape.html",
    "content": "lib.escape. Escape occurrence of the elements of list in string by prefixing it with a backslash. Example. escape [\"(\" \")\"] \"(foo)\" => \"\\\\(foo\\\\)\" Type. escape :: [string] -> string -> string Arguments. [list] Edit source. Noogle also knows. Aliases. lib.strings.escape.",
    "word_count": 40,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.escape"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 31
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.escape. Escape occurrence of the elements of list in string by prefixing it with a backslash. Example. escape [\"(\" \")\"] \"(foo)\" =&gt; \"\\\\(foo\\\\)\" Type. escape :: [string] -&gt; string -&gt; string Arguments. [list] Edit source. Noogle also knows. Aliases. lib.strings.escape.",
    "raw_url": "/f/lib/escape.html",
    "excerpt": "lib.escape. Escape occurrence of the elements of list in string by prefixing it with a backslash. Example. escape [\"(\" \")\"] \"(foo)\" =&gt; \"\\\\(foo\\\\)\" Type. escape :: [string] -&gt; string -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/zipLists.html",
    "content": "lib.zipLists. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. Example. zipLists [ 1 2 ] [ \"a\" \"b\" ] => [ { fst = 1; snd = \"a\"; } { fst = 2; snd = \"b\"; } ] Type. zipLists :: [a] -> [b] -> [{ fst :: a; snd :: b; }] Edit source. Noogle also knows. Aliases. lib.lists.zipLists.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.zipLists"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 21
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.zipLists. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. Example. zipLists [ 1 2 ] [ \"a\" \"b\" ] =&gt; [ { fst = 1; snd = \"a\"; } { fst = 2; snd = \"b\"; } ] Type. zipLists :: [a] -&gt; [b] -&gt; [{ fst :: a; snd :: b; }] Edit source. Noogle also knows. Aliases. lib.lists.zipLists.",
    "raw_url": "/f/lib/zipLists.html",
    "excerpt": "lib.zipLists. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. Example. zipLists [ 1 2 ] [ \"a\" \"b\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/optional.html",
    "content": "lib.optional. Return a singleton list or an empty list, depending on a boolean value. Useful when building lists with optional elements (e.g. ++ optional (system == \"i686-linux\") firefox). Example. optional true \"foo\" => [ \"foo\" ] optional false \"foo\" => [ ] Type. optional :: bool -> a -> [a] Arguments. [cond] [elem] Edit source. Noogle also knows. Aliases. lib.lists.optional.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.optional"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 28
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 42
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.optional. Return a singleton list or an empty list, depending on a boolean value. Useful when building lists with optional elements (e.g. ++ optional (system == \"i686-linux\") firefox). Example. optional true \"foo\" =&gt; [ \"foo\" ] optional false \"foo\" =&gt; [ ] Type. optional :: bool -&gt; a -&gt; [a] Arguments. [cond] [elem] Edit source. Noogle also knows. Aliases. lib.lists.optional.",
    "raw_url": "/f/lib/optional.html",
    "excerpt": "lib.optional. Return a singleton list or an empty list, depending on a boolean value. Useful when building lists with optional elements (e.g. ++ optional (system == \"i686-linux\") firefox). Example. optional",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeOneOption.html",
    "content": "lib.mergeOneOption. Noogle also knows. Aliases. lib.options.mergeOneOption.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeOneOption"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeOneOption. Noogle also knows. Aliases. lib.options.mergeOneOption.",
    "raw_url": "/f/lib/mergeOneOption.html",
    "excerpt": "lib.mergeOneOption. Noogle also knows. Aliases. lib.options.mergeOneOption.",
    "sub_results": []
  },
  {
    "url": "/f/lib/genList.html",
    "content": "lib.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x * x) 5 returns the list [ 0 1 4 9 16 ]. Noogle also knows. Aliases. builtins.genList. lib.lists.genList. lib.strings.genList.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.genList Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x * x) 5 returns the list [ 0 1 4 9 16 ]. Noogle also knows. Aliases. builtins.genList. lib.lists.genList. lib.strings.genList.",
    "raw_url": "/f/lib/genList.html",
    "excerpt": "lib.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x *",
    "sub_results": []
  },
  {
    "url": "/f/lib/foldr.html",
    "content": "lib.foldr. “right fold” a binary function op between successive elements of list with nul as the starting value, i.e., foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul)). Example. concat = foldr (a: b: a + b) \"z\" concat [ \"a\" \"b\" \"c\" ] => \"abcz\" # different types strange = foldr (int: str: toString (int + 1) + str) \"a\" strange [ 1 2 3 4 ] => \"2345a\" Type. foldr :: (a -> b -> b) -> b -> [a] -> b Arguments. [op] [nul] [list] Edit source. Noogle also knows. Aliases. lib.lists.foldr.",
    "word_count": 102,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.foldr"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 35
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 77
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 91
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.foldr. “right fold” a binary function op between successive elements of list with nul as the starting value, i.e., foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul)). Example. concat = foldr (a: b: a + b) \"z\" concat [ \"a\" \"b\" \"c\" ] =&gt; \"abcz\" # different types strange = foldr (int: str: toString (int + 1) + str) \"a\" strange [ 1 2 3 4 ] =&gt; \"2345a\" Type. foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b Arguments. [op] [nul] [list] Edit source. Noogle also knows. Aliases. lib.lists.foldr.",
    "raw_url": "/f/lib/foldr.html",
    "excerpt": "lib.foldr. “right fold” a binary function op between successive elements of list with nul as the starting value, i.e., foldr op nul [x_1 x_2 ... x_n] == op x_1 (op",
    "sub_results": []
  },
  {
    "url": "/f/lib/evalOptionValue.html",
    "content": "lib.evalOptionValue. Merge all the definitions of an option to produce the final config value. Arguments. [loc] [opt] [defs] Edit source. Noogle also knows. Aliases. lib.modules.evalOptionValue.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.evalOptionValue"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.evalOptionValue. Merge all the definitions of an option to produce the final config value. Arguments. [loc] [opt] [defs] Edit source. Noogle also knows. Aliases. lib.modules.evalOptionValue.",
    "raw_url": "/f/lib/evalOptionValue.html",
    "excerpt": "lib.evalOptionValue. Merge all the definitions of an option to produce the final config value. Arguments. [loc] [opt] [defs] Edit source. Noogle also knows. Aliases. lib.modules.evalOptionValue.",
    "sub_results": []
  },
  {
    "url": "/f/lib/allUnique.html",
    "content": "lib.allUnique. Check if list contains only unique elements. O(n^2) complexity. Example. allUnique [ 3 2 3 4 ] => false allUnique [ 3 2 4 1 ] => true Type. allUnique :: [a] -> bool Arguments. [list] Edit source. Noogle also knows. Aliases. lib.lists.allUnique.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.allUnique"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 29
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.allUnique. Check if list contains only unique elements. O(n^2) complexity. Example. allUnique [ 3 2 3 4 ] =&gt; false allUnique [ 3 2 4 1 ] =&gt; true Type. allUnique :: [a] -&gt; bool Arguments. [list] Edit source. Noogle also knows. Aliases. lib.lists.allUnique.",
    "raw_url": "/f/lib/allUnique.html",
    "excerpt": "lib.allUnique. Check if list contains only unique elements. O(n^2) complexity. Example. allUnique [ 3 2 3 4 ] =&gt; false allUnique [ 3 2 4 1 ] =&gt; true Type.",
    "sub_results": []
  },
  {
    "url": "/f/lib/replicate.html",
    "content": "lib.replicate. Return a list with n copies of an element. Example. replicate 3 \"a\" => [ \"a\" \"a\" \"a\" ] replicate 2 true => [ true true ] Type. replicate :: int -> a -> [a] Arguments. [n] [elem] Edit source. Noogle also knows. Aliases. lib.lists.replicate. lib.strings.replicate.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.replicate"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 28
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 36
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.replicate. Return a list with n copies of an element. Example. replicate 3 \"a\" =&gt; [ \"a\" \"a\" \"a\" ] replicate 2 true =&gt; [ true true ] Type. replicate :: int -&gt; a -&gt; [a] Arguments. [n] [elem] Edit source. Noogle also knows. Aliases. lib.lists.replicate. lib.strings.replicate.",
    "raw_url": "/f/lib/replicate.html",
    "excerpt": "lib.replicate. Return a list with n copies of an element. Example. replicate 3 \"a\" =&gt; [ \"a\" \"a\" \"a\" ] replicate 2 true =&gt; [ true true ] Type. replicate",
    "sub_results": []
  },
  {
    "url": "/f/lib/nameFromURL.html",
    "content": "lib.nameFromURL. Extract name with version from URL. Ask for separator which is supposed to start extension. Example. nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"-\" => \"nix\" nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"_\" => \"nix-1.7-x86\" Arguments. [url] [sep] Edit source. Noogle also knows. Aliases. lib.strings.nameFromURL.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.nameFromURL"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.nameFromURL. Extract name with version from URL. Ask for separator which is supposed to start extension. Example. nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"-\" =&gt; \"nix\" nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"_\" =&gt; \"nix-1.7-x86\" Arguments. [url] [sep] Edit source. Noogle also knows. Aliases. lib.strings.nameFromURL.",
    "raw_url": "/f/lib/nameFromURL.html",
    "excerpt": "lib.nameFromURL. Extract name with version from URL. Ask for separator which is supposed to start extension. Example. nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"-\" =&gt; \"nix\" nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"_\" =&gt; \"nix-1.7-x86\" Arguments. [url] [sep]",
    "sub_results": []
  },
  {
    "url": "/f/lib/optionalAttrs.html",
    "content": "lib.optionalAttrs. If cond is true, return the attribute set as, otherwise an empty attribute set. Example. optionalAttrs (true) { my = \"set\"; } => { my = \"set\"; } optionalAttrs (false) { my = \"set\"; } => { } Type. optionalAttrs :: Bool -> AttrSet -> AttrSet Arguments. [cond] Condition under which the as attribute set is returned. [as] The attribute set to return if cond is true. Edit source. Noogle also knows. Aliases. lib.attrsets.optionalAttrs.",
    "word_count": 75,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.optionalAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 39
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.optionalAttrs. If cond is true, return the attribute set as, otherwise an empty attribute set. Example. optionalAttrs (true) { my = \"set\"; } =&gt; { my = \"set\"; } optionalAttrs (false) { my = \"set\"; } =&gt; { } Type. optionalAttrs :: Bool -&gt; AttrSet -&gt; AttrSet Arguments. [cond] Condition under which the as attribute set is returned. [as] The attribute set to return if cond is true. Edit source. Noogle also knows. Aliases. lib.attrsets.optionalAttrs.",
    "raw_url": "/f/lib/optionalAttrs.html",
    "excerpt": "lib.optionalAttrs. If cond is true, return the attribute set as, otherwise an empty attribute set. Example. optionalAttrs (true) { my = \"set\"; } =&gt; { my = \"set\"; } optionalAttrs",
    "sub_results": []
  },
  {
    "url": "/f/lib/extendDerivation.html",
    "content": "lib.extendDerivation. Add attributes to each output of a derivation without changing the derivation itself and check a given condition when evaluating. Type. extendDerivation :: Bool -> Any -> Derivation -> Derivation Arguments. [condition] [passthru] [drv] Edit source. Noogle also knows. Aliases. lib.customisation.extendDerivation.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.extendDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 31
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.extendDerivation. Add attributes to each output of a derivation without changing the derivation itself and check a given condition when evaluating. Type. extendDerivation :: Bool -&gt; Any -&gt; Derivation -&gt; Derivation Arguments. [condition] [passthru] [drv] Edit source. Noogle also knows. Aliases. lib.customisation.extendDerivation.",
    "raw_url": "/f/lib/extendDerivation.html",
    "excerpt": "lib.extendDerivation. Add attributes to each output of a derivation without changing the derivation itself and check a given condition when evaluating. Type. extendDerivation :: Bool -&gt; Any -&gt; Derivation -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/optionals.html",
    "content": "lib.optionals. Return a list or an empty list, depending on a boolean value. Example. optionals true [ 2 3 ] => [ 2 3 ] optionals false [ 2 3 ] => [ ] Type. optionals :: bool -> [a] -> [a] Arguments. [cond] Condition. [elems] List to return if condition is true. Edit source. Noogle also knows. Aliases. lib.lists.optionals.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.optionals"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.optionals. Return a list or an empty list, depending on a boolean value. Example. optionals true [ 2 3 ] =&gt; [ 2 3 ] optionals false [ 2 3 ] =&gt; [ ] Type. optionals :: bool -&gt; [a] -&gt; [a] Arguments. [cond] Condition. [elems] List to return if condition is true. Edit source. Noogle also knows. Aliases. lib.lists.optionals.",
    "raw_url": "/f/lib/optionals.html",
    "excerpt": "lib.optionals. Return a list or an empty list, depending on a boolean value. Example. optionals true [ 2 3 ] =&gt; [ 2 3 ] optionals false [ 2 3",
    "sub_results": []
  },
  {
    "url": "/f/lib/makeLibraryPath.html",
    "content": "lib.makeLibraryPath. Construct a library search path (such as RPATH) containing the libraries for a set of packages. Example. makeLibraryPath [ \"/usr\" \"/usr/local\" ] => \"/usr/lib:/usr/local/lib\" pkgs = import <nixpkgs> { } makeLibraryPath [ pkgs.openssl pkgs.zlib ] => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r/lib:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/lib\" Edit source. Noogle also knows. Aliases. lib.strings.makeLibraryPath.",
    "word_count": 45,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.makeLibraryPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.makeLibraryPath. Construct a library search path (such as RPATH) containing the libraries for a set of packages. Example. makeLibraryPath [ \"/usr\" \"/usr/local\" ] =&gt; \"/usr/lib:/usr/local/lib\" pkgs = import &lt;nixpkgs&gt; { } makeLibraryPath [ pkgs.openssl pkgs.zlib ] =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r/lib:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/lib\" Edit source. Noogle also knows. Aliases. lib.strings.makeLibraryPath.",
    "raw_url": "/f/lib/makeLibraryPath.html",
    "excerpt": "lib.makeLibraryPath. Construct a library search path (such as RPATH) containing the libraries for a set of packages. Example. makeLibraryPath [ \"/usr\" \"/usr/local\" ] =&gt; \"/usr/lib:/usr/local/lib\" pkgs = import &lt;nixpkgs&gt; {",
    "sub_results": []
  },
  {
    "url": "/f/lib/escapeURL.html",
    "content": "lib.escapeURL. Escape the string so it can be safely placed inside a URL query. Example. escapeURL \"foo/bar baz\" => \"foo%2Fbar%20baz\" Type. escapeURL :: string -> string Edit source. Noogle also knows. Aliases. lib.strings.escapeURL.",
    "word_count": 33,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.escapeURL"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.escapeURL. Escape the string so it can be safely placed inside a URL query. Example. escapeURL \"foo/bar baz\" =&gt; \"foo%2Fbar%20baz\" Type. escapeURL :: string -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.escapeURL.",
    "raw_url": "/f/lib/escapeURL.html",
    "excerpt": "lib.escapeURL. Escape the string so it can be safely placed inside a URL query. Example. escapeURL \"foo/bar baz\" =&gt; \"foo%2Fbar%20baz\" Type. escapeURL :: string -&gt; string Edit source. Noogle also",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkAliasDefinitions.html",
    "content": "lib.mkAliasDefinitions. Noogle also knows. Aliases. lib.modules.mkAliasDefinitions.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkAliasDefinitions"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkAliasDefinitions. Noogle also knows. Aliases. lib.modules.mkAliasDefinitions.",
    "raw_url": "/f/lib/mkAliasDefinitions.html",
    "excerpt": "lib.mkAliasDefinitions. Noogle also knows. Aliases. lib.modules.mkAliasDefinitions.",
    "sub_results": []
  },
  {
    "url": "/f/lib/cmakeOptionType.html",
    "content": "lib.cmakeOptionType. Create a \"-D:=\" string that can be passed to typical CMake invocations. Example. cmakeOptionType \"string\" \"ENGINE\" \"sdl2\" => \"-DENGINE:STRING=sdl2\" Type. cmakeOptionType :: string -> string -> string -> string @param feature The feature to be set @param type The type of the feature to be set, as described in https://cmake.org/cmake/help/latest/command/set.html the possible values (case insensitive) are: BOOL FILEPATH PATH STRING INTERNAL @param value The desired value Arguments. [type] [feature] [value] Edit source. Noogle also knows. Aliases. lib.strings.cmakeOptionType.",
    "word_count": 78,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.cmakeOptionType"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 67
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.cmakeOptionType. Create a \"-D:=\" string that can be passed to typical CMake invocations. Example. cmakeOptionType \"string\" \"ENGINE\" \"sdl2\" =&gt; \"-DENGINE:STRING=sdl2\" Type. cmakeOptionType :: string -&gt; string -&gt; string -&gt; string @param feature The feature to be set @param type The type of the feature to be set, as described in https://cmake.org/cmake/help/latest/command/set.html the possible values (case insensitive) are: BOOL FILEPATH PATH STRING INTERNAL @param value The desired value Arguments. [type] [feature] [value] Edit source. Noogle also knows. Aliases. lib.strings.cmakeOptionType.",
    "raw_url": "/f/lib/cmakeOptionType.html",
    "excerpt": "lib.cmakeOptionType. Create a \"-D:=\" string that can be passed to typical CMake invocations. Example. cmakeOptionType \"string\" \"ENGINE\" \"sdl2\" =&gt; \"-DENGINE:STRING=sdl2\" Type. cmakeOptionType :: string -&gt; string -&gt; string -&gt; string",
    "sub_results": []
  },
  {
    "url": "/f/lib/cleanSourceWith.html",
    "content": "lib.cleanSourceWith. Like builtins.filterSource, except it will compose with itself, allowing you to chain multiple calls together without any intermediate copies being put in the nix store. Example. lib.cleanSourceWith { filter = f; src = lib.cleanSourceWith { filter = g; src = ./.; }; } # Succeeds! builtins.filterSource f (builtins.filterSource g ./.) # Fails! Arguments. Edit source. Noogle also knows. Aliases. lib.sources.cleanSourceWith.",
    "word_count": 61,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.cleanSourceWith"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 53
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.cleanSourceWith. Like builtins.filterSource, except it will compose with itself, allowing you to chain multiple calls together without any intermediate copies being put in the nix store. Example. lib.cleanSourceWith { filter = f; src = lib.cleanSourceWith { filter = g; src = ./.; }; } # Succeeds! builtins.filterSource f (builtins.filterSource g ./.) # Fails! Arguments. Edit source. Noogle also knows. Aliases. lib.sources.cleanSourceWith.",
    "raw_url": "/f/lib/cleanSourceWith.html",
    "excerpt": "lib.cleanSourceWith. Like builtins.filterSource, except it will compose with itself, allowing you to chain multiple calls together without any intermediate copies being put in the nix store. Example. lib.cleanSourceWith { filter",
    "sub_results": []
  },
  {
    "url": "/f/lib/callPackageWith.html",
    "content": "lib.callPackageWith. Call the package function in the file fn with the required arguments automatically. The function is called with the arguments args, but any missing arguments are obtained from autoArgs. This function is intended to be partially parameterised, e.g., callPackage = callPackageWith pkgs; pkgs = { libfoo = callPackage ./foo.nix { }; libbar = callPackage ./bar.nix { }; }; If the libbar function expects an argument named libfoo, it is automatically passed as an argument. Overrides or missing arguments can be supplied in args, e.g. libbar = callPackage ./bar.nix { libfoo = null; enableX11 = true; }; Type. callPackageWith :: AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a Arguments. [autoArgs] [fn] [args] Edit source. Noogle also knows. Aliases. lib.customisation.callPackageWith.",
    "word_count": 122,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.callPackageWith"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 97
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 111
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.callPackageWith. Call the package function in the file fn with the required arguments automatically. The function is called with the arguments args, but any missing arguments are obtained from autoArgs. This function is intended to be partially parameterised, e.g., callPackage = callPackageWith pkgs; pkgs = { libfoo = callPackage ./foo.nix { }; libbar = callPackage ./bar.nix { }; }; If the libbar function expects an argument named libfoo, it is automatically passed as an argument. Overrides or missing arguments can be supplied in args, e.g. libbar = callPackage ./bar.nix { libfoo = null; enableX11 = true; }; Type. callPackageWith :: AttrSet -&gt; ((AttrSet -&gt; a) | Path) -&gt; AttrSet -&gt; a Arguments. [autoArgs] [fn] [args] Edit source. Noogle also knows. Aliases. lib.customisation.callPackageWith.",
    "raw_url": "/f/lib/callPackageWith.html",
    "excerpt": "lib.callPackageWith. Call the package function in the file fn with the required arguments automatically. The function is called with the arguments args, but any missing arguments are obtained from autoArgs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/condConcat.html",
    "content": "lib.condConcat. Edit source. Noogle also knows. Aliases. lib.misc.condConcat.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.condConcat"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.condConcat. Edit source. Noogle also knows. Aliases. lib.misc.condConcat.",
    "raw_url": "/f/lib/condConcat.html",
    "excerpt": "lib.condConcat. Edit source. Noogle also knows. Aliases. lib.misc.condConcat.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrsConcatenateValues.html",
    "content": "lib.mergeAttrsConcatenateValues. Noogle also knows. Aliases. lib.misc.mergeAttrsConcatenateValues.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrsConcatenateValues"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrsConcatenateValues. Noogle also knows. Aliases. lib.misc.mergeAttrsConcatenateValues.",
    "raw_url": "/f/lib/mergeAttrsConcatenateValues.html",
    "excerpt": "lib.mergeAttrsConcatenateValues. Noogle also knows. Aliases. lib.misc.mergeAttrsConcatenateValues.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkPackageOption.html",
    "content": "lib.mkPackageOption. Creates an Option attribute set for an option that specifies the package a module should use for some purpose. The package is specified in the third argument under default as a list of strings representing its attribute path in nixpkgs (or another package set). Because of this, you need to pass nixpkgs itself (usually pkgs in a module; alternatively to nixpkgs itself, another package set) as the first argument. If you pass another package set you should set the pkgsText option. This option is used to display the expression for the package set. It is \"pkgs\" by default. If your expression is complex you should parenthesize it, as the pkgsText argument is usually immediately followed by an attribute lookup (.). The second argument may be either a string or a list of strings. It provides the display name of the package in the description of the generated option (using only the last element if the passed value is a list) and serves as the fallback value for the default argument. To include extra information in the description, pass extraDescription to append arbitrary text to the generated description. You can also pass an example value, either a literal string or an attribute path. The default argument can be omitted if the provided name is an attribute of pkgs (if name is a string) or a valid attribute path in pkgs (if name is a list). You can also set default to just a string in which case it is interpreted as an attribute name (a singleton attribute path, if you will). If you wish to explicitly provide no default, pass null as default. If you want users to be able to set no package, pass nullable = true. In this mode a default = null will not be interpreted as no default and is interpreted literally. Example. mkPackageOption pkgs \"hello\" { } => { ...; default = pkgs.hello; defaultText = literalExpression \"pkgs.hello\"; description = \"The hello package to use.\"; type = package; } mkPackageOption pkgs \"GHC\" { default = [ \"ghc\" ]; example = \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; } => { ...; default = pkgs.ghc; defaultText = literalExpression \"pkgs.ghc\"; description = \"The GHC package to use.\"; example = literalExpression \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; type = package; } mkPackageOption pkgs [ \"python3Packages\" \"pytorch\" ] { extraDescription = \"This is an example and doesn't actually do anything.\"; } => { ...; default = pkgs.python3Packages.pytorch; defaultText = literalExpression \"pkgs.python3Packages.pytorch\"; description = \"The pytorch package to use. This is an example and doesn't actually do anything.\"; type = package; } mkPackageOption pkgs \"nushell\" { nullable = true; } => { ...; default = pkgs.nushell; defaultText = literalExpression \"pkgs.nushell\"; description = \"The nushell package to use.\"; type = nullOr package; } mkPackageOption pkgs \"coreutils\" { default = null; } => { ...; description = \"The coreutils package to use.\"; type = package; } mkPackageOption pkgs \"dbus\" { nullable = true; default = null; } => { ...; default = null; description = \"The dbus package to use.\"; type = nullOr package; } mkPackageOption pkgs.javaPackages \"OpenJFX\" { default = \"openjfx20\"; pkgsText = \"pkgs.javaPackages\"; } => { ...; default = pkgs.javaPackages.openjfx20; defaultText = literalExpression \"pkgs.javaPackages.openjfx20\"; description = \"The OpenJFX package to use.\"; type = package; } Type. mkPackageOption :: pkgs -> (string|[string]) -> { nullable? :: bool, default? :: string|[string], example? :: null|string|[string], extraDescription? :: string, pkgsText? :: string } -> option Arguments. [pkgs] Package set (an instantiation of nixpkgs such as pkgs in modules or another package set). [name] Name for the package, shown in option description. Edit source. Noogle also knows. Aliases. lib.options.mkPackageOption.",
    "word_count": 600,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkPackageOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 306
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 541
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 567
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkPackageOption. Creates an Option attribute set for an option that specifies the package a module should use for some purpose. The package is specified in the third argument under default as a list of strings representing its attribute path in nixpkgs (or another package set). Because of this, you need to pass nixpkgs itself (usually pkgs in a module; alternatively to nixpkgs itself, another package set) as the first argument. If you pass another package set you should set the pkgsText option. This option is used to display the expression for the package set. It is \"pkgs\" by default. If your expression is complex you should parenthesize it, as the pkgsText argument is usually immediately followed by an attribute lookup (.). The second argument may be either a string or a list of strings. It provides the display name of the package in the description of the generated option (using only the last element if the passed value is a list) and serves as the fallback value for the default argument. To include extra information in the description, pass extraDescription to append arbitrary text to the generated description. You can also pass an example value, either a literal string or an attribute path. The default argument can be omitted if the provided name is an attribute of pkgs (if name is a string) or a valid attribute path in pkgs (if name is a list). You can also set default to just a string in which case it is interpreted as an attribute name (a singleton attribute path, if you will). If you wish to explicitly provide no default, pass null as default. If you want users to be able to set no package, pass nullable = true. In this mode a default = null will not be interpreted as no default and is interpreted literally. Example. mkPackageOption pkgs \"hello\" { } =&gt; { ...; default = pkgs.hello; defaultText = literalExpression \"pkgs.hello\"; description = \"The hello package to use.\"; type = package; } mkPackageOption pkgs \"GHC\" { default = [ \"ghc\" ]; example = \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; } =&gt; { ...; default = pkgs.ghc; defaultText = literalExpression \"pkgs.ghc\"; description = \"The GHC package to use.\"; example = literalExpression \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; type = package; } mkPackageOption pkgs [ \"python3Packages\" \"pytorch\" ] { extraDescription = \"This is an example and doesn't actually do anything.\"; } =&gt; { ...; default = pkgs.python3Packages.pytorch; defaultText = literalExpression \"pkgs.python3Packages.pytorch\"; description = \"The pytorch package to use. This is an example and doesn't actually do anything.\"; type = package; } mkPackageOption pkgs \"nushell\" { nullable = true; } =&gt; { ...; default = pkgs.nushell; defaultText = literalExpression \"pkgs.nushell\"; description = \"The nushell package to use.\"; type = nullOr package; } mkPackageOption pkgs \"coreutils\" { default = null; } =&gt; { ...; description = \"The coreutils package to use.\"; type = package; } mkPackageOption pkgs \"dbus\" { nullable = true; default = null; } =&gt; { ...; default = null; description = \"The dbus package to use.\"; type = nullOr package; } mkPackageOption pkgs.javaPackages \"OpenJFX\" { default = \"openjfx20\"; pkgsText = \"pkgs.javaPackages\"; } =&gt; { ...; default = pkgs.javaPackages.openjfx20; defaultText = literalExpression \"pkgs.javaPackages.openjfx20\"; description = \"The OpenJFX package to use.\"; type = package; } Type. mkPackageOption :: pkgs -&gt; (string|[string]) -&gt; { nullable? :: bool, default? :: string|[string], example? :: null|string|[string], extraDescription? :: string, pkgsText? :: string } -&gt; option Arguments. [pkgs] Package set (an instantiation of nixpkgs such as pkgs in modules or another package set). [name] Name for the package, shown in option description. Edit source. Noogle also knows. Aliases. lib.options.mkPackageOption.",
    "raw_url": "/f/lib/mkPackageOption.html",
    "excerpt": "lib.mkPackageOption. Creates an Option attribute set for an option that specifies the package a module should use for some purpose. The package is specified in the third argument under default",
    "sub_results": []
  },
  {
    "url": "/f/lib/getName.html",
    "content": "lib.getName. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the name part from that argument. Example. getName \"youtube-dl-2016.01.01\" => \"youtube-dl\" getName pkgs.youtube-dl => \"youtube-dl\" Arguments. [x] Edit source. Noogle also knows. Aliases. lib.strings.getName.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getName. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the name part from that argument. Example. getName \"youtube-dl-2016.01.01\" =&gt; \"youtube-dl\" getName pkgs.youtube-dl =&gt; \"youtube-dl\" Arguments. [x] Edit source. Noogle also knows. Aliases. lib.strings.getName.",
    "raw_url": "/f/lib/getName.html",
    "excerpt": "lib.getName. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the name part from that argument. Example. getName \"youtube-dl-2016.01.01\" =&gt; \"youtube-dl\" getName pkgs.youtube-dl",
    "sub_results": []
  },
  {
    "url": "/f/lib/testAllTrue.html",
    "content": "lib.testAllTrue. Create a test assuming that list elements are true. Example. { testX = allTrue [ true ]; } Arguments. [expr] Edit source. Noogle also knows. Aliases. lib.debug.testAllTrue.",
    "word_count": 28,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.testAllTrue"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 19
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.testAllTrue. Create a test assuming that list elements are true. Example. { testX = allTrue [ true ]; } Arguments. [expr] Edit source. Noogle also knows. Aliases. lib.debug.testAllTrue.",
    "raw_url": "/f/lib/testAllTrue.html",
    "excerpt": "lib.testAllTrue. Create a test assuming that list elements are true. Example. { testX = allTrue [ true ]; } Arguments. [expr] Edit source. Noogle also knows. Aliases. lib.debug.testAllTrue.",
    "sub_results": []
  },
  {
    "url": "/f/lib/listToAttrs.html",
    "content": "lib.listToAttrs Primop. Takes 1 arguments. e. Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting of a string-valued attribute name specifying the name of the attribute, and an attribute value specifying its value. In case of duplicate occurrences of the same name, the first takes precedence. Example: builtins.listToAttrs [ { name = \"foo\"; value = 123; } { name = \"bar\"; value = 456; } { name = \"bar\"; value = 420; } ] evaluates to. { foo = 123; bar = 456; } Noogle also knows. Aliases. builtins.listToAttrs. lib.attrsets.listToAttrs.",
    "word_count": 105,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.listToAttrs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.listToAttrs Primop. Takes 1 arguments. e. Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting of a string-valued attribute name specifying the name of the attribute, and an attribute value specifying its value. In case of duplicate occurrences of the same name, the first takes precedence. Example: builtins.listToAttrs [ { name = \"foo\"; value = 123; } { name = \"bar\"; value = 456; } { name = \"bar\"; value = 420; } ] evaluates to. { foo = 123; bar = 456; } Noogle also knows. Aliases. builtins.listToAttrs. lib.attrsets.listToAttrs.",
    "raw_url": "/f/lib/listToAttrs.html",
    "excerpt": "lib.listToAttrs Primop. Takes 1 arguments. e. Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting",
    "sub_results": []
  },
  {
    "url": "/f/lib/innerModifySumArgs.html",
    "content": "lib.innerModifySumArgs. Edit source. Noogle also knows. Aliases. lib.misc.innerModifySumArgs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.innerModifySumArgs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.innerModifySumArgs. Edit source. Noogle also knows. Aliases. lib.misc.innerModifySumArgs.",
    "raw_url": "/f/lib/innerModifySumArgs.html",
    "excerpt": "lib.innerModifySumArgs. Edit source. Noogle also knows. Aliases. lib.misc.innerModifySumArgs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkAliasOptionModule.html",
    "content": "lib.mkAliasOptionModule. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.modules.mkAliasOptionModule.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkAliasOptionModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkAliasOptionModule. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.modules.mkAliasOptionModule.",
    "raw_url": "/f/lib/mkAliasOptionModule.html",
    "excerpt": "lib.mkAliasOptionModule. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.modules.mkAliasOptionModule.",
    "sub_results": []
  },
  {
    "url": "/f/lib/converge.html",
    "content": "lib.converge. Return the fixpoint that f converges to when called iteratively, starting with the input x. nix-repl> converge (x: x / 2) 16 0 Type. (a -> a) -> a -> a Arguments. [f] [x] Edit source. Noogle also knows. Aliases. lib.fixedPoints.converge.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.converge"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 24
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.converge. Return the fixpoint that f converges to when called iteratively, starting with the input x. nix-repl&gt; converge (x: x / 2) 16 0 Type. (a -&gt; a) -&gt; a -&gt; a Arguments. [f] [x] Edit source. Noogle also knows. Aliases. lib.fixedPoints.converge.",
    "raw_url": "/f/lib/converge.html",
    "excerpt": "lib.converge. Return the fixpoint that f converges to when called iteratively, starting with the input x. nix-repl&gt; converge (x: x / 2) 16 0 Type. (a -&gt; a) -&gt; a",
    "sub_results": []
  },
  {
    "url": "/f/lib/getMan.html",
    "content": "lib.getMan. Get a package's man output. If the output does not exist, fallback to .out and then to the default. Example. getMan pkgs.openssl => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-man\" Type. getMan :: Derivation -> String Edit source. Noogle also knows. Aliases. lib.attrsets.getMan.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getMan"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getMan. Get a package's man output. If the output does not exist, fallback to .out and then to the default. Example. getMan pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-man\" Type. getMan :: Derivation -&gt; String Edit source. Noogle also knows. Aliases. lib.attrsets.getMan.",
    "raw_url": "/f/lib/getMan.html",
    "excerpt": "lib.getMan. Get a package's man output. If the output does not exist, fallback to .out and then to the default. Example. getMan pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-man\" Type. getMan :: Derivation -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/getLib.html",
    "content": "lib.getLib. Get a package's lib output. If the output does not exist, fallback to .out and then to the default. Example. getLib pkgs.openssl => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-lib\" Type. getLib :: Derivation -> String Edit source. Noogle also knows. Aliases. lib.attrsets.getLib.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getLib"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getLib. Get a package's lib output. If the output does not exist, fallback to .out and then to the default. Example. getLib pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-lib\" Type. getLib :: Derivation -&gt; String Edit source. Noogle also knows. Aliases. lib.attrsets.getLib.",
    "raw_url": "/f/lib/getLib.html",
    "excerpt": "lib.getLib. Get a package's lib output. If the output does not exist, fallback to .out and then to the default. Example. getLib pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-lib\" Type. getLib :: Derivation -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/condConcat.html",
    "content": "lib.misc.condConcat. Edit source. Noogle also knows. Aliases. lib.condConcat.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.condConcat"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.condConcat. Edit source. Noogle also knows. Aliases. lib.condConcat.",
    "raw_url": "/f/lib/misc/condConcat.html",
    "excerpt": "lib.misc.condConcat. Edit source. Noogle also knows. Aliases. lib.condConcat.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrsConcatenateValues.html",
    "content": "lib.misc.mergeAttrsConcatenateValues. Noogle also knows. Aliases. lib.mergeAttrsConcatenateValues.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrsConcatenateValues"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrsConcatenateValues. Noogle also knows. Aliases. lib.mergeAttrsConcatenateValues.",
    "raw_url": "/f/lib/misc/mergeAttrsConcatenateValues.html",
    "excerpt": "lib.misc.mergeAttrsConcatenateValues. Noogle also knows. Aliases. lib.mergeAttrsConcatenateValues.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/innerModifySumArgs.html",
    "content": "lib.misc.innerModifySumArgs. Edit source. Noogle also knows. Aliases. lib.innerModifySumArgs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.innerModifySumArgs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.innerModifySumArgs. Edit source. Noogle also knows. Aliases. lib.innerModifySumArgs.",
    "raw_url": "/f/lib/misc/innerModifySumArgs.html",
    "excerpt": "lib.misc.innerModifySumArgs. Edit source. Noogle also knows. Aliases. lib.innerModifySumArgs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/uniqListExt.html",
    "content": "lib.misc.uniqListExt. Edit source. Noogle also knows. Aliases. lib.uniqListExt.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.uniqListExt"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.uniqListExt. Edit source. Noogle also knows. Aliases. lib.uniqListExt.",
    "raw_url": "/f/lib/misc/uniqListExt.html",
    "excerpt": "lib.misc.uniqListExt. Edit source. Noogle also knows. Aliases. lib.uniqListExt.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/checkReqs.html",
    "content": "lib.misc.checkReqs. Edit source. Noogle also knows. Aliases. lib.checkReqs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.checkReqs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.checkReqs. Edit source. Noogle also knows. Aliases. lib.checkReqs.",
    "raw_url": "/f/lib/misc/checkReqs.html",
    "excerpt": "lib.misc.checkReqs. Edit source. Noogle also knows. Aliases. lib.checkReqs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/defaultMerge.html",
    "content": "lib.misc.defaultMerge. Edit source. Noogle also knows. Aliases. lib.defaultMerge.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.defaultMerge"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.defaultMerge. Edit source. Noogle also knows. Aliases. lib.defaultMerge.",
    "raw_url": "/f/lib/misc/defaultMerge.html",
    "excerpt": "lib.misc.defaultMerge. Edit source. Noogle also knows. Aliases. lib.defaultMerge.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/closePropagation.html",
    "content": "lib.misc.closePropagation. Edit source. Noogle also knows. Aliases. lib.closePropagation.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.closePropagation"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.closePropagation. Edit source. Noogle also knows. Aliases. lib.closePropagation.",
    "raw_url": "/f/lib/misc/closePropagation.html",
    "excerpt": "lib.misc.closePropagation. Edit source. Noogle also knows. Aliases. lib.closePropagation.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/maybeAttrNullable.html",
    "content": "lib.misc.maybeAttrNullable. Edit source. Noogle also knows. Aliases. lib.maybeAttrNullable.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.maybeAttrNullable"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.maybeAttrNullable. Edit source. Noogle also knows. Aliases. lib.maybeAttrNullable.",
    "raw_url": "/f/lib/misc/maybeAttrNullable.html",
    "excerpt": "lib.misc.maybeAttrNullable. Edit source. Noogle also knows. Aliases. lib.maybeAttrNullable.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/closePropagationSlow.html",
    "content": "lib.misc.closePropagationSlow. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.closePropagationSlow"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.closePropagationSlow. Edit source.",
    "raw_url": "/f/lib/misc/closePropagationSlow.html",
    "excerpt": "lib.misc.closePropagationSlow. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/nvs.html",
    "content": "lib.misc.nvs. Edit source. Noogle also knows. Aliases. lib.nvs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.nvs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.nvs. Edit source. Noogle also knows. Aliases. lib.nvs.",
    "raw_url": "/f/lib/misc/nvs.html",
    "excerpt": "lib.misc.nvs. Edit source. Noogle also knows. Aliases. lib.nvs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/lazyGenericClosure.html",
    "content": "lib.misc.lazyGenericClosure. Edit source. Noogle also knows. Aliases. lib.lazyGenericClosure.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.lazyGenericClosure"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.lazyGenericClosure. Edit source. Noogle also knows. Aliases. lib.lazyGenericClosure.",
    "raw_url": "/f/lib/misc/lazyGenericClosure.html",
    "excerpt": "lib.misc.lazyGenericClosure. Edit source. Noogle also knows. Aliases. lib.lazyGenericClosure.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/uniqList.html",
    "content": "lib.misc.uniqList. Edit source. Noogle also knows. Aliases. lib.uniqList.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.uniqList"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.uniqList. Edit source. Noogle also knows. Aliases. lib.uniqList.",
    "raw_url": "/f/lib/misc/uniqList.html",
    "excerpt": "lib.misc.uniqList. Edit source. Noogle also knows. Aliases. lib.uniqList.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/setAttrMerge.html",
    "content": "lib.misc.setAttrMerge. Edit source. Noogle also knows. Aliases. lib.setAttrMerge.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.setAttrMerge"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.setAttrMerge. Edit source. Noogle also knows. Aliases. lib.setAttrMerge.",
    "raw_url": "/f/lib/misc/setAttrMerge.html",
    "excerpt": "lib.misc.setAttrMerge. Edit source. Noogle also knows. Aliases. lib.setAttrMerge.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/setAttr.html",
    "content": "lib.misc.setAttr. Edit source. Noogle also knows. Aliases. lib.setAttr.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.setAttr"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.setAttr. Edit source. Noogle also knows. Aliases. lib.setAttr.",
    "raw_url": "/f/lib/misc/setAttr.html",
    "excerpt": "lib.misc.setAttr. Edit source. Noogle also knows. Aliases. lib.setAttr.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/checkFlag.html",
    "content": "lib.misc.checkFlag. Edit source. Noogle also knows. Aliases. lib.checkFlag.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.checkFlag"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.checkFlag. Edit source. Noogle also knows. Aliases. lib.checkFlag.",
    "raw_url": "/f/lib/misc/checkFlag.html",
    "excerpt": "lib.misc.checkFlag. Edit source. Noogle also knows. Aliases. lib.checkFlag.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrsNoOverride.html",
    "content": "lib.misc.mergeAttrsNoOverride. Edit source. Noogle also knows. Aliases. lib.mergeAttrsNoOverride.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrsNoOverride"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrsNoOverride. Edit source. Noogle also knows. Aliases. lib.mergeAttrsNoOverride.",
    "raw_url": "/f/lib/misc/mergeAttrsNoOverride.html",
    "excerpt": "lib.misc.mergeAttrsNoOverride. Edit source. Noogle also knows. Aliases. lib.mergeAttrsNoOverride.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/ifEnable.html",
    "content": "lib.misc.ifEnable. Edit source. Noogle also knows. Aliases. lib.ifEnable.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.ifEnable"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.ifEnable. Edit source. Noogle also knows. Aliases. lib.ifEnable.",
    "raw_url": "/f/lib/misc/ifEnable.html",
    "excerpt": "lib.misc.ifEnable. Edit source. Noogle also knows. Aliases. lib.ifEnable.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/defaultMergeArg.html",
    "content": "lib.misc.defaultMergeArg. Edit source. Noogle also knows. Aliases. lib.defaultMergeArg.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.defaultMergeArg"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.defaultMergeArg. Edit source. Noogle also knows. Aliases. lib.defaultMergeArg.",
    "raw_url": "/f/lib/misc/defaultMergeArg.html",
    "excerpt": "lib.misc.defaultMergeArg. Edit source. Noogle also knows. Aliases. lib.defaultMergeArg.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/foldArgs.html",
    "content": "lib.misc.foldArgs. Edit source. Noogle also knows. Aliases. lib.foldArgs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.foldArgs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.foldArgs. Edit source. Noogle also knows. Aliases. lib.foldArgs.",
    "raw_url": "/f/lib/misc/foldArgs.html",
    "excerpt": "lib.misc.foldArgs. Edit source. Noogle also knows. Aliases. lib.foldArgs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mapAttrsFlatten.html",
    "content": "lib.misc.mapAttrsFlatten. Edit source. Noogle also knows. Aliases. lib.mapAttrsFlatten.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mapAttrsFlatten"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mapAttrsFlatten. Edit source. Noogle also knows. Aliases. lib.mapAttrsFlatten.",
    "raw_url": "/f/lib/misc/mapAttrsFlatten.html",
    "excerpt": "lib.misc.mapAttrsFlatten. Edit source. Noogle also knows. Aliases. lib.mapAttrsFlatten.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/meta.html",
    "content": "lib.misc.mergeAttrBy.meta. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -> attrs -> attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } => { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.meta.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.meta"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.meta. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } =&gt; { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.meta.",
    "raw_url": "/f/lib/misc/mergeAttrBy/meta.html",
    "excerpt": "lib.misc.mergeAttrBy.meta. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/preConfigure.html",
    "content": "lib.misc.mergeAttrBy.preConfigure. Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.preConfigure.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.preConfigure"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.preConfigure. Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.preConfigure.",
    "raw_url": "/f/lib/misc/mergeAttrBy/preConfigure.html",
    "excerpt": "lib.misc.mergeAttrBy.preConfigure. Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.preConfigure.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/propagatedBuildInputs.html",
    "content": "lib.misc.mergeAttrBy.propagatedBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.propagatedBuildInputs.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.propagatedBuildInputs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.propagatedBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.propagatedBuildInputs.",
    "raw_url": "/f/lib/misc/mergeAttrBy/propagatedBuildInputs.html",
    "excerpt": "lib.misc.mergeAttrBy.propagatedBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/prePhases.html",
    "content": "lib.misc.mergeAttrBy.prePhases. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.prePhases.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.prePhases"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.prePhases. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.prePhases.",
    "raw_url": "/f/lib/misc/mergeAttrBy/prePhases.html",
    "excerpt": "lib.misc.mergeAttrBy.prePhases. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/postInstall.html",
    "content": "lib.misc.mergeAttrBy.postInstall. Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.postInstall.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.postInstall"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.postInstall. Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.postInstall.",
    "raw_url": "/f/lib/misc/mergeAttrBy/postInstall.html",
    "excerpt": "lib.misc.mergeAttrBy.postInstall. Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.postInstall.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/flags.html",
    "content": "lib.misc.mergeAttrBy.flags. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -> attrs -> attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } => { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.flags.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.flags"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.flags. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } =&gt; { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.flags.",
    "raw_url": "/f/lib/misc/mergeAttrBy/flags.html",
    "excerpt": "lib.misc.mergeAttrBy.flags. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/patches.html",
    "content": "lib.misc.mergeAttrBy.patches. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.patches.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.patches"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.patches. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.patches.",
    "raw_url": "/f/lib/misc/mergeAttrBy/patches.html",
    "excerpt": "lib.misc.mergeAttrBy.patches. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/postAll.html",
    "content": "lib.misc.mergeAttrBy.postAll. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.postAll.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.postAll"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.postAll. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.postAll.",
    "raw_url": "/f/lib/misc/mergeAttrBy/postAll.html",
    "excerpt": "lib.misc.mergeAttrBy.postAll. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/buildInputs.html",
    "content": "lib.misc.mergeAttrBy.buildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.buildInputs.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.buildInputs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.buildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.buildInputs.",
    "raw_url": "/f/lib/misc/mergeAttrBy/buildInputs.html",
    "excerpt": "lib.misc.mergeAttrBy.buildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/passthru.html",
    "content": "lib.misc.mergeAttrBy.passthru. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -> attrs -> attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } => { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.passthru.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.passthru"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.passthru. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } =&gt; { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.passthru.",
    "raw_url": "/f/lib/misc/mergeAttrBy/passthru.html",
    "excerpt": "lib.misc.mergeAttrBy.passthru. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/cfg.html",
    "content": "lib.misc.mergeAttrBy.cfg. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -> attrs -> attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } => { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.cfg.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.cfg"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.cfg. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } =&gt; { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.cfg.",
    "raw_url": "/f/lib/misc/mergeAttrBy/cfg.html",
    "excerpt": "lib.misc.mergeAttrBy.cfg. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/nativeBuildInputs.html",
    "content": "lib.misc.mergeAttrBy.nativeBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.nativeBuildInputs.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.nativeBuildInputs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.nativeBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.nativeBuildInputs.",
    "raw_url": "/f/lib/misc/mergeAttrBy/nativeBuildInputs.html",
    "excerpt": "lib.misc.mergeAttrBy.nativeBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrBy/configureFlags.html",
    "content": "lib.misc.mergeAttrBy.configureFlags. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.configureFlags.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrBy.configureFlags"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrBy.configureFlags. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.mergeAttrBy.configureFlags.",
    "raw_url": "/f/lib/misc/mergeAttrBy/configureFlags.html",
    "excerpt": "lib.misc.mergeAttrBy.configureFlags. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrsByFuncDefaultsClean.html",
    "content": "lib.misc.mergeAttrsByFuncDefaultsClean. Edit source. Noogle also knows. Aliases. lib.mergeAttrsByFuncDefaultsClean.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrsByFuncDefaultsClean"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrsByFuncDefaultsClean. Edit source. Noogle also knows. Aliases. lib.mergeAttrsByFuncDefaultsClean.",
    "raw_url": "/f/lib/misc/mergeAttrsByFuncDefaultsClean.html",
    "excerpt": "lib.misc.mergeAttrsByFuncDefaultsClean. Edit source. Noogle also knows. Aliases. lib.mergeAttrsByFuncDefaultsClean.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrByFunc.html",
    "content": "lib.misc.mergeAttrByFunc. Edit source. Noogle also knows. Aliases. lib.mergeAttrByFunc.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrByFunc"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrByFunc. Edit source. Noogle also knows. Aliases. lib.mergeAttrByFunc.",
    "raw_url": "/f/lib/misc/mergeAttrByFunc.html",
    "excerpt": "lib.misc.mergeAttrByFunc. Edit source. Noogle also knows. Aliases. lib.mergeAttrByFunc.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrsByFuncDefaults.html",
    "content": "lib.misc.mergeAttrsByFuncDefaults. Noogle also knows. Aliases. lib.mergeAttrsByFuncDefaults.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrsByFuncDefaults"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrsByFuncDefaults. Noogle also knows. Aliases. lib.mergeAttrsByFuncDefaults.",
    "raw_url": "/f/lib/misc/mergeAttrsByFuncDefaults.html",
    "excerpt": "lib.misc.mergeAttrsByFuncDefaults. Noogle also knows. Aliases. lib.mergeAttrsByFuncDefaults.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/mergeAttrsWithFunc.html",
    "content": "lib.misc.mergeAttrsWithFunc. Edit source. Noogle also knows. Aliases. lib.mergeAttrsWithFunc.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.mergeAttrsWithFunc"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.mergeAttrsWithFunc. Edit source. Noogle also knows. Aliases. lib.mergeAttrsWithFunc.",
    "raw_url": "/f/lib/misc/mergeAttrsWithFunc.html",
    "excerpt": "lib.misc.mergeAttrsWithFunc. Edit source. Noogle also knows. Aliases. lib.mergeAttrsWithFunc.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/nixType.html",
    "content": "lib.misc.nixType. Edit source. Noogle also knows. Aliases. lib.nixType.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.nixType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.nixType. Edit source. Noogle also knows. Aliases. lib.nixType.",
    "raw_url": "/f/lib/misc/nixType.html",
    "excerpt": "lib.misc.nixType. Edit source. Noogle also knows. Aliases. lib.nixType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/maybeAttr.html",
    "content": "lib.misc.maybeAttr. Edit source. Noogle also knows. Aliases. lib.maybeAttr.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.maybeAttr"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.maybeAttr. Edit source. Noogle also knows. Aliases. lib.maybeAttr.",
    "raw_url": "/f/lib/misc/maybeAttr.html",
    "excerpt": "lib.misc.maybeAttr. Edit source. Noogle also knows. Aliases. lib.maybeAttr.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/getValue.html",
    "content": "lib.misc.getValue. Edit source. Noogle also knows. Aliases. lib.getValue.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.getValue"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.getValue. Edit source. Noogle also knows. Aliases. lib.getValue.",
    "raw_url": "/f/lib/misc/getValue.html",
    "excerpt": "lib.misc.getValue. Edit source. Noogle also knows. Aliases. lib.getValue.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/imap.html",
    "content": "lib.misc.imap. deprecated: For historical reasons, imap has an index starting at 1. But for consistency with the rest of the library we want an index starting at zero. Edit source. Noogle also knows. Aliases. lib.imap.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.imap"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.imap. deprecated: For historical reasons, imap has an index starting at 1. But for consistency with the rest of the library we want an index starting at zero. Edit source. Noogle also knows. Aliases. lib.imap.",
    "raw_url": "/f/lib/misc/imap.html",
    "excerpt": "lib.misc.imap. deprecated: For historical reasons, imap has an index starting at 1. But for consistency with the rest of the library we want an index starting at zero. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/maybeEnv.html",
    "content": "lib.misc.maybeEnv. Edit source. Noogle also knows. Aliases. lib.maybeEnv.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.maybeEnv"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.maybeEnv. Edit source. Noogle also knows. Aliases. lib.maybeEnv.",
    "raw_url": "/f/lib/misc/maybeEnv.html",
    "excerpt": "lib.misc.maybeEnv. Edit source. Noogle also knows. Aliases. lib.maybeEnv.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/innerClosePropagation.html",
    "content": "lib.misc.innerClosePropagation. Edit source. Noogle also knows. Aliases. lib.innerClosePropagation.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.innerClosePropagation"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.innerClosePropagation. Edit source. Noogle also knows. Aliases. lib.innerClosePropagation.",
    "raw_url": "/f/lib/misc/innerClosePropagation.html",
    "excerpt": "lib.misc.innerClosePropagation. Edit source. Noogle also knows. Aliases. lib.innerClosePropagation.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/closePropagationFast.html",
    "content": "lib.misc.closePropagationFast. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.closePropagationFast"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.closePropagationFast. Edit source.",
    "raw_url": "/f/lib/misc/closePropagationFast.html",
    "excerpt": "lib.misc.closePropagationFast. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/misc/modifySumArgs.html",
    "content": "lib.misc.modifySumArgs. Edit source. Noogle also knows. Aliases. lib.modifySumArgs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.misc.modifySumArgs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.misc.modifySumArgs. Edit source. Noogle also knows. Aliases. lib.modifySumArgs.",
    "raw_url": "/f/lib/misc/modifySumArgs.html",
    "excerpt": "lib.misc.modifySumArgs. Edit source. Noogle also knows. Aliases. lib.modifySumArgs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/pipe.html",
    "content": "lib.pipe. Pipes a value through a list of functions, left to right. Example. pipe 2 [ (x: x + 2) # 2 + 2 = 4 (x: x * 2) # 4 * 2 = 8 ] => 8 # ideal to do text transformations pipe [ \"a/b\" \"a/c\" ] [ # create the cp command (map (file: ''cp \"${src}/${file}\" $out\\n'')) # concatenate all commands into one string lib.concatStrings # make that string into a nix derivation (pkgs.runCommand \"copy-to-out\" {}) ] => <drv which copies all files to $out> The output type of each function has to be the input type of the next function, and the last function returns the final value. Type. pipe :: a -> [<functions>] -> <return type of last function> Arguments. [val] [functions] Edit source. Noogle also knows. Aliases. lib.trivial.pipe.",
    "word_count": 135,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.pipe"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 113
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 125
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.pipe. Pipes a value through a list of functions, left to right. Example. pipe 2 [ (x: x + 2) # 2 + 2 = 4 (x: x * 2) # 4 * 2 = 8 ] =&gt; 8 # ideal to do text transformations pipe [ \"a/b\" \"a/c\" ] [ # create the cp command (map (file: ''cp \"${src}/${file}\" $out\\n'')) # concatenate all commands into one string lib.concatStrings # make that string into a nix derivation (pkgs.runCommand \"copy-to-out\" {}) ] =&gt; &lt;drv which copies all files to $out&gt; The output type of each function has to be the input type of the next function, and the last function returns the final value. Type. pipe :: a -&gt; [&lt;functions&gt;] -&gt; &lt;return type of last function&gt; Arguments. [val] [functions] Edit source. Noogle also knows. Aliases. lib.trivial.pipe.",
    "raw_url": "/f/lib/pipe.html",
    "excerpt": "lib.pipe. Pipes a value through a list of functions, left to right. Example. pipe 2 [ (x: x + 2) # 2 + 2 = 4 (x: x * 2)",
    "sub_results": []
  },
  {
    "url": "/f/lib/naturalSort.html",
    "content": "lib.naturalSort. Sort list using \"Natural sorting\". Numeric portions of strings are sorted in numeric order. Example. naturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"] => [\"disk8\" \"disk9\" \"disk11\" \"disk100\"] naturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"] => [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"] naturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"] => [ \"v0.0.9\" \"v0.2\" \"v0.15\" ] Arguments. [lst] Edit source. Noogle also knows. Aliases. lib.lists.naturalSort.",
    "word_count": 53,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.naturalSort"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 44
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.naturalSort. Sort list using \"Natural sorting\". Numeric portions of strings are sorted in numeric order. Example. naturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"] =&gt; [\"disk8\" \"disk9\" \"disk11\" \"disk100\"] naturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"] =&gt; [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"] naturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"] =&gt; [ \"v0.0.9\" \"v0.2\" \"v0.15\" ] Arguments. [lst] Edit source. Noogle also knows. Aliases. lib.lists.naturalSort.",
    "raw_url": "/f/lib/naturalSort.html",
    "excerpt": "lib.naturalSort. Sort list using \"Natural sorting\". Numeric portions of strings are sorted in numeric order. Example. naturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"] =&gt; [\"disk8\" \"disk9\" \"disk11\" \"disk100\"] naturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"]",
    "sub_results": []
  },
  {
    "url": "/f/lib/zipAttrs.html",
    "content": "lib.zipAttrs. Merge sets of attributes and combine each attribute value in to a list. Like lib.attrsets.zipAttrsWith with (name: values: values) as the function. Example. zipAttrs [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrs :: [ AttrSet ] -> AttrSet Arguments. [sets] List of attribute sets to zip together. Edit source. Noogle also knows. Aliases. lib.attrsets.zipAttrs.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.zipAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 44
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 52
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.zipAttrs. Merge sets of attributes and combine each attribute value in to a list. Like lib.attrsets.zipAttrsWith with (name: values: values) as the function. Example. zipAttrs [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrs :: [ AttrSet ] -&gt; AttrSet Arguments. [sets] List of attribute sets to zip together. Edit source. Noogle also knows. Aliases. lib.attrsets.zipAttrs.",
    "raw_url": "/f/lib/zipAttrs.html",
    "excerpt": "lib.zipAttrs. Merge sets of attributes and combine each attribute value in to a list. Like lib.attrsets.zipAttrsWith with (name: values: values) as the function. Example. zipAttrs [{a = \"x\";} {a =",
    "sub_results": []
  },
  {
    "url": "/f/lib/intersperse.html",
    "content": "lib.intersperse. Place an element between each element of a list. Example. intersperse \"/\" [\"usr\" \"local\" \"bin\"] => [\"usr\" \"/\" \"local\" \"/\" \"bin\"]. Type. intersperse :: a -> [a] -> [a] Arguments. [separator] Separator to add between elements. [list] Input list. Edit source. Noogle also knows. Aliases. lib.strings.intersperse.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.intersperse"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 30
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.intersperse. Place an element between each element of a list. Example. intersperse \"/\" [\"usr\" \"local\" \"bin\"] =&gt; [\"usr\" \"/\" \"local\" \"/\" \"bin\"]. Type. intersperse :: a -&gt; [a] -&gt; [a] Arguments. [separator] Separator to add between elements. [list] Input list. Edit source. Noogle also knows. Aliases. lib.strings.intersperse.",
    "raw_url": "/f/lib/intersperse.html",
    "excerpt": "lib.intersperse. Place an element between each element of a list. Example. intersperse \"/\" [\"usr\" \"local\" \"bin\"] =&gt; [\"usr\" \"/\" \"local\" \"/\" \"bin\"]. Type. intersperse :: a -&gt; [a] -&gt; [a]",
    "sub_results": []
  },
  {
    "url": "/f/lib/mapAttrs'.html",
    "content": "lib.mapAttrs' (Prime). Like mapAttrs, but allows the name of each attribute to be changed in addition to the value. The applied function should return both the new name and value as a nameValuePair. Example. mapAttrs' (name: value: nameValuePair (\"foo_\" + name) (\"bar-\" + value)) { x = \"a\"; y = \"b\"; } => { foo_x = \"bar-a\"; foo_y = \"bar-b\"; } Type. mapAttrs' :: (String -> Any -> { name :: String; value :: Any; }) -> AttrSet -> AttrSet Arguments. [f] A function, given an attribute's name and value, returns a new nameValuePair. [set] Attribute set to map over. Edit source. Noogle also knows. Aliases. lib.attrsets.mapAttrs'",
    "word_count": 107,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mapAttrs' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 33
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 61
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 80
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mapAttrs' (Prime). Like mapAttrs, but allows the name of each attribute to be changed in addition to the value. The applied function should return both the new name and value as a nameValuePair. Example. mapAttrs' (name: value: nameValuePair (\"foo_\" + name) (\"bar-\" + value)) { x = \"a\"; y = \"b\"; } =&gt; { foo_x = \"bar-a\"; foo_y = \"bar-b\"; } Type. mapAttrs' :: (String -&gt; Any -&gt; { name :: String; value :: Any; }) -&gt; AttrSet -&gt; AttrSet Arguments. [f] A function, given an attribute's name and value, returns a new nameValuePair. [set] Attribute set to map over. Edit source. Noogle also knows. Aliases. lib.attrsets.mapAttrs'",
    "raw_url": "/f/lib/mapAttrs'.html",
    "excerpt": "lib.mapAttrs' (Prime). Like mapAttrs, but allows the name of each attribute to be changed in addition to the value. The applied function should return both the new name and value",
    "sub_results": []
  },
  {
    "url": "/f/lib/hiPrioSet.html",
    "content": "lib.hiPrioSet. Apply hiPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.meta.hiPrioSet.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.hiPrioSet"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.hiPrioSet. Apply hiPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.meta.hiPrioSet.",
    "raw_url": "/f/lib/hiPrioSet.html",
    "excerpt": "lib.hiPrioSet. Apply hiPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.meta.hiPrioSet.",
    "sub_results": []
  },
  {
    "url": "/f/lib/concatLines.html",
    "content": "lib.concatLines. Concatenate a list of strings, adding a newline at the end of each one. Defined as concatMapStrings (s: s + \"\\n\"). Example. concatLines [ \"foo\" \"bar\" ] => \"foo\\nbar\\n\" Type. concatLines :: [string] -> string Edit source. Noogle also knows. Aliases. lib.strings.concatLines.",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concatLines"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 22
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 30
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concatLines. Concatenate a list of strings, adding a newline at the end of each one. Defined as concatMapStrings (s: s + \"\\n\"). Example. concatLines [ \"foo\" \"bar\" ] =&gt; \"foo\\nbar\\n\" Type. concatLines :: [string] -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.concatLines.",
    "raw_url": "/f/lib/concatLines.html",
    "excerpt": "lib.concatLines. Concatenate a list of strings, adding a newline at the end of each one. Defined as concatMapStrings (s: s + \"\\n\"). Example. concatLines [ \"foo\" \"bar\" ] =&gt; \"foo\\nbar\\n\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/makeSearchPathOutput.html",
    "content": "lib.makeSearchPathOutput. Construct a Unix-style search path by appending the given subDir to the specified output of each of the packages. If no output by the given name is found, fallback to .out and then to the default. Example. makeSearchPathOutput \"dev\" \"bin\" [ pkgs.openssl pkgs.zlib ] => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev/bin:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/bin\" Type. string -> string -> [package] -> string Arguments. [output] Package output to use. [subDir] Directory name to append. [pkgs] List of packages. Edit source. Noogle also knows. Aliases. lib.strings.makeSearchPathOutput.",
    "word_count": 77,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.makeSearchPathOutput"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 37
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.makeSearchPathOutput. Construct a Unix-style search path by appending the given subDir to the specified output of each of the packages. If no output by the given name is found, fallback to .out and then to the default. Example. makeSearchPathOutput \"dev\" \"bin\" [ pkgs.openssl pkgs.zlib ] =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev/bin:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/bin\" Type. string -&gt; string -&gt; [package] -&gt; string Arguments. [output] Package output to use. [subDir] Directory name to append. [pkgs] List of packages. Edit source. Noogle also knows. Aliases. lib.strings.makeSearchPathOutput.",
    "raw_url": "/f/lib/makeSearchPathOutput.html",
    "excerpt": "lib.makeSearchPathOutput. Construct a Unix-style search path by appending the given subDir to the specified output of each of the packages. If no output by the given name is found, fallback",
    "sub_results": []
  },
  {
    "url": "/f/lib/uniqListExt.html",
    "content": "lib.uniqListExt. Edit source. Noogle also knows. Aliases. lib.misc.uniqListExt.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.uniqListExt"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.uniqListExt. Edit source. Noogle also knows. Aliases. lib.misc.uniqListExt.",
    "raw_url": "/f/lib/uniqListExt.html",
    "excerpt": "lib.uniqListExt. Edit source. Noogle also knows. Aliases. lib.misc.uniqListExt.",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toJSON.html",
    "content": "lib.generators.toJSON. Generates JSON from an arbitrary (non-function) value. For more information see the documentation of the builtin. Arguments. Edit source.",
    "word_count": 20,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toJSON"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toJSON. Generates JSON from an arbitrary (non-function) value. For more information see the documentation of the builtin. Arguments. Edit source.",
    "raw_url": "/f/lib/generators/toJSON.html",
    "excerpt": "lib.generators.toJSON. Generates JSON from an arbitrary (non-function) value. For more information see the documentation of the builtin. Arguments. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/mkLuaInline.html",
    "content": "lib.generators.mkLuaInline. Mark string as Lua expression to be inlined when processed by toLua. Type. mkLuaInline :: String -> AttrSet Arguments. [expr] Edit source.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.mkLuaInline"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 19
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.mkLuaInline. Mark string as Lua expression to be inlined when processed by toLua. Type. mkLuaInline :: String -&gt; AttrSet Arguments. [expr] Edit source.",
    "raw_url": "/f/lib/generators/mkLuaInline.html",
    "excerpt": "lib.generators.mkLuaInline. Mark string as Lua expression to be inlined when processed by toLua. Type. mkLuaInline :: String -&gt; AttrSet Arguments. [expr] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toGitINI.html",
    "content": "lib.generators.toGitINI. Generate a git-config file from an attrset. *. It has two major differences from the regular INI format: values are indented with tabs. sections can have sub-sections. generators.toGitINI { url.\"ssh://git@github.com/\".insteadOf = \"https://github.com\"; user.name = \"edolstra\"; } *> [url \"ssh://git@github.com/\"] *> insteadOf = \"https://github.com\" *> *> [user] *> name = \"edolstra\" Arguments. [attrs] Edit source.",
    "word_count": 55,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toGitINI"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 51
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toGitINI. Generate a git-config file from an attrset. *. It has two major differences from the regular INI format: values are indented with tabs. sections can have sub-sections. generators.toGitINI { url.\"ssh://git@github.com/\".insteadOf = \"https://github.com\"; user.name = \"edolstra\"; } *&gt; [url \"ssh://git@github.com/\"] *&gt; insteadOf = \"https://github.com\" *&gt; *&gt; [user] *&gt; name = \"edolstra\" Arguments. [attrs] Edit source.",
    "raw_url": "/f/lib/generators/toGitINI.html",
    "excerpt": "lib.generators.toGitINI. Generate a git-config file from an attrset. *. It has two major differences from the regular INI format: values are indented with tabs. sections can have sub-sections. generators.toGitINI {",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toLua.html",
    "content": "lib.generators.toLua. Translate a simple Nix expression to Lua representation with occasional Lua-inlines that can be constructed by mkLuaInline function. Configuration: multiline - by default is true which results in indented block-like view. indent - initial indent. asBindings - by default generate single value, but with this use attrset to set global vars. Attention: Regardless of multiline parameter there is no trailing newline. Example. generators.toLua {} { cmd = [ \"typescript-language-server\" \"--stdio\" ]; settings.workspace.library = mkLuaInline ''vim.api.nvim_get_runtime_file(\"\", true)''; } -> { [\"cmd\"] = { \"typescript-language-server\", \"--stdio\" }, [\"settings\"] = { [\"workspace\"] = { [\"library\"] = (vim.api.nvim_get_runtime_file(\"\", true)) } } } Type. toLua :: AttrSet -> Any -> String Arguments. [v] Edit source.",
    "word_count": 111,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toLua"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 62
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 99
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 107
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toLua. Translate a simple Nix expression to Lua representation with occasional Lua-inlines that can be constructed by mkLuaInline function. Configuration: multiline - by default is true which results in indented block-like view. indent - initial indent. asBindings - by default generate single value, but with this use attrset to set global vars. Attention: Regardless of multiline parameter there is no trailing newline. Example. generators.toLua {} { cmd = [ \"typescript-language-server\" \"--stdio\" ]; settings.workspace.library = mkLuaInline ''vim.api.nvim_get_runtime_file(\"\", true)''; } -&gt; { [\"cmd\"] = { \"typescript-language-server\", \"--stdio\" }, [\"settings\"] = { [\"workspace\"] = { [\"library\"] = (vim.api.nvim_get_runtime_file(\"\", true)) } } } Type. toLua :: AttrSet -&gt; Any -&gt; String Arguments. [v] Edit source.",
    "raw_url": "/f/lib/generators/toLua.html",
    "excerpt": "lib.generators.toLua. Translate a simple Nix expression to Lua representation with occasional Lua-inlines that can be constructed by mkLuaInline function. Configuration: multiline - by default is true which results in indented",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toDconfINI.html",
    "content": "lib.generators.toDconfINI.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toDconfINI"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toDconfINI.",
    "raw_url": "/f/lib/generators/toDconfINI.html",
    "excerpt": "lib.generators.toDconfINI.",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toINI.html",
    "content": "lib.generators.toINI. Generate an INI-style config file from an. attrset of sections to an attrset of key-value pairs. generators.toINI {} { foo = { hi = \"${pkgs.hello}\"; ciao = \"bar\"; }; baz = { \"also, integers\" = 42; }; } *> [baz] *> also, integers=42 *> *> [foo] *> ciao=bar *> hi=/nix/store/y93qql1p5ggfnaqjjqhxcw0vqw95rlz0-hello-2.10 *. The mk* configuration attributes can generically change. the way sections and key-value strings are generated. For more examples see the test cases in ./tests/misc.nix. Arguments. [attrsOfAttrs] Edit source.",
    "word_count": 80,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toINI"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 76
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toINI. Generate an INI-style config file from an. attrset of sections to an attrset of key-value pairs. generators.toINI {} { foo = { hi = \"${pkgs.hello}\"; ciao = \"bar\"; }; baz = { \"also, integers\" = 42; }; } *&gt; [baz] *&gt; also, integers=42 *&gt; *&gt; [foo] *&gt; ciao=bar *&gt; hi=/nix/store/y93qql1p5ggfnaqjjqhxcw0vqw95rlz0-hello-2.10 *. The mk* configuration attributes can generically change. the way sections and key-value strings are generated. For more examples see the test cases in ./tests/misc.nix. Arguments. [attrsOfAttrs] Edit source.",
    "raw_url": "/f/lib/generators/toINI.html",
    "excerpt": "lib.generators.toINI. Generate an INI-style config file from an. attrset of sections to an attrset of key-value pairs. generators.toINI {} { foo = { hi = \"${pkgs.hello}\"; ciao = \"bar\"; };",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toINIWithGlobalSection.html",
    "content": "lib.generators.toINIWithGlobalSection. Generate an INI-style config file from an attrset. specifying the global section (no header), and an. attrset of sections to an attrset of key-value pairs. generators.toINIWithGlobalSection {} { globalSection = { someGlobalKey = \"hi\"; }; sections = { foo = { hi = \"${pkgs.hello}\"; ciao = \"bar\"; }; baz = { \"also, integers\" = 42; }; } *> someGlobalKey=hi *> *> [baz] *> also, integers=42 *> *> [foo] *> ciao=bar *> hi=/nix/store/y93qql1p5ggfnaqjjqhxcw0vqw95rlz0-hello-2.10 *. The mk* configuration attributes can generically change. the way sections and key-value strings are generated. For more examples see the test cases in ./tests/misc.nix. If you don’t need a global section, you can also use. generators.toINI directly, which only takes. the part in sections. Arguments. Edit source.",
    "word_count": 121,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toINIWithGlobalSection"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 118
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toINIWithGlobalSection. Generate an INI-style config file from an attrset. specifying the global section (no header), and an. attrset of sections to an attrset of key-value pairs. generators.toINIWithGlobalSection {} { globalSection = { someGlobalKey = \"hi\"; }; sections = { foo = { hi = \"${pkgs.hello}\"; ciao = \"bar\"; }; baz = { \"also, integers\" = 42; }; } *&gt; someGlobalKey=hi *&gt; *&gt; [baz] *&gt; also, integers=42 *&gt; *&gt; [foo] *&gt; ciao=bar *&gt; hi=/nix/store/y93qql1p5ggfnaqjjqhxcw0vqw95rlz0-hello-2.10 *. The mk* configuration attributes can generically change. the way sections and key-value strings are generated. For more examples see the test cases in ./tests/misc.nix. If you don’t need a global section, you can also use. generators.toINI directly, which only takes. the part in sections. Arguments. Edit source.",
    "raw_url": "/f/lib/generators/toINIWithGlobalSection.html",
    "excerpt": "lib.generators.toINIWithGlobalSection. Generate an INI-style config file from an attrset. specifying the global section (no header), and an. attrset of sections to an attrset of key-value pairs. generators.toINIWithGlobalSection {} { globalSection",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toPretty.html",
    "content": "lib.generators.toPretty. Pretty print a value, akin to builtins.trace. Should probably be a builtin as well. The pretty-printed string should be suitable for rendering default values. in the NixOS manual. In particular, it should be as close to a valid Nix expression. as possible. Arguments. Edit source.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toPretty"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 43
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toPretty. Pretty print a value, akin to builtins.trace. Should probably be a builtin as well. The pretty-printed string should be suitable for rendering default values. in the NixOS manual. In particular, it should be as close to a valid Nix expression. as possible. Arguments. Edit source.",
    "raw_url": "/f/lib/generators/toPretty.html",
    "excerpt": "lib.generators.toPretty. Pretty print a value, akin to builtins.trace. Should probably be a builtin as well. The pretty-printed string should be suitable for rendering default values. in the NixOS manual. In",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toKeyValue.html",
    "content": "lib.generators.toKeyValue. Generate a key-value-style config file from an attrset. *. mkKeyValue is the same as in toINI. Arguments. Edit source.",
    "word_count": 20,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toKeyValue"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toKeyValue. Generate a key-value-style config file from an attrset. *. mkKeyValue is the same as in toINI. Arguments. Edit source.",
    "raw_url": "/f/lib/generators/toKeyValue.html",
    "excerpt": "lib.generators.toKeyValue. Generate a key-value-style config file from an attrset. *. mkKeyValue is the same as in toINI. Arguments. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/mkDconfKeyValue.html",
    "content": "lib.generators.mkDconfKeyValue.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.mkDconfKeyValue"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.mkDconfKeyValue.",
    "raw_url": "/f/lib/generators/mkDconfKeyValue.html",
    "excerpt": "lib.generators.mkDconfKeyValue.",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/withRecursion.html",
    "content": "lib.generators.withRecursion. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.withRecursion"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.withRecursion. Edit source.",
    "raw_url": "/f/lib/generators/withRecursion.html",
    "excerpt": "lib.generators.withRecursion. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toPlist.html",
    "content": "lib.generators.toPlist. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toPlist"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toPlist. Edit source.",
    "raw_url": "/f/lib/generators/toPlist.html",
    "excerpt": "lib.generators.toPlist. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toYAML.html",
    "content": "lib.generators.toYAML. YAML has been a strict superset of JSON since 1.2, so we. use toJSON. Before it only had a few differences referring. to implicit typing rules, so it should work with older. parsers as well. Edit source.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toYAML"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toYAML. YAML has been a strict superset of JSON since 1.2, so we. use toJSON. Before it only had a few differences referring. to implicit typing rules, so it should work with older. parsers as well. Edit source.",
    "raw_url": "/f/lib/generators/toYAML.html",
    "excerpt": "lib.generators.toYAML. YAML has been a strict superset of JSON since 1.2, so we. use toJSON. Before it only had a few differences referring. to implicit typing rules, so it should",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/mkKeyValueDefault.html",
    "content": "lib.generators.mkKeyValueDefault. Generate a line of key k and value v, separated by. character sep. If sep appears in k, it is escaped. Helper for synaxes with different separators. mkValueString specifies how values should be formatted. mkKeyValueDefault {} \":\" \"f:oo\" \"bar\" \"f:oo:bar\" Arguments. [sep] [k] [v] Edit source.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.mkKeyValueDefault"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.mkKeyValueDefault. Generate a line of key k and value v, separated by. character sep. If sep appears in k, it is escaped. Helper for synaxes with different separators. mkValueString specifies how values should be formatted. mkKeyValueDefault {} \":\" \"f:oo\" \"bar\" \"f:oo:bar\" Arguments. [sep] [k] [v] Edit source.",
    "raw_url": "/f/lib/generators/mkKeyValueDefault.html",
    "excerpt": "lib.generators.mkKeyValueDefault. Generate a line of key k and value v, separated by. character sep. If sep appears in k, it is escaped. Helper for synaxes with different separators. mkValueString specifies",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/mkValueStringDefault.html",
    "content": "lib.generators.mkValueStringDefault. Convert a value to a sensible default string representation. The builtin toString function has some strange defaults, suitable for bash scripts but not much else. Arguments. [v] Edit source.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.mkValueStringDefault"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.mkValueStringDefault. Convert a value to a sensible default string representation. The builtin toString function has some strange defaults, suitable for bash scripts but not much else. Arguments. [v] Edit source.",
    "raw_url": "/f/lib/generators/mkValueStringDefault.html",
    "excerpt": "lib.generators.mkValueStringDefault. Convert a value to a sensible default string representation. The builtin toString function has some strange defaults, suitable for bash scripts but not much else. Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/generators/toDhall.html",
    "content": "lib.generators.toDhall. Translate a simple Nix expression to Dhall notation. Note that integers are translated to Integer and never. the Natural type. Arguments. [v] Edit source.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.generators.toDhall"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 21
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.generators.toDhall. Translate a simple Nix expression to Dhall notation. Note that integers are translated to Integer and never. the Natural type. Arguments. [v] Edit source.",
    "raw_url": "/f/lib/generators/toDhall.html",
    "excerpt": "lib.generators.toDhall. Translate a simple Nix expression to Dhall notation. Note that integers are translated to Integer and never. the Natural type. Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/isStringLike.html",
    "content": "lib.isStringLike. Check whether a value can be coerced to a string. The value must be a string, path, or attribute set. String-like values can be used without explicit conversion in string interpolations and in most functions that expect a string. Arguments. [x] Edit source. Noogle also knows. Aliases. lib.strings.isStringLike.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isStringLike"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isStringLike. Check whether a value can be coerced to a string. The value must be a string, path, or attribute set. String-like values can be used without explicit conversion in string interpolations and in most functions that expect a string. Arguments. [x] Edit source. Noogle also knows. Aliases. lib.strings.isStringLike.",
    "raw_url": "/f/lib/isStringLike.html",
    "excerpt": "lib.isStringLike. Check whether a value can be coerced to a string. The value must be a string, path, or attribute set. String-like values can be used without explicit conversion in",
    "sub_results": []
  },
  {
    "url": "/f/lib/toBaseDigits.html",
    "content": "lib.toBaseDigits. toBaseDigits base i converts the positive integer i to a list of its digits in the given base. For example: toBaseDigits 10 123 => [ 1 2 3 ] toBaseDigits 2 6 => [ 1 1 0 ] toBaseDigits 16 250 => [ 15 10 ] Arguments. [base] [i] Edit source. Noogle also knows. Aliases. lib.trivial.toBaseDigits.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toBaseDigits"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toBaseDigits. toBaseDigits base i converts the positive integer i to a list of its digits in the given base. For example: toBaseDigits 10 123 =&gt; [ 1 2 3 ] toBaseDigits 2 6 =&gt; [ 1 1 0 ] toBaseDigits 16 250 =&gt; [ 15 10 ] Arguments. [base] [i] Edit source. Noogle also knows. Aliases. lib.trivial.toBaseDigits.",
    "raw_url": "/f/lib/toBaseDigits.html",
    "excerpt": "lib.toBaseDigits. toBaseDigits base i converts the positive integer i to a list of its digits in the given base. For example: toBaseDigits 10 123 =&gt; [ 1 2 3 ]",
    "sub_results": []
  },
  {
    "url": "/f/lib/mapDerivationAttrset.html",
    "content": "lib.mapDerivationAttrset. Apply a function to each derivation and only to derivations in an attrset. Arguments. [f] [set] Edit source. Noogle also knows. Aliases. lib.meta.mapDerivationAttrset.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mapDerivationAttrset"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mapDerivationAttrset. Apply a function to each derivation and only to derivations in an attrset. Arguments. [f] [set] Edit source. Noogle also knows. Aliases. lib.meta.mapDerivationAttrset.",
    "raw_url": "/f/lib/mapDerivationAttrset.html",
    "excerpt": "lib.mapDerivationAttrset. Apply a function to each derivation and only to derivations in an attrset. Arguments. [f] [set] Edit source. Noogle also knows. Aliases. lib.meta.mapDerivationAttrset.",
    "sub_results": []
  },
  {
    "url": "/f/lib/unifyModuleSyntax.html",
    "content": "lib.unifyModuleSyntax. Massage a module into canonical form, that is, a set consisting of ‘options’, ‘config’ and ‘imports’ attributes. Arguments. [file] [key] [m] Edit source. Noogle also knows. Aliases. lib.modules.unifyModuleSyntax.",
    "word_count": 29,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.unifyModuleSyntax"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 18
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.unifyModuleSyntax. Massage a module into canonical form, that is, a set consisting of ‘options’, ‘config’ and ‘imports’ attributes. Arguments. [file] [key] [m] Edit source. Noogle also knows. Aliases. lib.modules.unifyModuleSyntax.",
    "raw_url": "/f/lib/unifyModuleSyntax.html",
    "excerpt": "lib.unifyModuleSyntax. Massage a module into canonical form, that is, a set consisting of ‘options’, ‘config’ and ‘imports’ attributes. Arguments. [file] [key] [m] Edit source. Noogle also knows. Aliases. lib.modules.unifyModuleSyntax.",
    "sub_results": []
  },
  {
    "url": "/f/lib/appendToName.html",
    "content": "lib.appendToName. Append a suffix to the name of a package (before the version part). Arguments. [suffix] Edit source. Noogle also knows. Aliases. lib.meta.appendToName.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.appendToName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.appendToName. Append a suffix to the name of a package (before the version part). Arguments. [suffix] Edit source. Noogle also knows. Aliases. lib.meta.appendToName.",
    "raw_url": "/f/lib/appendToName.html",
    "excerpt": "lib.appendToName. Append a suffix to the name of a package (before the version part). Arguments. [suffix] Edit source. Noogle also knows. Aliases. lib.meta.appendToName.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mesonOption.html",
    "content": "lib.mesonOption. Create a -D= string that can be passed to typical Meson invocations. Example. mesonOption \"engine\" \"opengl\" => \"-Dengine=opengl\" Type. mesonOption :: string -> string -> string @param feature The feature to be set @param value The desired value Arguments. [feature] [value] Edit source. Noogle also knows. Aliases. lib.strings.mesonOption.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mesonOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mesonOption. Create a -D= string that can be passed to typical Meson invocations. Example. mesonOption \"engine\" \"opengl\" =&gt; \"-Dengine=opengl\" Type. mesonOption :: string -&gt; string -&gt; string @param feature The feature to be set @param value The desired value Arguments. [feature] [value] Edit source. Noogle also knows. Aliases. lib.strings.mesonOption.",
    "raw_url": "/f/lib/mesonOption.html",
    "excerpt": "lib.mesonOption. Create a -D= string that can be passed to typical Meson invocations. Example. mesonOption \"engine\" \"opengl\" =&gt; \"-Dengine=opengl\" Type. mesonOption :: string -&gt; string -&gt; string @param feature The",
    "sub_results": []
  },
  {
    "url": "/f/lib/bitOr.html",
    "content": "lib.bitOr Primop. Takes 2 arguments. e1, e2. bitwise “or” Edit source. Noogle also knows. Aliases. builtins.bitOr. lib.trivial.bitOr.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.bitOr Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.bitOr Primop. Takes 2 arguments. e1, e2. bitwise “or” Edit source. Noogle also knows. Aliases. builtins.bitOr. lib.trivial.bitOr.",
    "raw_url": "/f/lib/bitOr.html",
    "excerpt": "lib.bitOr Primop. Takes 2 arguments. e1, e2. bitwise “or” Edit source. Noogle also knows. Aliases. builtins.bitOr. lib.trivial.bitOr.",
    "sub_results": []
  },
  {
    "url": "/f/lib/checkReqs.html",
    "content": "lib.checkReqs. Edit source. Noogle also knows. Aliases. lib.misc.checkReqs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.checkReqs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.checkReqs. Edit source. Noogle also knows. Aliases. lib.misc.checkReqs.",
    "raw_url": "/f/lib/checkReqs.html",
    "excerpt": "lib.checkReqs. Edit source. Noogle also knows. Aliases. lib.misc.checkReqs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/forEach.html",
    "content": "lib.forEach. Apply the function to each element in the list. Same as map, but arguments flipped. Example. forEach [ 1 2 ] (x: toString x ) => [ \"1\" \"2\" ] Type. forEach :: [a] -> (a -> b) -> [b] Arguments. [xs] [f] Edit source. Noogle also knows. Aliases. lib.lists.forEach.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.forEach"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.forEach. Apply the function to each element in the list. Same as map, but arguments flipped. Example. forEach [ 1 2 ] (x: toString x ) =&gt; [ \"1\" \"2\" ] Type. forEach :: [a] -&gt; (a -&gt; b) -&gt; [b] Arguments. [xs] [f] Edit source. Noogle also knows. Aliases. lib.lists.forEach.",
    "raw_url": "/f/lib/forEach.html",
    "excerpt": "lib.forEach. Apply the function to each element in the list. Same as map, but arguments flipped. Example. forEach [ 1 2 ] (x: toString x ) =&gt; [ \"1\" \"2\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/throwIf.html",
    "content": "lib.throwIf. Like throwIfNot, but negated (throw if the first argument is true). Type. bool -> string -> a -> a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.throwIf.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.throwIf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.throwIf. Like throwIfNot, but negated (throw if the first argument is true). Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.throwIf.",
    "raw_url": "/f/lib/throwIf.html",
    "excerpt": "lib.throwIf. Like throwIfNot, but negated (throw if the first argument is true). Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.throwIf.",
    "sub_results": []
  },
  {
    "url": "/f/lib/evalModules.html",
    "content": "lib.evalModules. See https://nixos.org/manual/nixpkgs/unstable/#module-system-lib-evalModules or file://./../doc/module-system/module-system.chapter.md !!! Please think twice before adding to this argument list! The more that is specified here instead of in the modules themselves the harder it is to transparently move a set of modules to be a submodule of another config (as the proper arguments need to be replicated at each call to evalModules) and the less declarative the module set is. Arguments. Edit source. Noogle also knows. Aliases. lib.modules.evalModules.",
    "word_count": 74,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.evalModules"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 66
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.evalModules. See https://nixos.org/manual/nixpkgs/unstable/#module-system-lib-evalModules or file://./../doc/module-system/module-system.chapter.md !!! Please think twice before adding to this argument list! The more that is specified here instead of in the modules themselves the harder it is to transparently move a set of modules to be a submodule of another config (as the proper arguments need to be replicated at each call to evalModules) and the less declarative the module set is. Arguments. Edit source. Noogle also knows. Aliases. lib.modules.evalModules.",
    "raw_url": "/f/lib/evalModules.html",
    "excerpt": "lib.evalModules. See https://nixos.org/manual/nixpkgs/unstable/#module-system-lib-evalModules or file://./../doc/module-system/module-system.chapter.md !!! Please think twice before adding to this argument list! The more that is specified here instead of in the modules themselves the harder it",
    "sub_results": []
  },
  {
    "url": "/f/lib/defaultMerge.html",
    "content": "lib.defaultMerge. Edit source. Noogle also knows. Aliases. lib.misc.defaultMerge.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.defaultMerge"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.defaultMerge. Edit source. Noogle also knows. Aliases. lib.misc.defaultMerge.",
    "raw_url": "/f/lib/defaultMerge.html",
    "excerpt": "lib.defaultMerge. Edit source. Noogle also knows. Aliases. lib.misc.defaultMerge.",
    "sub_results": []
  },
  {
    "url": "/f/lib/const.html",
    "content": "lib.const. The constant function Ignores the second argument. If called with only one argument, constructs a function that always returns a static value. Example. let f = const 5; in f 10 => 5 Type. const :: a -> b -> a Arguments. [x] Value to return. [y] Value to ignore. Edit source. Noogle also knows. Aliases. lib.trivial.const.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.const"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.const. The constant function Ignores the second argument. If called with only one argument, constructs a function that always returns a static value. Example. let f = const 5; in f 10 =&gt; 5 Type. const :: a -&gt; b -&gt; a Arguments. [x] Value to return. [y] Value to ignore. Edit source. Noogle also knows. Aliases. lib.trivial.const.",
    "raw_url": "/f/lib/const.html",
    "excerpt": "lib.const. The constant function Ignores the second argument. If called with only one argument, constructs a function that always returns a static value. Example. let f = const 5; in",
    "sub_results": []
  },
  {
    "url": "/f/lib/and.html",
    "content": "lib.and. boolean “and” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.and.",
    "word_count": 13,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.and"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 3
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.and. boolean “and” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.and.",
    "raw_url": "/f/lib/and.html",
    "excerpt": "lib.and. boolean “and” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.and.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeDefaultOption.html",
    "content": "lib.mergeDefaultOption. Edit source. Noogle also knows. Aliases. lib.options.mergeDefaultOption.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeDefaultOption"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeDefaultOption. Edit source. Noogle also knows. Aliases. lib.options.mergeDefaultOption.",
    "raw_url": "/f/lib/mergeDefaultOption.html",
    "excerpt": "lib.mergeDefaultOption. Edit source. Noogle also knows. Aliases. lib.options.mergeDefaultOption.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkUint16.html",
    "content": "lib.gvariant.mkUint16. Returns the GVariant uint16 from the given Nix int value. Type. mkUint16 :: Int -> gvariant Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkUint16"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkUint16. Returns the GVariant uint16 from the given Nix int value. Type. mkUint16 :: Int -&gt; gvariant Edit source.",
    "raw_url": "/f/lib/gvariant/mkUint16.html",
    "excerpt": "lib.gvariant.mkUint16. Returns the GVariant uint16 from the given Nix int value. Type. mkUint16 :: Int -&gt; gvariant Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkInt64.html",
    "content": "lib.gvariant.mkInt64. Returns the GVariant int64 from the given Nix int value. Type. mkInt64 :: Int -> gvariant Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkInt64"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkInt64. Returns the GVariant int64 from the given Nix int value. Type. mkInt64 :: Int -&gt; gvariant Edit source.",
    "raw_url": "/f/lib/gvariant/mkInt64.html",
    "excerpt": "lib.gvariant.mkInt64. Returns the GVariant int64 from the given Nix int value. Type. mkInt64 :: Int -&gt; gvariant Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkBoolean.html",
    "content": "lib.gvariant.mkBoolean. Returns the GVariant boolean from the given Nix bool value. Type. mkBoolean :: Bool -> gvariant Arguments. [v] Edit source.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkBoolean"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkBoolean. Returns the GVariant boolean from the given Nix bool value. Type. mkBoolean :: Bool -&gt; gvariant Arguments. [v] Edit source.",
    "raw_url": "/f/lib/gvariant/mkBoolean.html",
    "excerpt": "lib.gvariant.mkBoolean. Returns the GVariant boolean from the given Nix bool value. Type. mkBoolean :: Bool -&gt; gvariant Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkJust.html",
    "content": "lib.gvariant.mkJust. Returns the GVariant just from the given Nix value. Type. mkJust :: Any -> gvariant Arguments. [elem] Edit source.",
    "word_count": 20,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkJust"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 10
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 16
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkJust. Returns the GVariant just from the given Nix value. Type. mkJust :: Any -&gt; gvariant Arguments. [elem] Edit source.",
    "raw_url": "/f/lib/gvariant/mkJust.html",
    "excerpt": "lib.gvariant.mkJust. Returns the GVariant just from the given Nix value. Type. mkJust :: Any -&gt; gvariant Arguments. [elem] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkUchar.html",
    "content": "lib.gvariant.mkUchar. Returns the GVariant uchar from the given Nix int value. Type. mkUchar :: Int -> gvariant Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkUchar"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkUchar. Returns the GVariant uchar from the given Nix int value. Type. mkUchar :: Int -&gt; gvariant Edit source.",
    "raw_url": "/f/lib/gvariant/mkUchar.html",
    "excerpt": "lib.gvariant.mkUchar. Returns the GVariant uchar from the given Nix int value. Type. mkUchar :: Int -&gt; gvariant Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkUint32.html",
    "content": "lib.gvariant.mkUint32. Returns the GVariant uint32 from the given Nix int value. Type. mkUint32 :: Int -> gvariant Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkUint32"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkUint32. Returns the GVariant uint32 from the given Nix int value. Type. mkUint32 :: Int -&gt; gvariant Edit source.",
    "raw_url": "/f/lib/gvariant/mkUint32.html",
    "excerpt": "lib.gvariant.mkUint32. Returns the GVariant uint32 from the given Nix int value. Type. mkUint32 :: Int -&gt; gvariant Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkString.html",
    "content": "lib.gvariant.mkString. Returns the GVariant string from the given Nix string value. Type. mkString :: String -> gvariant Arguments. [v] Edit source.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkString. Returns the GVariant string from the given Nix string value. Type. mkString :: String -&gt; gvariant Arguments. [v] Edit source.",
    "raw_url": "/f/lib/gvariant/mkString.html",
    "excerpt": "lib.gvariant.mkString. Returns the GVariant string from the given Nix string value. Type. mkString :: String -&gt; gvariant Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkArray.html",
    "content": "lib.gvariant.mkArray. Returns the GVariant array from the given type of the elements and a Nix list. Example. # Creating a string array lib.gvariant.mkArray [ \"a\" \"b\" \"c\" ] Type. mkArray :: [Any] -> gvariant Arguments. [elems] Edit source.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkArray"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 28
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 34
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkArray. Returns the GVariant array from the given type of the elements and a Nix list. Example. # Creating a string array lib.gvariant.mkArray [ \"a\" \"b\" \"c\" ] Type. mkArray :: [Any] -&gt; gvariant Arguments. [elems] Edit source.",
    "raw_url": "/f/lib/gvariant/mkArray.html",
    "excerpt": "lib.gvariant.mkArray. Returns the GVariant array from the given type of the elements and a Nix list. Example. # Creating a string array lib.gvariant.mkArray [ \"a\" \"b\" \"c\" ] Type. mkArray",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkEmptyArray.html",
    "content": "lib.gvariant.mkEmptyArray. Returns the GVariant array from the given empty Nix list. Example. # Creating an empty string array lib.gvariant.mkEmptyArray (lib.gvariant.type.string) Type. mkEmptyArray :: gvariant.type -> gvariant Arguments. [elemType] Edit source.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkEmptyArray"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkEmptyArray. Returns the GVariant array from the given empty Nix list. Example. # Creating an empty string array lib.gvariant.mkEmptyArray (lib.gvariant.type.string) Type. mkEmptyArray :: gvariant.type -&gt; gvariant Arguments. [elemType] Edit source.",
    "raw_url": "/f/lib/gvariant/mkEmptyArray.html",
    "excerpt": "lib.gvariant.mkEmptyArray. Returns the GVariant array from the given empty Nix list. Example. # Creating an empty string array lib.gvariant.mkEmptyArray (lib.gvariant.type.string) Type. mkEmptyArray :: gvariant.type -&gt; gvariant Arguments. [elemType] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkInt16.html",
    "content": "lib.gvariant.mkInt16. Returns the GVariant int16 from the given Nix int value. Type. mkInt16 :: Int -> gvariant Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkInt16"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkInt16. Returns the GVariant int16 from the given Nix int value. Type. mkInt16 :: Int -&gt; gvariant Edit source.",
    "raw_url": "/f/lib/gvariant/mkInt16.html",
    "excerpt": "lib.gvariant.mkInt16. Returns the GVariant int16 from the given Nix int value. Type. mkInt16 :: Int -&gt; gvariant Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/isGVariant.html",
    "content": "lib.gvariant.isGVariant. Check if a value is a GVariant value. Type. isGVariant :: Any -> Bool Arguments. [v] Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.isGVariant"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 15
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.isGVariant. Check if a value is a GVariant value. Type. isGVariant :: Any -&gt; Bool Arguments. [v] Edit source.",
    "raw_url": "/f/lib/gvariant/isGVariant.html",
    "excerpt": "lib.gvariant.isGVariant. Check if a value is a GVariant value. Type. isGVariant :: Any -&gt; Bool Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkInt32.html",
    "content": "lib.gvariant.mkInt32. Returns the GVariant int32 from the given Nix int value. Type. mkInt32 :: Int -> gvariant Arguments. [v] Edit source.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkInt32"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkInt32. Returns the GVariant int32 from the given Nix int value. Type. mkInt32 :: Int -&gt; gvariant Arguments. [v] Edit source.",
    "raw_url": "/f/lib/gvariant/mkInt32.html",
    "excerpt": "lib.gvariant.mkInt32. Returns the GVariant int32 from the given Nix int value. Type. mkInt32 :: Int -&gt; gvariant Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkDouble.html",
    "content": "lib.gvariant.mkDouble. Returns the GVariant double from the given Nix float value. Type. mkDouble :: Float -> gvariant Arguments. [v] Edit source.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkDouble"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkDouble. Returns the GVariant double from the given Nix float value. Type. mkDouble :: Float -&gt; gvariant Arguments. [v] Edit source.",
    "raw_url": "/f/lib/gvariant/mkDouble.html",
    "excerpt": "lib.gvariant.mkDouble. Returns the GVariant double from the given Nix float value. Type. mkDouble :: Float -&gt; gvariant Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/type/maybeOf.html",
    "content": "lib.gvariant.type.maybeOf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.type.maybeOf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.type.maybeOf. Edit source.",
    "raw_url": "/f/lib/gvariant/type/maybeOf.html",
    "excerpt": "lib.gvariant.type.maybeOf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/type/dictionaryEntryOf.html",
    "content": "lib.gvariant.type.dictionaryEntryOf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.type.dictionaryEntryOf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.type.dictionaryEntryOf. Edit source.",
    "raw_url": "/f/lib/gvariant/type/dictionaryEntryOf.html",
    "excerpt": "lib.gvariant.type.dictionaryEntryOf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/type/arrayOf.html",
    "content": "lib.gvariant.type.arrayOf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.type.arrayOf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.type.arrayOf. Edit source.",
    "raw_url": "/f/lib/gvariant/type/arrayOf.html",
    "excerpt": "lib.gvariant.type.arrayOf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/type/tupleOf.html",
    "content": "lib.gvariant.type.tupleOf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.type.tupleOf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.type.tupleOf. Edit source.",
    "raw_url": "/f/lib/gvariant/type/tupleOf.html",
    "excerpt": "lib.gvariant.type.tupleOf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkNothing.html",
    "content": "lib.gvariant.mkNothing. Returns the GVariant nothing from the given element type. Type. mkNothing :: gvariant.type -> gvariant Arguments. [elemType] Edit source.",
    "word_count": 20,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkNothing"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 10
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 16
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkNothing. Returns the GVariant nothing from the given element type. Type. mkNothing :: gvariant.type -&gt; gvariant Arguments. [elemType] Edit source.",
    "raw_url": "/f/lib/gvariant/mkNothing.html",
    "excerpt": "lib.gvariant.mkNothing. Returns the GVariant nothing from the given element type. Type. mkNothing :: gvariant.type -&gt; gvariant Arguments. [elemType] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkUint64.html",
    "content": "lib.gvariant.mkUint64. Returns the GVariant uint64 from the given Nix int value. Type. mkUint64 :: Int -> gvariant Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkUint64"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkUint64. Returns the GVariant uint64 from the given Nix int value. Type. mkUint64 :: Int -&gt; gvariant Edit source.",
    "raw_url": "/f/lib/gvariant/mkUint64.html",
    "excerpt": "lib.gvariant.mkUint64. Returns the GVariant uint64 from the given Nix int value. Type. mkUint64 :: Int -&gt; gvariant Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkDictionaryEntry.html",
    "content": "lib.gvariant.mkDictionaryEntry. Returns the GVariant dictionary entry from the given key and value. Example. # A dictionary describing an Epiphany’s search provider [ (lib.gvariant.mkDictionaryEntry \"url\" (lib.gvariant.mkVariant \"https://duckduckgo.com/?q=%s&t=epiphany\")) (lib.gvariant.mkDictionaryEntry \"bang\" (lib.gvariant.mkVariant \"!d\")) (lib.gvariant.mkDictionaryEntry \"name\" (lib.gvariant.mkVariant \"DuckDuckGo\")) ] Type. mkDictionaryEntry :: String -> Any -> gvariant Arguments. [name] The key of the entry. [value] The value of the entry. Edit source.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkDictionaryEntry"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 35
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 43
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkDictionaryEntry. Returns the GVariant dictionary entry from the given key and value. Example. # A dictionary describing an Epiphany’s search provider [ (lib.gvariant.mkDictionaryEntry \"url\" (lib.gvariant.mkVariant \"https://duckduckgo.com/?q=%s&t=epiphany\")) (lib.gvariant.mkDictionaryEntry \"bang\" (lib.gvariant.mkVariant \"!d\")) (lib.gvariant.mkDictionaryEntry \"name\" (lib.gvariant.mkVariant \"DuckDuckGo\")) ] Type. mkDictionaryEntry :: String -&gt; Any -&gt; gvariant Arguments. [name] The key of the entry. [value] The value of the entry. Edit source.",
    "raw_url": "/f/lib/gvariant/mkDictionaryEntry.html",
    "excerpt": "lib.gvariant.mkDictionaryEntry. Returns the GVariant dictionary entry from the given key and value. Example. # A dictionary describing an Epiphany’s search provider [ (lib.gvariant.mkDictionaryEntry \"url\" (lib.gvariant.mkVariant \"https://duckduckgo.com/?q=%s&t=epiphany\")) (lib.gvariant.mkDictionaryEntry \"bang\" (lib.gvariant.mkVariant \"!d\"))",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkVariant.html",
    "content": "lib.gvariant.mkVariant. Returns the GVariant variant from the given Nix value. Variants are containers of different GVariant type. Example. lib.gvariant.mkArray [ (lib.gvariant.mkVariant \"a string\") (lib.gvariant.mkVariant (lib.gvariant.mkInt32 1)) ] Type. mkVariant :: Any -> gvariant Arguments. [elem] Edit source.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkVariant"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 27
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 33
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkVariant. Returns the GVariant variant from the given Nix value. Variants are containers of different GVariant type. Example. lib.gvariant.mkArray [ (lib.gvariant.mkVariant \"a string\") (lib.gvariant.mkVariant (lib.gvariant.mkInt32 1)) ] Type. mkVariant :: Any -&gt; gvariant Arguments. [elem] Edit source.",
    "raw_url": "/f/lib/gvariant/mkVariant.html",
    "excerpt": "lib.gvariant.mkVariant. Returns the GVariant variant from the given Nix value. Variants are containers of different GVariant type. Example. lib.gvariant.mkArray [ (lib.gvariant.mkVariant \"a string\") (lib.gvariant.mkVariant (lib.gvariant.mkInt32 1)) ] Type. mkVariant ::",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkTuple.html",
    "content": "lib.gvariant.mkTuple. Returns the GVariant tuple from the given Nix list. Type. mkTuple :: [Any] -> gvariant Arguments. [elems] Edit source.",
    "word_count": 20,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkTuple"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 10
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 16
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkTuple. Returns the GVariant tuple from the given Nix list. Type. mkTuple :: [Any] -&gt; gvariant Arguments. [elems] Edit source.",
    "raw_url": "/f/lib/gvariant/mkTuple.html",
    "excerpt": "lib.gvariant.mkTuple. Returns the GVariant tuple from the given Nix list. Type. mkTuple :: [Any] -&gt; gvariant Arguments. [elems] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkObjectpath.html",
    "content": "lib.gvariant.mkObjectpath. Returns the GVariant object path from the given Nix string value. Type. mkObjectpath :: String -> gvariant Arguments. [v] Edit source.",
    "word_count": 22,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkObjectpath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 18
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkObjectpath. Returns the GVariant object path from the given Nix string value. Type. mkObjectpath :: String -&gt; gvariant Arguments. [v] Edit source.",
    "raw_url": "/f/lib/gvariant/mkObjectpath.html",
    "excerpt": "lib.gvariant.mkObjectpath. Returns the GVariant object path from the given Nix string value. Type. mkObjectpath :: String -&gt; gvariant Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkValue.html",
    "content": "lib.gvariant.mkValue. Returns the GVariant value that most closely matches the given Nix value. If no GVariant value can be found unambiguously then error is thrown. Type. mkValue :: Any -> gvariant Arguments. [v] Edit source.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkValue"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 31
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkValue. Returns the GVariant value that most closely matches the given Nix value. If no GVariant value can be found unambiguously then error is thrown. Type. mkValue :: Any -&gt; gvariant Arguments. [v] Edit source.",
    "raw_url": "/f/lib/gvariant/mkValue.html",
    "excerpt": "lib.gvariant.mkValue. Returns the GVariant value that most closely matches the given Nix value. If no GVariant value can be found unambiguously then error is thrown. Type. mkValue :: Any -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/gvariant/mkMaybe.html",
    "content": "lib.gvariant.mkMaybe. Returns the GVariant maybe from the given element type. Type. mkMaybe :: gvariant.type -> Any -> gvariant Arguments. [elemType] [elem] Edit source.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.gvariant.mkMaybe"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 10
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 18
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.gvariant.mkMaybe. Returns the GVariant maybe from the given element type. Type. mkMaybe :: gvariant.type -&gt; Any -&gt; gvariant Arguments. [elemType] [elem] Edit source.",
    "raw_url": "/f/lib/gvariant/mkMaybe.html",
    "excerpt": "lib.gvariant.mkMaybe. Returns the GVariant maybe from the given element type. Type. mkMaybe :: gvariant.type -&gt; Any -&gt; gvariant Arguments. [elemType] [elem] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/hiPrioSet.html",
    "content": "lib.meta.hiPrioSet. Apply hiPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.hiPrioSet.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.hiPrioSet"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.hiPrioSet. Apply hiPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.hiPrioSet.",
    "raw_url": "/f/lib/meta/hiPrioSet.html",
    "excerpt": "lib.meta.hiPrioSet. Apply hiPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.hiPrioSet.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/mapDerivationAttrset.html",
    "content": "lib.meta.mapDerivationAttrset. Apply a function to each derivation and only to derivations in an attrset. Arguments. [f] [set] Edit source. Noogle also knows. Aliases. lib.mapDerivationAttrset.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.mapDerivationAttrset"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.mapDerivationAttrset. Apply a function to each derivation and only to derivations in an attrset. Arguments. [f] [set] Edit source. Noogle also knows. Aliases. lib.mapDerivationAttrset.",
    "raw_url": "/f/lib/meta/mapDerivationAttrset.html",
    "excerpt": "lib.meta.mapDerivationAttrset. Apply a function to each derivation and only to derivations in an attrset. Arguments. [f] [set] Edit source. Noogle also knows. Aliases. lib.mapDerivationAttrset.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/appendToName.html",
    "content": "lib.meta.appendToName. Append a suffix to the name of a package (before the version part). Arguments. [suffix] Edit source. Noogle also knows. Aliases. lib.appendToName.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.appendToName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.appendToName. Append a suffix to the name of a package (before the version part). Arguments. [suffix] Edit source. Noogle also knows. Aliases. lib.appendToName.",
    "raw_url": "/f/lib/meta/appendToName.html",
    "excerpt": "lib.meta.appendToName. Append a suffix to the name of a package (before the version part). Arguments. [suffix] Edit source. Noogle also knows. Aliases. lib.appendToName.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/setPrio.html",
    "content": "lib.meta.setPrio. Set the nix-env priority of the package. Arguments. [priority] Edit source. Noogle also knows. Aliases. lib.setPrio.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.setPrio"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.setPrio. Set the nix-env priority of the package. Arguments. [priority] Edit source. Noogle also knows. Aliases. lib.setPrio.",
    "raw_url": "/f/lib/meta/setPrio.html",
    "excerpt": "lib.meta.setPrio. Set the nix-env priority of the package. Arguments. [priority] Edit source. Noogle also knows. Aliases. lib.setPrio.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/lowPrioSet.html",
    "content": "lib.meta.lowPrioSet. Apply lowPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.lowPrioSet.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.lowPrioSet"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.lowPrioSet. Apply lowPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.lowPrioSet.",
    "raw_url": "/f/lib/meta/lowPrioSet.html",
    "excerpt": "lib.meta.lowPrioSet. Apply lowPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.lowPrioSet.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/dontDistribute.html",
    "content": "lib.meta.dontDistribute. Disable Hydra builds of given derivation. Arguments. [drv] Edit source. Noogle also knows. Aliases. lib.dontDistribute. pkgs.haskell.lib.dontDistribute.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.dontDistribute"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 7
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.dontDistribute. Disable Hydra builds of given derivation. Arguments. [drv] Edit source. Noogle also knows. Aliases. lib.dontDistribute. pkgs.haskell.lib.dontDistribute.",
    "raw_url": "/f/lib/meta/dontDistribute.html",
    "excerpt": "lib.meta.dontDistribute. Disable Hydra builds of given derivation. Arguments. [drv] Edit source. Noogle also knows. Aliases. lib.dontDistribute. pkgs.haskell.lib.dontDistribute.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/hiPrio.html",
    "content": "lib.meta.hiPrio. Increase the nix-env priority of the package, i.e., this version/variant of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.hiPrio. pkgs.hiPrio.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.hiPrio"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.hiPrio. Increase the nix-env priority of the package, i.e., this version/variant of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.hiPrio. pkgs.hiPrio.",
    "raw_url": "/f/lib/meta/hiPrio.html",
    "excerpt": "lib.meta.hiPrio. Increase the nix-env priority of the package, i.e., this version/variant of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.hiPrio. pkgs.hiPrio.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/setName.html",
    "content": "lib.meta.setName. Change the symbolic name of a package for presentation purposes (i.e., so that nix-env users can tell them apart). Arguments. [name] [drv] Edit source. Noogle also knows. Aliases. lib.setName.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.setName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.setName. Change the symbolic name of a package for presentation purposes (i.e., so that nix-env users can tell them apart). Arguments. [name] [drv] Edit source. Noogle also knows. Aliases. lib.setName.",
    "raw_url": "/f/lib/meta/setName.html",
    "excerpt": "lib.meta.setName. Change the symbolic name of a package for presentation purposes (i.e., so that nix-env users can tell them apart). Arguments. [name] [drv] Edit source. Noogle also knows. Aliases. lib.setName.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/lowPrio.html",
    "content": "lib.meta.lowPrio. Decrease the nix-env priority of the package, i.e., other versions/variants of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.lowPrio. pkgs.lowPrio.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.lowPrio"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.lowPrio. Decrease the nix-env priority of the package, i.e., other versions/variants of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.lowPrio. pkgs.lowPrio.",
    "raw_url": "/f/lib/meta/lowPrio.html",
    "excerpt": "lib.meta.lowPrio. Decrease the nix-env priority of the package, i.e., other versions/variants of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.lowPrio. pkgs.lowPrio.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/platformMatch.html",
    "content": "lib.meta.platformMatch. Check to see if a platform is matched by the given meta.platforms element. A meta.platform pattern is either. (legacy) a system string. (modern) a pattern for the entire platform structure (see lib.systems.inspect.platformPatterns). (modern) a pattern for the platform parsed field (see lib.systems.inspect.patterns). We can inject these into a pattern for the whole of a structured platform, and then match that. Arguments. [platform] [elem] Edit source.",
    "word_count": 66,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.platformMatch"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 61
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.platformMatch. Check to see if a platform is matched by the given meta.platforms element. A meta.platform pattern is either. (legacy) a system string. (modern) a pattern for the entire platform structure (see lib.systems.inspect.platformPatterns). (modern) a pattern for the platform parsed field (see lib.systems.inspect.patterns). We can inject these into a pattern for the whole of a structured platform, and then match that. Arguments. [platform] [elem] Edit source.",
    "raw_url": "/f/lib/meta/platformMatch.html",
    "excerpt": "lib.meta.platformMatch. Check to see if a platform is matched by the given meta.platforms element. A meta.platform pattern is either. (legacy) a system string. (modern) a pattern for the entire platform",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/getLicenseFromSpdxId.html",
    "content": "lib.meta.getLicenseFromSpdxId. Get the corresponding attribute in lib.licenses from the SPDX ID. For SPDX IDs, see https://spdx.org/licenses. Example. lib.getLicenseFromSpdxId \"MIT\" == lib.licenses.mit => true lib.getLicenseFromSpdxId \"mIt\" == lib.licenses.mit => true lib.getLicenseFromSpdxId \"MY LICENSE\" => trace: warning: getLicenseFromSpdxId: No license matches the given SPDX ID: MY LICENSE => { shortName = \"MY LICENSE\"; } Type. getLicenseFromSpdxId :: str -> AttrSet Edit source. Noogle also knows. Aliases. lib.getLicenseFromSpdxId.",
    "word_count": 65,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.getLicenseFromSpdxId"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 52
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.getLicenseFromSpdxId. Get the corresponding attribute in lib.licenses from the SPDX ID. For SPDX IDs, see https://spdx.org/licenses. Example. lib.getLicenseFromSpdxId \"MIT\" == lib.licenses.mit =&gt; true lib.getLicenseFromSpdxId \"mIt\" == lib.licenses.mit =&gt; true lib.getLicenseFromSpdxId \"MY LICENSE\" =&gt; trace: warning: getLicenseFromSpdxId: No license matches the given SPDX ID: MY LICENSE =&gt; { shortName = \"MY LICENSE\"; } Type. getLicenseFromSpdxId :: str -&gt; AttrSet Edit source. Noogle also knows. Aliases. lib.getLicenseFromSpdxId.",
    "raw_url": "/f/lib/meta/getLicenseFromSpdxId.html",
    "excerpt": "lib.meta.getLicenseFromSpdxId. Get the corresponding attribute in lib.licenses from the SPDX ID. For SPDX IDs, see https://spdx.org/licenses. Example. lib.getLicenseFromSpdxId \"MIT\" == lib.licenses.mit =&gt; true lib.getLicenseFromSpdxId \"mIt\" == lib.licenses.mit =&gt; true lib.getLicenseFromSpdxId",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/getExe.html",
    "content": "lib.meta.getExe. Get the path to the main program of a package based on meta.mainProgram. Example. getExe pkgs.hello => \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe pkgs.mustache-go => \"/nix/store/am9ml4f4ywvivxnkiaqwr0hyxka1xjsf-mustache-go-1.3.0/bin/mustache\" Type. getExe :: package -> string Arguments. [x] Edit source. Noogle also knows. Aliases. lib.getExe.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.getExe"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.getExe. Get the path to the main program of a package based on meta.mainProgram. Example. getExe pkgs.hello =&gt; \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe pkgs.mustache-go =&gt; \"/nix/store/am9ml4f4ywvivxnkiaqwr0hyxka1xjsf-mustache-go-1.3.0/bin/mustache\" Type. getExe :: package -&gt; string Arguments. [x] Edit source. Noogle also knows. Aliases. lib.getExe.",
    "raw_url": "/f/lib/meta/getExe.html",
    "excerpt": "lib.meta.getExe. Get the path to the main program of a package based on meta.mainProgram. Example. getExe pkgs.hello =&gt; \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe pkgs.mustache-go =&gt; \"/nix/store/am9ml4f4ywvivxnkiaqwr0hyxka1xjsf-mustache-go-1.3.0/bin/mustache\" Type. getExe :: package -&gt; string Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/updateName.html",
    "content": "lib.meta.updateName. Like setName, but takes the previous name as an argument. Example. updateName (oldName: oldName + \"-experimental\") somePkg Arguments. [updater] [drv] Edit source. Noogle also knows. Aliases. lib.updateName.",
    "word_count": 28,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.updateName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 18
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.updateName. Like setName, but takes the previous name as an argument. Example. updateName (oldName: oldName + \"-experimental\") somePkg Arguments. [updater] [drv] Edit source. Noogle also knows. Aliases. lib.updateName.",
    "raw_url": "/f/lib/meta/updateName.html",
    "excerpt": "lib.meta.updateName. Like setName, but takes the previous name as an argument. Example. updateName (oldName: oldName + \"-experimental\") somePkg Arguments. [updater] [drv] Edit source. Noogle also knows. Aliases. lib.updateName.",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/getExe'.html",
    "content": "lib.meta.getExe' (Prime). Get the path of a program of a derivation. Example. getExe' pkgs.hello \"hello\" => \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe' pkgs.imagemagick \"convert\" => \"/nix/store/5rs48jamq7k6sal98ymj9l4k2bnwq515-imagemagick-7.1.1-15/bin/convert\" Type. getExe' :: derivation -> string -> string Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.getExe'",
    "word_count": 40,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.getExe' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 30
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.getExe' (Prime). Get the path of a program of a derivation. Example. getExe' pkgs.hello \"hello\" =&gt; \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe' pkgs.imagemagick \"convert\" =&gt; \"/nix/store/5rs48jamq7k6sal98ymj9l4k2bnwq515-imagemagick-7.1.1-15/bin/convert\" Type. getExe' :: derivation -&gt; string -&gt; string Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.getExe'",
    "raw_url": "/f/lib/meta/getExe'.html",
    "excerpt": "lib.meta.getExe' (Prime). Get the path of a program of a derivation. Example. getExe' pkgs.hello \"hello\" =&gt; \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe' pkgs.imagemagick \"convert\" =&gt; \"/nix/store/5rs48jamq7k6sal98ymj9l4k2bnwq515-imagemagick-7.1.1-15/bin/convert\" Type. getExe' :: derivation -&gt; string -&gt; string",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/availableOn.html",
    "content": "lib.meta.availableOn. Check if a package is available on a given platform. A package is available on a platform if both. One of meta.platforms pattern matches the given platform, or meta.platforms is not present. None of meta.badPlatforms pattern matches the given platform. Arguments. [platform] [pkg] Edit source.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.availableOn"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.availableOn. Check if a package is available on a given platform. A package is available on a platform if both. One of meta.platforms pattern matches the given platform, or meta.platforms is not present. None of meta.badPlatforms pattern matches the given platform. Arguments. [platform] [pkg] Edit source.",
    "raw_url": "/f/lib/meta/availableOn.html",
    "excerpt": "lib.meta.availableOn. Check if a package is available on a given platform. A package is available on a platform if both. One of meta.platforms pattern matches the given platform, or meta.platforms",
    "sub_results": []
  },
  {
    "url": "/f/lib/meta/addMetaAttrs.html",
    "content": "lib.meta.addMetaAttrs. Add to or override the meta attributes of the given derivation. Example. addMetaAttrs {description = \"Bla blah\";} somePkg Arguments. [newAttrs] [drv] Edit source. Noogle also knows. Aliases. lib.addMetaAttrs.",
    "word_count": 29,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.meta.addMetaAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 19
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.meta.addMetaAttrs. Add to or override the meta attributes of the given derivation. Example. addMetaAttrs {description = \"Bla blah\";} somePkg Arguments. [newAttrs] [drv] Edit source. Noogle also knows. Aliases. lib.addMetaAttrs.",
    "raw_url": "/f/lib/meta/addMetaAttrs.html",
    "excerpt": "lib.meta.addMetaAttrs. Add to or override the meta attributes of the given derivation. Example. addMetaAttrs {description = \"Bla blah\";} somePkg Arguments. [newAttrs] [drv] Edit source. Noogle also knows. Aliases. lib.addMetaAttrs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/addErrorContext.html",
    "content": "lib.addErrorContext Primop. Takes 2 arguments.",
    "word_count": 5,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.addErrorContext Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.addErrorContext Primop. Takes 2 arguments.",
    "raw_url": "/f/lib/addErrorContext.html",
    "excerpt": "lib.addErrorContext Primop. Takes 2 arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/concatMapStringsSep.html",
    "content": "lib.concatMapStringsSep. Maps a function over a list of strings and then concatenates the result with the specified separator interspersed between elements. Example. concatMapStringsSep \"-\" (x: toUpper x) [\"foo\" \"bar\" \"baz\"] => \"FOO-BAR-BAZ\" Type. concatMapStringsSep :: string -> (a -> string) -> [a] -> string Arguments. [sep] Separator to add between elements. [f] Function to map over the list. [list] List of input strings. Edit source. Noogle also knows. Aliases. lib.strings.concatMapStringsSep.",
    "word_count": 70,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concatMapStringsSep"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 21
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 44
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concatMapStringsSep. Maps a function over a list of strings and then concatenates the result with the specified separator interspersed between elements. Example. concatMapStringsSep \"-\" (x: toUpper x) [\"foo\" \"bar\" \"baz\"] =&gt; \"FOO-BAR-BAZ\" Type. concatMapStringsSep :: string -&gt; (a -&gt; string) -&gt; [a] -&gt; string Arguments. [sep] Separator to add between elements. [f] Function to map over the list. [list] List of input strings. Edit source. Noogle also knows. Aliases. lib.strings.concatMapStringsSep.",
    "raw_url": "/f/lib/concatMapStringsSep.html",
    "excerpt": "lib.concatMapStringsSep. Maps a function over a list of strings and then concatenates the result with the specified separator interspersed between elements. Example. concatMapStringsSep \"-\" (x: toUpper x) [\"foo\" \"bar\" \"baz\"]",
    "sub_results": []
  },
  {
    "url": "/f/lib/checkListOfEnum.html",
    "content": "lib.checkListOfEnum. Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise. Example. let colorVariants = [\"bright\" \"dark\" \"black\"] in checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants; => error: color variants: bright, black unexpected; valid ones: standard, light, dark Type. String -> List ComparableVal -> List ComparableVal -> a -> a Arguments. [msg] [valid] [given] Edit source. Noogle also knows. Aliases. lib.trivial.checkListOfEnum.",
    "word_count": 76,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.checkListOfEnum"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 53
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 65
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.checkListOfEnum. Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise. Example. let colorVariants = [\"bright\" \"dark\" \"black\"] in checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants; =&gt; error: color variants: bright, black unexpected; valid ones: standard, light, dark Type. String -&gt; List ComparableVal -&gt; List ComparableVal -&gt; a -&gt; a Arguments. [msg] [valid] [given] Edit source. Noogle also knows. Aliases. lib.trivial.checkListOfEnum.",
    "raw_url": "/f/lib/checkListOfEnum.html",
    "excerpt": "lib.checkListOfEnum. Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise. Example. let colorVariants = [\"bright\" \"dark\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/toFunction.html",
    "content": "lib.toFunction. Turns any non-callable values into constant functions. Returns callable values as is. Example. nix-repl> lib.toFunction 1 2 1 nix-repl> lib.toFunction (x: x + 1) 2 3 Arguments. [v] Any value. Edit source. Noogle also knows. Aliases. lib.trivial.toFunction.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toFunction"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toFunction. Turns any non-callable values into constant functions. Returns callable values as is. Example. nix-repl&gt; lib.toFunction 1 2 1 nix-repl&gt; lib.toFunction (x: x + 1) 2 3 Arguments. [v] Any value. Edit source. Noogle also knows. Aliases. lib.trivial.toFunction.",
    "raw_url": "/f/lib/toFunction.html",
    "excerpt": "lib.toFunction. Turns any non-callable values into constant functions. Returns callable values as is. Example. nix-repl&gt; lib.toFunction 1 2 1 nix-repl&gt; lib.toFunction (x: x + 1) 2 3 Arguments. [v] Any",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixedWidthString.html",
    "content": "lib.fixedWidthString. Create a fixed width string with additional prefix to match required width. This function will fail if the input string is longer than the requested length. Example. fixedWidthString 5 \"0\" (toString 15) => \"00015\" Type. fixedWidthString :: int -> string -> string -> string Arguments. [width] [filler] [str] Edit source. Noogle also knows. Aliases. lib.strings.fixedWidthString.",
    "word_count": 56,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixedWidthString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 27
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 35
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 45
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixedWidthString. Create a fixed width string with additional prefix to match required width. This function will fail if the input string is longer than the requested length. Example. fixedWidthString 5 \"0\" (toString 15) =&gt; \"00015\" Type. fixedWidthString :: int -&gt; string -&gt; string -&gt; string Arguments. [width] [filler] [str] Edit source. Noogle also knows. Aliases. lib.strings.fixedWidthString.",
    "raw_url": "/f/lib/fixedWidthString.html",
    "excerpt": "lib.fixedWidthString. Create a fixed width string with additional prefix to match required width. This function will fail if the input string is longer than the requested length. Example. fixedWidthString 5",
    "sub_results": []
  },
  {
    "url": "/f/lib/drop.html",
    "content": "lib.drop. Remove the first (at most) N elements of a list. Example. drop 2 [ \"a\" \"b\" \"c\" \"d\" ] => [ \"c\" \"d\" ] drop 2 [ ] => [ ] Type. drop :: int -> [a] -> [a] Arguments. [count] Number of elements to drop. [list] Input list. Edit source. Noogle also knows. Aliases. lib.lists.drop.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.drop"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.drop. Remove the first (at most) N elements of a list. Example. drop 2 [ \"a\" \"b\" \"c\" \"d\" ] =&gt; [ \"c\" \"d\" ] drop 2 [ ] =&gt; [ ] Type. drop :: int -&gt; [a] -&gt; [a] Arguments. [count] Number of elements to drop. [list] Input list. Edit source. Noogle also knows. Aliases. lib.lists.drop.",
    "raw_url": "/f/lib/drop.html",
    "excerpt": "lib.drop. Remove the first (at most) N elements of a list. Example. drop 2 [ \"a\" \"b\" \"c\" \"d\" ] =&gt; [ \"c\" \"d\" ] drop 2 [ ] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/count.html",
    "content": "lib.count. Count how many elements of list match the supplied predicate function. Example. count (x: x == 3) [ 3 2 3 4 6 ] => 2 Type. count :: (a -> bool) -> [a] -> int Arguments. [pred] Predicate. Edit source. Noogle also knows. Aliases. lib.lists.count.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.count"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 27
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 37
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.count. Count how many elements of list match the supplied predicate function. Example. count (x: x == 3) [ 3 2 3 4 6 ] =&gt; 2 Type. count :: (a -&gt; bool) -&gt; [a] -&gt; int Arguments. [pred] Predicate. Edit source. Noogle also knows. Aliases. lib.lists.count.",
    "raw_url": "/f/lib/count.html",
    "excerpt": "lib.count. Count how many elements of list match the supplied predicate function. Example. count (x: x == 3) [ 3 2 3 4 6 ] =&gt; 2 Type. count ::",
    "sub_results": []
  },
  {
    "url": "/f/lib/throwIfNot.html",
    "content": "lib.throwIfNot. Like the assert b; e expression, but with a custom error message and without the semicolon. If true, return the identity function, r: r. If false, throw the error message. Calls can be juxtaposed using function application, as (r: r) a = a, so (r: r) (r: r) a = a, and so forth. Example. throwIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\" lib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays pkgs Type. bool -> string -> a -> a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.throwIfNot.",
    "word_count": 103,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.throwIfNot"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 55
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 85
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 93
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.throwIfNot. Like the assert b; e expression, but with a custom error message and without the semicolon. If true, return the identity function, r: r. If false, throw the error message. Calls can be juxtaposed using function application, as (r: r) a = a, so (r: r) (r: r) a = a, and so forth. Example. throwIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\" lib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays pkgs Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.throwIfNot.",
    "raw_url": "/f/lib/throwIfNot.html",
    "excerpt": "lib.throwIfNot. Like the assert b; e expression, but with a custom error message and without the semicolon. If true, return the identity function, r: r. If false, throw the error",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/mergeOneOption.html",
    "content": "lib.options.mergeOneOption. Noogle also knows. Aliases. lib.mergeOneOption.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.mergeOneOption"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.mergeOneOption. Noogle also knows. Aliases. lib.mergeOneOption.",
    "raw_url": "/f/lib/options/mergeOneOption.html",
    "excerpt": "lib.options.mergeOneOption. Noogle also knows. Aliases. lib.mergeOneOption.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/renderOptionValue.html",
    "content": "lib.options.renderOptionValue. Ensures that the given option value (default or example) is a _typed string by rendering Nix values to literalExpressions. Arguments. [v] Edit source.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.renderOptionValue"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.renderOptionValue. Ensures that the given option value (default or example) is a _typed string by rendering Nix values to literalExpressions. Arguments. [v] Edit source.",
    "raw_url": "/f/lib/options/renderOptionValue.html",
    "excerpt": "lib.options.renderOptionValue. Ensures that the given option value (default or example) is a _typed string by rendering Nix values to literalExpressions. Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/mkPackageOption.html",
    "content": "lib.options.mkPackageOption. Creates an Option attribute set for an option that specifies the package a module should use for some purpose. The package is specified in the third argument under default as a list of strings representing its attribute path in nixpkgs (or another package set). Because of this, you need to pass nixpkgs itself (usually pkgs in a module; alternatively to nixpkgs itself, another package set) as the first argument. If you pass another package set you should set the pkgsText option. This option is used to display the expression for the package set. It is \"pkgs\" by default. If your expression is complex you should parenthesize it, as the pkgsText argument is usually immediately followed by an attribute lookup (.). The second argument may be either a string or a list of strings. It provides the display name of the package in the description of the generated option (using only the last element if the passed value is a list) and serves as the fallback value for the default argument. To include extra information in the description, pass extraDescription to append arbitrary text to the generated description. You can also pass an example value, either a literal string or an attribute path. The default argument can be omitted if the provided name is an attribute of pkgs (if name is a string) or a valid attribute path in pkgs (if name is a list). You can also set default to just a string in which case it is interpreted as an attribute name (a singleton attribute path, if you will). If you wish to explicitly provide no default, pass null as default. If you want users to be able to set no package, pass nullable = true. In this mode a default = null will not be interpreted as no default and is interpreted literally. Example. mkPackageOption pkgs \"hello\" { } => { ...; default = pkgs.hello; defaultText = literalExpression \"pkgs.hello\"; description = \"The hello package to use.\"; type = package; } mkPackageOption pkgs \"GHC\" { default = [ \"ghc\" ]; example = \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; } => { ...; default = pkgs.ghc; defaultText = literalExpression \"pkgs.ghc\"; description = \"The GHC package to use.\"; example = literalExpression \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; type = package; } mkPackageOption pkgs [ \"python3Packages\" \"pytorch\" ] { extraDescription = \"This is an example and doesn't actually do anything.\"; } => { ...; default = pkgs.python3Packages.pytorch; defaultText = literalExpression \"pkgs.python3Packages.pytorch\"; description = \"The pytorch package to use. This is an example and doesn't actually do anything.\"; type = package; } mkPackageOption pkgs \"nushell\" { nullable = true; } => { ...; default = pkgs.nushell; defaultText = literalExpression \"pkgs.nushell\"; description = \"The nushell package to use.\"; type = nullOr package; } mkPackageOption pkgs \"coreutils\" { default = null; } => { ...; description = \"The coreutils package to use.\"; type = package; } mkPackageOption pkgs \"dbus\" { nullable = true; default = null; } => { ...; default = null; description = \"The dbus package to use.\"; type = nullOr package; } mkPackageOption pkgs.javaPackages \"OpenJFX\" { default = \"openjfx20\"; pkgsText = \"pkgs.javaPackages\"; } => { ...; default = pkgs.javaPackages.openjfx20; defaultText = literalExpression \"pkgs.javaPackages.openjfx20\"; description = \"The OpenJFX package to use.\"; type = package; } Type. mkPackageOption :: pkgs -> (string|[string]) -> { nullable? :: bool, default? :: string|[string], example? :: null|string|[string], extraDescription? :: string, pkgsText? :: string } -> option Arguments. [pkgs] Package set (an instantiation of nixpkgs such as pkgs in modules or another package set). [name] Name for the package, shown in option description. Edit source. Noogle also knows. Aliases. lib.mkPackageOption.",
    "word_count": 600,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.mkPackageOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 306
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 541
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 567
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.mkPackageOption. Creates an Option attribute set for an option that specifies the package a module should use for some purpose. The package is specified in the third argument under default as a list of strings representing its attribute path in nixpkgs (or another package set). Because of this, you need to pass nixpkgs itself (usually pkgs in a module; alternatively to nixpkgs itself, another package set) as the first argument. If you pass another package set you should set the pkgsText option. This option is used to display the expression for the package set. It is \"pkgs\" by default. If your expression is complex you should parenthesize it, as the pkgsText argument is usually immediately followed by an attribute lookup (.). The second argument may be either a string or a list of strings. It provides the display name of the package in the description of the generated option (using only the last element if the passed value is a list) and serves as the fallback value for the default argument. To include extra information in the description, pass extraDescription to append arbitrary text to the generated description. You can also pass an example value, either a literal string or an attribute path. The default argument can be omitted if the provided name is an attribute of pkgs (if name is a string) or a valid attribute path in pkgs (if name is a list). You can also set default to just a string in which case it is interpreted as an attribute name (a singleton attribute path, if you will). If you wish to explicitly provide no default, pass null as default. If you want users to be able to set no package, pass nullable = true. In this mode a default = null will not be interpreted as no default and is interpreted literally. Example. mkPackageOption pkgs \"hello\" { } =&gt; { ...; default = pkgs.hello; defaultText = literalExpression \"pkgs.hello\"; description = \"The hello package to use.\"; type = package; } mkPackageOption pkgs \"GHC\" { default = [ \"ghc\" ]; example = \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; } =&gt; { ...; default = pkgs.ghc; defaultText = literalExpression \"pkgs.ghc\"; description = \"The GHC package to use.\"; example = literalExpression \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\"; type = package; } mkPackageOption pkgs [ \"python3Packages\" \"pytorch\" ] { extraDescription = \"This is an example and doesn't actually do anything.\"; } =&gt; { ...; default = pkgs.python3Packages.pytorch; defaultText = literalExpression \"pkgs.python3Packages.pytorch\"; description = \"The pytorch package to use. This is an example and doesn't actually do anything.\"; type = package; } mkPackageOption pkgs \"nushell\" { nullable = true; } =&gt; { ...; default = pkgs.nushell; defaultText = literalExpression \"pkgs.nushell\"; description = \"The nushell package to use.\"; type = nullOr package; } mkPackageOption pkgs \"coreutils\" { default = null; } =&gt; { ...; description = \"The coreutils package to use.\"; type = package; } mkPackageOption pkgs \"dbus\" { nullable = true; default = null; } =&gt; { ...; default = null; description = \"The dbus package to use.\"; type = nullOr package; } mkPackageOption pkgs.javaPackages \"OpenJFX\" { default = \"openjfx20\"; pkgsText = \"pkgs.javaPackages\"; } =&gt; { ...; default = pkgs.javaPackages.openjfx20; defaultText = literalExpression \"pkgs.javaPackages.openjfx20\"; description = \"The OpenJFX package to use.\"; type = package; } Type. mkPackageOption :: pkgs -&gt; (string|[string]) -&gt; { nullable? :: bool, default? :: string|[string], example? :: null|string|[string], extraDescription? :: string, pkgsText? :: string } -&gt; option Arguments. [pkgs] Package set (an instantiation of nixpkgs such as pkgs in modules or another package set). [name] Name for the package, shown in option description. Edit source. Noogle also knows. Aliases. lib.mkPackageOption.",
    "raw_url": "/f/lib/options/mkPackageOption.html",
    "excerpt": "lib.options.mkPackageOption. Creates an Option attribute set for an option that specifies the package a module should use for some purpose. The package is specified in the third argument under default",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/mergeDefaultOption.html",
    "content": "lib.options.mergeDefaultOption. Edit source. Noogle also knows. Aliases. lib.mergeDefaultOption.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.mergeDefaultOption"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.mergeDefaultOption. Edit source. Noogle also knows. Aliases. lib.mergeDefaultOption.",
    "raw_url": "/f/lib/options/mergeDefaultOption.html",
    "excerpt": "lib.options.mergeDefaultOption. Edit source. Noogle also knows. Aliases. lib.mergeDefaultOption.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/mkSinkUndeclaredOptions.html",
    "content": "lib.options.mkSinkUndeclaredOptions. This option accepts anything, but it does not produce any result. This is useful for sharing a module across different module sets without having to implement similar features as long as the values of the options are not accessed. Arguments. [attrs] Edit source. Noogle also knows. Aliases. lib.mkSinkUndeclaredOptions.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.mkSinkUndeclaredOptions"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.mkSinkUndeclaredOptions. This option accepts anything, but it does not produce any result. This is useful for sharing a module across different module sets without having to implement similar features as long as the values of the options are not accessed. Arguments. [attrs] Edit source. Noogle also knows. Aliases. lib.mkSinkUndeclaredOptions.",
    "raw_url": "/f/lib/options/mkSinkUndeclaredOptions.html",
    "excerpt": "lib.options.mkSinkUndeclaredOptions. This option accepts anything, but it does not produce any result. This is useful for sharing a module across different module sets without having to implement similar features as",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/isOption.html",
    "content": "lib.options.isOption. Returns true when the given argument is an option. Example. isOption 1 // => false isOption (mkOption {}) // => true Type. isOption :: a -> bool Edit source. Noogle also knows. Aliases. lib.isOption.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.isOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.isOption. Returns true when the given argument is an option. Example. isOption 1 // =&gt; false isOption (mkOption {}) // =&gt; true Type. isOption :: a -&gt; bool Edit source. Noogle also knows. Aliases. lib.isOption.",
    "raw_url": "/f/lib/options/isOption.html",
    "excerpt": "lib.options.isOption. Returns true when the given argument is an option. Example. isOption 1 // =&gt; false isOption (mkOption {}) // =&gt; true Type. isOption :: a -&gt; bool Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/mdDoc.html",
    "content": "lib.options.mdDoc. Transition marker for documentation that's already migrated to markdown syntax. This is a no-op and no longer needed. Edit source. Noogle also knows. Aliases. lib.mdDoc.",
    "word_count": 26,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.mdDoc"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.mdDoc. Transition marker for documentation that's already migrated to markdown syntax. This is a no-op and no longer needed. Edit source. Noogle also knows. Aliases. lib.mdDoc.",
    "raw_url": "/f/lib/options/mdDoc.html",
    "excerpt": "lib.options.mdDoc. Transition marker for documentation that's already migrated to markdown syntax. This is a no-op and no longer needed. Edit source. Noogle also knows. Aliases. lib.mdDoc.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/showOption.html",
    "content": "lib.options.showOption. Convert an option, described as a list of the option parts to a human-readable version. Example. (showOption [\"foo\" \"bar\" \"baz\"]) == \"foo.bar.baz\" (showOption [\"foo\" \"bar.baz\" \"tux\"]) == \"foo.\\\"bar.baz\\\".tux\" (showOption [\"windowManager\" \"2bwm\" \"enable\"]) == \"windowManager.\\\"2bwm\\\".enable\" Placeholders will not be quoted as they are not actual values: (showOption [\"foo\" \"*\" \"bar\"]) == \"foo.*.bar\" (showOption [\"foo\" \"<name>\" \"bar\"]) == \"foo.<name>.bar\" Arguments. [parts] Edit source. Noogle also knows. Aliases. lib.showOption.",
    "word_count": 67,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.showOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 58
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.showOption. Convert an option, described as a list of the option parts to a human-readable version. Example. (showOption [\"foo\" \"bar\" \"baz\"]) == \"foo.bar.baz\" (showOption [\"foo\" \"bar.baz\" \"tux\"]) == \"foo.\\\"bar.baz\\\".tux\" (showOption [\"windowManager\" \"2bwm\" \"enable\"]) == \"windowManager.\\\"2bwm\\\".enable\" Placeholders will not be quoted as they are not actual values: (showOption [\"foo\" \"*\" \"bar\"]) == \"foo.*.bar\" (showOption [\"foo\" \"&lt;name&gt;\" \"bar\"]) == \"foo.&lt;name&gt;.bar\" Arguments. [parts] Edit source. Noogle also knows. Aliases. lib.showOption.",
    "raw_url": "/f/lib/options/showOption.html",
    "excerpt": "lib.options.showOption. Convert an option, described as a list of the option parts to a human-readable version. Example. (showOption [\"foo\" \"bar\" \"baz\"]) == \"foo.bar.baz\" (showOption [\"foo\" \"bar.baz\" \"tux\"]) == \"foo.\\\"bar.baz\\\".tux\" (showOption",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/getValues.html",
    "content": "lib.options.getValues. Extracts values of all \"value\" keys of the given list. Example. getValues [ { value = 1; } { value = 2; } ] // => [ 1 2 ] getValues [ ] // => [ ] Type. getValues :: [ { value :: a; } ] -> [a] Edit source. Noogle also knows. Aliases. lib.getValues.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.getValues"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 38
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.getValues. Extracts values of all \"value\" keys of the given list. Example. getValues [ { value = 1; } { value = 2; } ] // =&gt; [ 1 2 ] getValues [ ] // =&gt; [ ] Type. getValues :: [ { value :: a; } ] -&gt; [a] Edit source. Noogle also knows. Aliases. lib.getValues.",
    "raw_url": "/f/lib/options/getValues.html",
    "excerpt": "lib.options.getValues. Extracts values of all \"value\" keys of the given list. Example. getValues [ { value = 1; } { value = 2; } ] // =&gt; [ 1 2",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/showFiles.html",
    "content": "lib.options.showFiles. Edit source. Noogle also knows. Aliases. lib.showFiles.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.showFiles"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.showFiles. Edit source. Noogle also knows. Aliases. lib.showFiles.",
    "raw_url": "/f/lib/options/showFiles.html",
    "excerpt": "lib.options.showFiles. Edit source. Noogle also knows. Aliases. lib.showFiles.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/scrubOptionValue.html",
    "content": "lib.options.scrubOptionValue. This function recursively removes all derivation attributes from x except for the name attribute. This is to make the generation of options.xml much more efficient: the XML representation of derivations is very large (on the order of megabytes) and is not actually used by the manual generator. This function was made obsolete by renderOptionValue and is kept for compatibility with out-of-tree code. Arguments. [x] Edit source. Noogle also knows. Aliases. lib.scrubOptionValue.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.scrubOptionValue"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 63
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.scrubOptionValue. This function recursively removes all derivation attributes from x except for the name attribute. This is to make the generation of options.xml much more efficient: the XML representation of derivations is very large (on the order of megabytes) and is not actually used by the manual generator. This function was made obsolete by renderOptionValue and is kept for compatibility with out-of-tree code. Arguments. [x] Edit source. Noogle also knows. Aliases. lib.scrubOptionValue.",
    "raw_url": "/f/lib/options/scrubOptionValue.html",
    "excerpt": "lib.options.scrubOptionValue. This function recursively removes all derivation attributes from x except for the name attribute. This is to make the generation of options.xml much more efficient: the XML representation of",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/getFiles.html",
    "content": "lib.options.getFiles. Extracts values of all \"file\" keys of the given list. Example. getFiles [ { file = \"file1\"; } { file = \"file2\"; } ] // => [ \"file1\" \"file2\" ] getFiles [ ] // => [ ] Type. getFiles :: [ { file :: a; } ] -> [a] Edit source. Noogle also knows. Aliases. lib.getFiles.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.getFiles"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 38
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.getFiles. Extracts values of all \"file\" keys of the given list. Example. getFiles [ { file = \"file1\"; } { file = \"file2\"; } ] // =&gt; [ \"file1\" \"file2\" ] getFiles [ ] // =&gt; [ ] Type. getFiles :: [ { file :: a; } ] -&gt; [a] Edit source. Noogle also knows. Aliases. lib.getFiles.",
    "raw_url": "/f/lib/options/getFiles.html",
    "excerpt": "lib.options.getFiles. Extracts values of all \"file\" keys of the given list. Example. getFiles [ { file = \"file1\"; } { file = \"file2\"; } ] // =&gt; [ \"file1\" \"file2\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/literalExpression.html",
    "content": "lib.options.literalExpression. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values, e.g. functions, or values that depend on other values or packages. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.literalExpression.",
    "word_count": 50,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.literalExpression"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.literalExpression. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values, e.g. functions, or values that depend on other values or packages. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.literalExpression.",
    "raw_url": "/f/lib/options/literalExpression.html",
    "excerpt": "lib.options.literalExpression. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values,",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/showDefs.html",
    "content": "lib.options.showDefs. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.showDefs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.showDefs. Edit source.",
    "raw_url": "/f/lib/options/showDefs.html",
    "excerpt": "lib.options.showDefs. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/literalMD.html",
    "content": "lib.options.literalMD. For use in the defaultText and example option attributes. Causes the given MD text to be inserted verbatim in the documentation, for when a literalExpression would be too hard to read. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.literalMD.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.literalMD"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.literalMD. For use in the defaultText and example option attributes. Causes the given MD text to be inserted verbatim in the documentation, for when a literalExpression would be too hard to read. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.literalMD.",
    "raw_url": "/f/lib/options/literalMD.html",
    "excerpt": "lib.options.literalMD. For use in the defaultText and example option attributes. Causes the given MD text to be inserted verbatim in the documentation, for when a literalExpression would be too hard",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/literalExample.html",
    "content": "lib.options.literalExample. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values, e.g. functions, or values that depend on other values or packages. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.literalExample.",
    "word_count": 50,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.literalExample"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.literalExample. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values, e.g. functions, or values that depend on other values or packages. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.literalExample.",
    "raw_url": "/f/lib/options/literalExample.html",
    "excerpt": "lib.options.literalExample. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values,",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/showOptionWithDefLocs.html",
    "content": "lib.options.showOptionWithDefLocs. Edit source. Noogle also knows. Aliases. lib.showOptionWithDefLocs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.showOptionWithDefLocs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.showOptionWithDefLocs. Edit source. Noogle also knows. Aliases. lib.showOptionWithDefLocs.",
    "raw_url": "/f/lib/options/showOptionWithDefLocs.html",
    "excerpt": "lib.options.showOptionWithDefLocs. Edit source. Noogle also knows. Aliases. lib.showOptionWithDefLocs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/mergeEqualOption.html",
    "content": "lib.options.mergeEqualOption. \"Merge\" option definitions by checking that they all have the same value. Arguments. [loc] [defs] Edit source. Noogle also knows. Aliases. lib.mergeEqualOption.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.mergeEqualOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 13
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.mergeEqualOption. \"Merge\" option definitions by checking that they all have the same value. Arguments. [loc] [defs] Edit source. Noogle also knows. Aliases. lib.mergeEqualOption.",
    "raw_url": "/f/lib/options/mergeEqualOption.html",
    "excerpt": "lib.options.mergeEqualOption. \"Merge\" option definitions by checking that they all have the same value. Arguments. [loc] [defs] Edit source. Noogle also knows. Aliases. lib.mergeEqualOption.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/optionAttrSetToDocList'.html",
    "content": "lib.options.optionAttrSetToDocList' (Prime). Edit source. Noogle also knows. Aliases. lib.optionAttrSetToDocList'",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.optionAttrSetToDocList' (Prime)"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.optionAttrSetToDocList' (Prime). Edit source. Noogle also knows. Aliases. lib.optionAttrSetToDocList'",
    "raw_url": "/f/lib/options/optionAttrSetToDocList'.html",
    "excerpt": "lib.options.optionAttrSetToDocList' (Prime). Edit source. Noogle also knows. Aliases. lib.optionAttrSetToDocList'",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/mkEnableOption.html",
    "content": "lib.options.mkEnableOption. Creates an Option attribute set for a boolean value option i.e an option to be toggled on or off: Example. mkEnableOption \"foo\" => { _type = \"option\"; default = false; description = \"Whether to enable foo.\"; example = true; type = { ... }; } Arguments. [name] Name for the created option. Edit source. Noogle also knows. Aliases. lib.mkEnableOption.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.mkEnableOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 46
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.mkEnableOption. Creates an Option attribute set for a boolean value option i.e an option to be toggled on or off: Example. mkEnableOption \"foo\" =&gt; { _type = \"option\"; default = false; description = \"Whether to enable foo.\"; example = true; type = { ... }; } Arguments. [name] Name for the created option. Edit source. Noogle also knows. Aliases. lib.mkEnableOption.",
    "raw_url": "/f/lib/options/mkEnableOption.html",
    "excerpt": "lib.options.mkEnableOption. Creates an Option attribute set for a boolean value option i.e an option to be toggled on or off: Example. mkEnableOption \"foo\" =&gt; { _type = \"option\"; default =",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/mkOption.html",
    "content": "lib.options.mkOption. Creates an Option attribute set. mkOption accepts an attribute set with the following keys: All keys default to null when not given. Example. mkOption { } // => { _type = \"option\"; } mkOption { default = \"foo\"; } // => { _type = \"option\"; default = \"foo\"; } Arguments. Edit source. Noogle also knows. Aliases. lib.mkOption.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.mkOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.mkOption. Creates an Option attribute set. mkOption accepts an attribute set with the following keys: All keys default to null when not given. Example. mkOption { } // =&gt; { _type = \"option\"; } mkOption { default = \"foo\"; } // =&gt; { _type = \"option\"; default = \"foo\"; } Arguments. Edit source. Noogle also knows. Aliases. lib.mkOption.",
    "raw_url": "/f/lib/options/mkOption.html",
    "excerpt": "lib.options.mkOption. Creates an Option attribute set. mkOption accepts an attribute set with the following keys: All keys default to null when not given. Example. mkOption { } // =&gt; {",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/mergeUniqueOption.html",
    "content": "lib.options.mergeUniqueOption. Edit source. Noogle also knows. Aliases. lib.mergeUniqueOption.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.mergeUniqueOption"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.mergeUniqueOption. Edit source. Noogle also knows. Aliases. lib.mergeUniqueOption.",
    "raw_url": "/f/lib/options/mergeUniqueOption.html",
    "excerpt": "lib.options.mergeUniqueOption. Edit source. Noogle also knows. Aliases. lib.mergeUniqueOption.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/optionAttrSetToDocList.html",
    "content": "lib.options.optionAttrSetToDocList. Noogle also knows. Aliases. lib.optionAttrSetToDocList.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.optionAttrSetToDocList"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.optionAttrSetToDocList. Noogle also knows. Aliases. lib.optionAttrSetToDocList.",
    "raw_url": "/f/lib/options/optionAttrSetToDocList.html",
    "excerpt": "lib.options.optionAttrSetToDocList. Noogle also knows. Aliases. lib.optionAttrSetToDocList.",
    "sub_results": []
  },
  {
    "url": "/f/lib/options/mkPackageOptionMD.html",
    "content": "lib.options.mkPackageOptionMD. Alias of mkPackageOption. Previously used to create options with markdown documentation, which is no longer required. Edit source. Noogle also knows. Aliases. lib.mkPackageOptionMD.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.options.mkPackageOptionMD"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.options.mkPackageOptionMD. Alias of mkPackageOption. Previously used to create options with markdown documentation, which is no longer required. Edit source. Noogle also knows. Aliases. lib.mkPackageOptionMD.",
    "raw_url": "/f/lib/options/mkPackageOptionMD.html",
    "excerpt": "lib.options.mkPackageOptionMD. Alias of mkPackageOption. Previously used to create options with markdown documentation, which is no longer required. Edit source. Noogle also knows. Aliases. lib.mkPackageOptionMD.",
    "sub_results": []
  },
  {
    "url": "/f/lib/hasSuffix.html",
    "content": "lib.hasSuffix. Determine whether a string has given suffix. Example. hasSuffix \"foo\" \"foobar\" => false hasSuffix \"foo\" \"barfoo\" => true Type. hasSuffix :: string -> string -> bool Arguments. [suffix] Suffix to check for. [content] Input string. Edit source. Noogle also knows. Aliases. lib.strings.hasSuffix.",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.hasSuffix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 8
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.hasSuffix. Determine whether a string has given suffix. Example. hasSuffix \"foo\" \"foobar\" =&gt; false hasSuffix \"foo\" \"barfoo\" =&gt; true Type. hasSuffix :: string -&gt; string -&gt; bool Arguments. [suffix] Suffix to check for. [content] Input string. Edit source. Noogle also knows. Aliases. lib.strings.hasSuffix.",
    "raw_url": "/f/lib/hasSuffix.html",
    "excerpt": "lib.hasSuffix. Determine whether a string has given suffix. Example. hasSuffix \"foo\" \"foobar\" =&gt; false hasSuffix \"foo\" \"barfoo\" =&gt; true Type. hasSuffix :: string -&gt; string -&gt; bool Arguments. [suffix] Suffix",
    "sub_results": []
  },
  {
    "url": "/f/lib/zipAttrsWith.html",
    "content": "lib.zipAttrsWith Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names. Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names. Example. zipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet Edit source. Noogle also knows. Aliases. builtins.zipAttrsWith. lib.zip. lib.attrsets.zip. lib.attrsets.zipAttrsWith.",
    "word_count": 118,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.zipAttrsWith Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 68
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 92
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.zipAttrsWith Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names. Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names. Example. zipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrsWith :: (String -&gt; [ Any ] -&gt; Any) -&gt; [ AttrSet ] -&gt; AttrSet Edit source. Noogle also knows. Aliases. builtins.zipAttrsWith. lib.zip. lib.attrsets.zip. lib.attrsets.zipAttrsWith.",
    "raw_url": "/f/lib/zipAttrsWith.html",
    "excerpt": "lib.zipAttrsWith Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names.",
    "sub_results": []
  },
  {
    "url": "/f/lib/makeBinPath.html",
    "content": "lib.makeBinPath. Construct a binary search path (such as $PATH) containing the binaries for a set of packages. Example. makeBinPath [\"/root\" \"/usr\" \"/usr/local\"] => \"/root/bin:/usr/bin:/usr/local/bin\" Edit source. Noogle also knows. Aliases. lib.strings.makeBinPath.",
    "word_count": 31,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.makeBinPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.makeBinPath. Construct a binary search path (such as $PATH) containing the binaries for a set of packages. Example. makeBinPath [\"/root\" \"/usr\" \"/usr/local\"] =&gt; \"/root/bin:/usr/bin:/usr/local/bin\" Edit source. Noogle also knows. Aliases. lib.strings.makeBinPath.",
    "raw_url": "/f/lib/makeBinPath.html",
    "excerpt": "lib.makeBinPath. Construct a binary search path (such as $PATH) containing the binaries for a set of packages. Example. makeBinPath [\"/root\" \"/usr\" \"/usr/local\"] =&gt; \"/root/bin:/usr/bin:/usr/local/bin\" Edit source. Noogle also knows. Aliases.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mapAttrsToList.html",
    "content": "lib.mapAttrsToList. Call a function for each attribute in the given set and return the result in a list. Example. mapAttrsToList (name: value: name + value) { x = \"a\"; y = \"b\"; } => [ \"xa\" \"yb\" ] Type. mapAttrsToList :: (String -> a -> b) -> AttrSet -> [b] Arguments. [f] A function, given an attribute's name and value, returns a new value. [attrs] Attribute set to map over. Edit source. Noogle also knows. Aliases. lib.attrsets.mapAttrsToList.",
    "word_count": 77,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mapAttrsToList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 38
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mapAttrsToList. Call a function for each attribute in the given set and return the result in a list. Example. mapAttrsToList (name: value: name + value) { x = \"a\"; y = \"b\"; } =&gt; [ \"xa\" \"yb\" ] Type. mapAttrsToList :: (String -&gt; a -&gt; b) -&gt; AttrSet -&gt; [b] Arguments. [f] A function, given an attribute's name and value, returns a new value. [attrs] Attribute set to map over. Edit source. Noogle also knows. Aliases. lib.attrsets.mapAttrsToList.",
    "raw_url": "/f/lib/mapAttrsToList.html",
    "excerpt": "lib.mapAttrsToList. Call a function for each attribute in the given set and return the result in a list. Example. mapAttrsToList (name: value: name + value) { x = \"a\"; y",
    "sub_results": []
  },
  {
    "url": "/f/lib/traceValSeqN.html",
    "content": "lib.traceValSeqN. A combination of traceVal and traceSeqN. Edit source. Noogle also knows. Aliases. lib.debug.traceValSeqN.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.traceValSeqN"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.traceValSeqN. A combination of traceVal and traceSeqN. Edit source. Noogle also knows. Aliases. lib.debug.traceValSeqN.",
    "raw_url": "/f/lib/traceValSeqN.html",
    "excerpt": "lib.traceValSeqN. A combination of traceVal and traceSeqN. Edit source. Noogle also knows. Aliases. lib.debug.traceValSeqN.",
    "sub_results": []
  },
  {
    "url": "/f/lib/escapeShellArgs.html",
    "content": "lib.escapeShellArgs. Quote all arguments to be safely passed to the Bourne shell. Example. escapeShellArgs [\"one\" \"two three\" \"four'five\"] => \"'one' 'two three' 'four'\\\\''five'\" Type. escapeShellArgs :: [string] -> string Edit source. Noogle also knows. Aliases. lib.strings.escapeShellArgs.",
    "word_count": 36,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.escapeShellArgs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.escapeShellArgs. Quote all arguments to be safely passed to the Bourne shell. Example. escapeShellArgs [\"one\" \"two three\" \"four'five\"] =&gt; \"'one' 'two three' 'four'\\\\''five'\" Type. escapeShellArgs :: [string] -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.escapeShellArgs.",
    "raw_url": "/f/lib/escapeShellArgs.html",
    "excerpt": "lib.escapeShellArgs. Quote all arguments to be safely passed to the Bourne shell. Example. escapeShellArgs [\"one\" \"two three\" \"four'five\"] =&gt; \"'one' 'two three' 'four'\\\\''five'\" Type. escapeShellArgs :: [string] -&gt; string Edit",
    "sub_results": []
  },
  {
    "url": "/f/lib/defaultTypeMerge.html",
    "content": "lib.defaultTypeMerge. Edit source. Noogle also knows. Aliases. lib.types.defaultTypeMerge.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.defaultTypeMerge"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.defaultTypeMerge. Edit source. Noogle also knows. Aliases. lib.types.defaultTypeMerge.",
    "raw_url": "/f/lib/defaultTypeMerge.html",
    "excerpt": "lib.defaultTypeMerge. Edit source. Noogle also knows. Aliases. lib.types.defaultTypeMerge.",
    "sub_results": []
  },
  {
    "url": "/f/lib/seq.html",
    "content": "lib.seq Primop. Takes 2 arguments. e1, e2. Evaluate e1, then evaluate and return e2. This ensures that a computation is strict in the value of e1. Noogle also knows. Aliases. builtins.seq. lib.trivial.seq.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.seq Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.seq Primop. Takes 2 arguments. e1, e2. Evaluate e1, then evaluate and return e2. This ensures that a computation is strict in the value of e1. Noogle also knows. Aliases. builtins.seq. lib.trivial.seq.",
    "raw_url": "/f/lib/seq.html",
    "excerpt": "lib.seq Primop. Takes 2 arguments. e1, e2. Evaluate e1, then evaluate and return e2. This ensures that a computation is strict in the value of e1. Noogle also knows. Aliases.",
    "sub_results": []
  },
  {
    "url": "/f/lib/subtractLists.html",
    "content": "lib.subtractLists. Subtracts list 'e' from another list. O(nm) complexity. Example. subtractLists [ 3 2 ] [ 1 2 3 4 5 3 ] => [ 1 4 5 ] Arguments. [e] Edit source. Noogle also knows. Aliases. lib.lists.subtractLists.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.subtractLists"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.subtractLists. Subtracts list 'e' from another list. O(nm) complexity. Example. subtractLists [ 3 2 ] [ 1 2 3 4 5 3 ] =&gt; [ 1 4 5 ] Arguments. [e] Edit source. Noogle also knows. Aliases. lib.lists.subtractLists.",
    "raw_url": "/f/lib/subtractLists.html",
    "excerpt": "lib.subtractLists. Subtracts list 'e' from another list. O(nm) complexity. Example. subtractLists [ 3 2 ] [ 1 2 3 4 5 3 ] =&gt; [ 1 4 5 ] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/fix'.html",
    "content": "lib.fix' (Prime). A variant of fix that records the original recursive attribute set in the result, in an attribute named __unfix__. This is useful in combination with the extends function to implement deep overriding. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.fixedPoints.fix'",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fix' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 34
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fix' (Prime). A variant of fix that records the original recursive attribute set in the result, in an attribute named __unfix__. This is useful in combination with the extends function to implement deep overriding. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.fixedPoints.fix'",
    "raw_url": "/f/lib/fix'.html",
    "excerpt": "lib.fix' (Prime). A variant of fix that records the original recursive attribute set in the result, in an attribute named __unfix__. This is useful in combination with the extends function",
    "sub_results": []
  },
  {
    "url": "/f/lib/closePropagation.html",
    "content": "lib.closePropagation. Edit source. Noogle also knows. Aliases. lib.misc.closePropagation.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.closePropagation"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.closePropagation. Edit source. Noogle also knows. Aliases. lib.misc.closePropagation.",
    "raw_url": "/f/lib/closePropagation.html",
    "excerpt": "lib.closePropagation. Edit source. Noogle also knows. Aliases. lib.misc.closePropagation.",
    "sub_results": []
  },
  {
    "url": "/f/lib/zipWithNames.html",
    "content": "lib.zipWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; } Type. zipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet Arguments. [names] List of attribute names to zip. [f] A function, accepts an attribute name, all the values, and returns a combined value. [sets] List of values from the list of attribute sets. Edit source. Noogle also knows. Aliases. lib.attrsets.zipWithNames.",
    "word_count": 96,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.zipWithNames"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 36
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 56
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.zipWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; } Type. zipAttrsWithNames :: [ String ] -&gt; (String -&gt; [ Any ] -&gt; Any) -&gt; [ AttrSet ] -&gt; AttrSet Arguments. [names] List of attribute names to zip. [f] A function, accepts an attribute name, all the values, and returns a combined value. [sets] List of values from the list of attribute sets. Edit source. Noogle also knows. Aliases. lib.attrsets.zipWithNames.",
    "raw_url": "/f/lib/zipWithNames.html",
    "excerpt": "lib.zipWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/testAllTrue.html",
    "content": "lib.debug.testAllTrue. Create a test assuming that list elements are true. Example. { testX = allTrue [ true ]; } Arguments. [expr] Edit source. Noogle also knows. Aliases. lib.testAllTrue.",
    "word_count": 28,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.testAllTrue"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 19
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.testAllTrue. Create a test assuming that list elements are true. Example. { testX = allTrue [ true ]; } Arguments. [expr] Edit source. Noogle also knows. Aliases. lib.testAllTrue.",
    "raw_url": "/f/lib/debug/testAllTrue.html",
    "excerpt": "lib.debug.testAllTrue. Create a test assuming that list elements are true. Example. { testX = allTrue [ true ]; } Arguments. [expr] Edit source. Noogle also knows. Aliases. lib.testAllTrue.",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/traceValSeqN.html",
    "content": "lib.debug.traceValSeqN. A combination of traceVal and traceSeqN. Edit source. Noogle also knows. Aliases. lib.traceValSeqN.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.traceValSeqN"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.traceValSeqN. A combination of traceVal and traceSeqN. Edit source. Noogle also knows. Aliases. lib.traceValSeqN.",
    "raw_url": "/f/lib/debug/traceValSeqN.html",
    "excerpt": "lib.debug.traceValSeqN. A combination of traceVal and traceSeqN. Edit source. Noogle also knows. Aliases. lib.traceValSeqN.",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/traceValFn.html",
    "content": "lib.debug.traceValFn. Trace the supplied value after applying a function to it, and return the original value. Example. traceValFn (v: \"mystring ${v}\") \"foo\" trace: mystring foo => \"foo\" Type. traceValFn :: (a -> b) -> a -> a Arguments. [f] Function to apply. [x] Value to trace and return. Edit source. Noogle also knows. Aliases. lib.traceValFn.",
    "word_count": 55,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.traceValFn"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 27
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 37
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.traceValFn. Trace the supplied value after applying a function to it, and return the original value. Example. traceValFn (v: \"mystring ${v}\") \"foo\" trace: mystring foo =&gt; \"foo\" Type. traceValFn :: (a -&gt; b) -&gt; a -&gt; a Arguments. [f] Function to apply. [x] Value to trace and return. Edit source. Noogle also knows. Aliases. lib.traceValFn.",
    "raw_url": "/f/lib/debug/traceValFn.html",
    "excerpt": "lib.debug.traceValFn. Trace the supplied value after applying a function to it, and return the original value. Example. traceValFn (v: \"mystring ${v}\") \"foo\" trace: mystring foo =&gt; \"foo\" Type. traceValFn ::",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/traceSeqN.html",
    "content": "lib.debug.traceSeqN. Like traceSeq, but only evaluate down to depth n. This is very useful because lots of traceSeq usages lead to an infinite recursion. Example. traceSeqN 2 { a.b.c = 3; } null trace: { a = { b = {…}; }; } => null Type. traceSeqN :: Int -> a -> b -> b Arguments. [depth] [x] [y] Edit source. Noogle also knows. Aliases. lib.traceSeqN.",
    "word_count": 66,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.traceSeqN"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 45
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.traceSeqN. Like traceSeq, but only evaluate down to depth n. This is very useful because lots of traceSeq usages lead to an infinite recursion. Example. traceSeqN 2 { a.b.c = 3; } null trace: { a = { b = {…}; }; } =&gt; null Type. traceSeqN :: Int -&gt; a -&gt; b -&gt; b Arguments. [depth] [x] [y] Edit source. Noogle also knows. Aliases. lib.traceSeqN.",
    "raw_url": "/f/lib/debug/traceSeqN.html",
    "excerpt": "lib.debug.traceSeqN. Like traceSeq, but only evaluate down to depth n. This is very useful because lots of traceSeq usages lead to an infinite recursion. Example. traceSeqN 2 { a.b.c =",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/traceValSeq.html",
    "content": "lib.debug.traceValSeq. A combination of traceVal and traceSeq. Edit source. Noogle also knows. Aliases. lib.traceValSeq.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.traceValSeq"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.traceValSeq. A combination of traceVal and traceSeq. Edit source. Noogle also knows. Aliases. lib.traceValSeq.",
    "raw_url": "/f/lib/debug/traceValSeq.html",
    "excerpt": "lib.debug.traceValSeq. A combination of traceVal and traceSeq. Edit source. Noogle also knows. Aliases. lib.traceValSeq.",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/runTests.html",
    "content": "lib.debug.runTests. Evaluates a set of tests. A test is an attribute set {expr, expected}, denoting an expression and its expected result. The result is a list of failed tests, each represented as {name, expected, result}, expected. What was passed as expected. result. The actual result of the test Used for regression testing of the functions in lib; see tests.nix for more examples. Important: Only attributes that start with test are executed. If you want to run only a subset of the tests add the attribute tests = [\"testName\"]; Example. runTests { testAndOk = { expr = lib.and true false; expected = false; }; testAndFail = { expr = lib.and true false; expected = true; }; } -> [ { name = \"testAndFail\"; expected = true; result = false; } ] Type. runTests :: { tests = [ String ]; ${testName} :: { expr :: a; expected :: a; }; } -> [ { name :: String; expected :: a; result :: a; } ] Arguments. [tests] Tests to run. Edit source. Noogle also knows. Aliases. lib.runTests.",
    "word_count": 176,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.runTests"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 88
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 130
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 164
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.runTests. Evaluates a set of tests. A test is an attribute set {expr, expected}, denoting an expression and its expected result. The result is a list of failed tests, each represented as {name, expected, result}, expected. What was passed as expected. result. The actual result of the test Used for regression testing of the functions in lib; see tests.nix for more examples. Important: Only attributes that start with test are executed. If you want to run only a subset of the tests add the attribute tests = [\"testName\"]; Example. runTests { testAndOk = { expr = lib.and true false; expected = false; }; testAndFail = { expr = lib.and true false; expected = true; }; } -&gt; [ { name = \"testAndFail\"; expected = true; result = false; } ] Type. runTests :: { tests = [ String ]; ${testName} :: { expr :: a; expected :: a; }; } -&gt; [ { name :: String; expected :: a; result :: a; } ] Arguments. [tests] Tests to run. Edit source. Noogle also knows. Aliases. lib.runTests.",
    "raw_url": "/f/lib/debug/runTests.html",
    "excerpt": "lib.debug.runTests. Evaluates a set of tests. A test is an attribute set {expr, expected}, denoting an expression and its expected result. The result is a list of failed tests, each",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/traceSeq.html",
    "content": "lib.debug.traceSeq. builtins.trace, but the value is builtins.deepSeqed first. Example. trace { a.b.c = 3; } null trace: { a = <CODE>; } => null traceSeq { a.b.c = 3; } null trace: { a = { b = { c = 3; }; }; } => null Type. traceSeq :: a -> b -> b Arguments. [x] The value to trace. [y] The value to return. Edit source. Noogle also knows. Aliases. lib.traceSeq.",
    "word_count": 73,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.traceSeq"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 8
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.traceSeq. builtins.trace, but the value is builtins.deepSeqed first. Example. trace { a.b.c = 3; } null trace: { a = &lt;CODE&gt;; } =&gt; null traceSeq { a.b.c = 3; } null trace: { a = { b = { c = 3; }; }; } =&gt; null Type. traceSeq :: a -&gt; b -&gt; b Arguments. [x] The value to trace. [y] The value to return. Edit source. Noogle also knows. Aliases. lib.traceSeq.",
    "raw_url": "/f/lib/debug/traceSeq.html",
    "excerpt": "lib.debug.traceSeq. builtins.trace, but the value is builtins.deepSeqed first. Example. trace { a.b.c = 3; } null trace: { a = &lt;CODE&gt;; } =&gt; null traceSeq { a.b.c = 3; }",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/traceVal.html",
    "content": "lib.debug.traceVal. Trace the supplied value and return it. Example. traceVal 42 # trace: 42 => 42 Type. traceVal :: a -> a Edit source. Noogle also knows. Aliases. lib.fileset.traceVal. lib.traceVal.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.traceVal"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 8
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 16
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.traceVal. Trace the supplied value and return it. Example. traceVal 42 # trace: 42 =&gt; 42 Type. traceVal :: a -&gt; a Edit source. Noogle also knows. Aliases. lib.fileset.traceVal. lib.traceVal.",
    "raw_url": "/f/lib/debug/traceVal.html",
    "excerpt": "lib.debug.traceVal. Trace the supplied value and return it. Example. traceVal 42 # trace: 42 =&gt; 42 Type. traceVal :: a -&gt; a Edit source. Noogle also knows. Aliases. lib.fileset.traceVal. lib.traceVal.",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/traceIf.html",
    "content": "lib.debug.traceIf. Conditionally trace the supplied message, based on a predicate. Example. traceIf true \"hello\" 3 trace: hello => 3 Type. traceIf :: bool -> string -> a -> a Arguments. [pred] Predicate to check. [msg] Message that should be traced. [x] Value to return. Edit source. Noogle also knows. Aliases. lib.traceIf.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.traceIf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.traceIf. Conditionally trace the supplied message, based on a predicate. Example. traceIf true \"hello\" 3 trace: hello =&gt; 3 Type. traceIf :: bool -&gt; string -&gt; a -&gt; a Arguments. [pred] Predicate to check. [msg] Message that should be traced. [x] Value to return. Edit source. Noogle also knows. Aliases. lib.traceIf.",
    "raw_url": "/f/lib/debug/traceIf.html",
    "excerpt": "lib.debug.traceIf. Conditionally trace the supplied message, based on a predicate. Example. traceIf true \"hello\" 3 trace: hello =&gt; 3 Type. traceIf :: bool -&gt; string -&gt; a -&gt; a Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/traceFnSeqN.html",
    "content": "lib.debug.traceFnSeqN. Trace the input and output of a function f named name, both down to depth. This is useful for adding around a function call, to see the before/after of values as they are transformed. Example. traceFnSeqN 2 \"id\" (x: x) { a.b.c = 3; } trace: { fn = \"id\"; from = { a.b = {…}; }; to = { a.b = {…}; }; } => { a.b.c = 3; } Arguments. [depth] [name] [f] [v] Edit source. Noogle also knows. Aliases. lib.traceFnSeqN.",
    "word_count": 84,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.traceFnSeqN"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 35
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 72
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.traceFnSeqN. Trace the input and output of a function f named name, both down to depth. This is useful for adding around a function call, to see the before/after of values as they are transformed. Example. traceFnSeqN 2 \"id\" (x: x) { a.b.c = 3; } trace: { fn = \"id\"; from = { a.b = {…}; }; to = { a.b = {…}; }; } =&gt; { a.b.c = 3; } Arguments. [depth] [name] [f] [v] Edit source. Noogle also knows. Aliases. lib.traceFnSeqN.",
    "raw_url": "/f/lib/debug/traceFnSeqN.html",
    "excerpt": "lib.debug.traceFnSeqN. Trace the input and output of a function f named name, both down to depth. This is useful for adding around a function call, to see the before/after of",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/traceValSeqFn.html",
    "content": "lib.debug.traceValSeqFn. A combination of traceVal and traceSeq that applies a provided function to the value to be traced after deepSeqing it. Arguments. [f] Function to apply. [v] Value to trace. Edit source. Noogle also knows. Aliases. lib.traceValSeqFn.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.traceValSeqFn"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 21
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.traceValSeqFn. A combination of traceVal and traceSeq that applies a provided function to the value to be traced after deepSeqing it. Arguments. [f] Function to apply. [v] Value to trace. Edit source. Noogle also knows. Aliases. lib.traceValSeqFn.",
    "raw_url": "/f/lib/debug/traceValSeqFn.html",
    "excerpt": "lib.debug.traceValSeqFn. A combination of traceVal and traceSeq that applies a provided function to the value to be traced after deepSeqing it. Arguments. [f] Function to apply. [v] Value to trace.",
    "sub_results": []
  },
  {
    "url": "/f/lib/debug/traceValSeqNFn.html",
    "content": "lib.debug.traceValSeqNFn. A combination of traceVal and traceSeqN that applies a provided function to the value to be traced. Arguments. [f] Function to apply. [depth] [v] Value to trace. Edit source. Noogle also knows. Aliases. lib.traceValSeqNFn.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.debug.traceValSeqNFn"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 18
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.debug.traceValSeqNFn. A combination of traceVal and traceSeqN that applies a provided function to the value to be traced. Arguments. [f] Function to apply. [depth] [v] Value to trace. Edit source. Noogle also knows. Aliases. lib.traceValSeqNFn.",
    "raw_url": "/f/lib/debug/traceValSeqNFn.html",
    "excerpt": "lib.debug.traceValSeqNFn. A combination of traceVal and traceSeqN that applies a provided function to the value to be traced. Arguments. [f] Function to apply. [depth] [v] Value to trace. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkMergedOptionModule.html",
    "content": "lib.mkMergedOptionModule. Return a module that causes a warning to be shown if any of the \"from\" option is defined; the defined values can be used in the \"mergeFn\" to set the \"to\" value. This function can be used to merge multiple options into one that has a different type. \"mergeFn\" takes the module \"config\" as a parameter and must return a value of \"to\" option type. mkMergedOptionModule [ [ \"a\" \"b\" \"c\" ] [ \"d\" \"e\" \"f\" ] ] [ \"x\" \"y\" \"z\" ] (config: let value = p: getAttrFromPath p config; in if (value [ \"a\" \"b\" \"c\" ]) == true then \"foo\" else if (value [ \"d\" \"e\" \"f\" ]) == true then \"bar\" else \"baz\"). options.a.b.c is a removed boolean option. options.d.e.f is a removed boolean option. options.x.y.z is a new str option that combines a.b.c and d.e.f functionality This show a warning if any a.b.c or d.e.f is set, and set the value of x.y.z to the result of the merge function. Arguments. [from] [to] [mergeFn] Edit source. Noogle also knows. Aliases. lib.modules.mkMergedOptionModule.",
    "word_count": 177,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkMergedOptionModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 166
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkMergedOptionModule. Return a module that causes a warning to be shown if any of the \"from\" option is defined; the defined values can be used in the \"mergeFn\" to set the \"to\" value. This function can be used to merge multiple options into one that has a different type. \"mergeFn\" takes the module \"config\" as a parameter and must return a value of \"to\" option type. mkMergedOptionModule [ [ \"a\" \"b\" \"c\" ] [ \"d\" \"e\" \"f\" ] ] [ \"x\" \"y\" \"z\" ] (config: let value = p: getAttrFromPath p config; in if (value [ \"a\" \"b\" \"c\" ]) == true then \"foo\" else if (value [ \"d\" \"e\" \"f\" ]) == true then \"bar\" else \"baz\"). options.a.b.c is a removed boolean option. options.d.e.f is a removed boolean option. options.x.y.z is a new str option that combines a.b.c and d.e.f functionality This show a warning if any a.b.c or d.e.f is set, and set the value of x.y.z to the result of the merge function. Arguments. [from] [to] [mergeFn] Edit source. Noogle also knows. Aliases. lib.modules.mkMergedOptionModule.",
    "raw_url": "/f/lib/mkMergedOptionModule.html",
    "excerpt": "lib.mkMergedOptionModule. Return a module that causes a warning to be shown if any of the \"from\" option is defined; the defined values can be used in the \"mergeFn\" to set",
    "sub_results": []
  },
  {
    "url": "/f/lib/take.html",
    "content": "lib.take. Return the first (at most) N elements of a list. Example. take 2 [ \"a\" \"b\" \"c\" \"d\" ] => [ \"a\" \"b\" ] take 2 [ ] => [ ] Type. take :: int -> [a] -> [a] Arguments. [count] Number of elements to take. Edit source. Noogle also knows. Aliases. lib.lists.take.",
    "word_count": 54,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.take"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.take. Return the first (at most) N elements of a list. Example. take 2 [ \"a\" \"b\" \"c\" \"d\" ] =&gt; [ \"a\" \"b\" ] take 2 [ ] =&gt; [ ] Type. take :: int -&gt; [a] -&gt; [a] Arguments. [count] Number of elements to take. Edit source. Noogle also knows. Aliases. lib.lists.take.",
    "raw_url": "/f/lib/take.html",
    "excerpt": "lib.take. Return the first (at most) N elements of a list. Example. take 2 [ \"a\" \"b\" \"c\" \"d\" ] =&gt; [ \"a\" \"b\" ] take 2 [ ] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/packEntry.html",
    "content": "lib.packEntry. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.packEntry.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.packEntry"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.packEntry. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.packEntry.",
    "raw_url": "/f/lib/packEntry.html",
    "excerpt": "lib.packEntry. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.packEntry.",
    "sub_results": []
  },
  {
    "url": "/f/lib/stringAsChars.html",
    "content": "lib.stringAsChars. Manipulate a string character by character and replace them by strings before concatenating the results. Example. stringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\" => \"nix\" Type. stringAsChars :: (string -> string) -> string -> string Arguments. [f] Function to map over each individual character. [s] Input string. Edit source. Noogle also knows. Aliases. lib.strings.stringAsChars.",
    "word_count": 59,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.stringAsChars"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 30
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.stringAsChars. Manipulate a string character by character and replace them by strings before concatenating the results. Example. stringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\" =&gt; \"nix\" Type. stringAsChars :: (string -&gt; string) -&gt; string -&gt; string Arguments. [f] Function to map over each individual character. [s] Input string. Edit source. Noogle also knows. Aliases. lib.strings.stringAsChars.",
    "raw_url": "/f/lib/stringAsChars.html",
    "excerpt": "lib.stringAsChars. Manipulate a string character by character and replace them by strings before concatenating the results. Example. stringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\" =&gt; \"nix\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/head.html",
    "content": "lib.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether a list is empty by comparing it with []. Noogle also knows. Aliases. builtins.head. lib.lists.head. lib.strings.head.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.head Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether a list is empty by comparing it with []. Noogle also knows. Aliases. builtins.head. lib.lists.head. lib.strings.head.",
    "raw_url": "/f/lib/head.html",
    "excerpt": "lib.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixMergeModules.html",
    "content": "lib.fixMergeModules. Compatibility. Arguments. [modules] [args] Edit source. Noogle also knows. Aliases. lib.modules.fixMergeModules.",
    "word_count": 12,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixMergeModules"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 2
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixMergeModules. Compatibility. Arguments. [modules] [args] Edit source. Noogle also knows. Aliases. lib.modules.fixMergeModules.",
    "raw_url": "/f/lib/fixMergeModules.html",
    "excerpt": "lib.fixMergeModules. Compatibility. Arguments. [modules] [args] Edit source. Noogle also knows. Aliases. lib.modules.fixMergeModules.",
    "sub_results": []
  },
  {
    "url": "/f/lib/maybeAttrNullable.html",
    "content": "lib.maybeAttrNullable. Edit source. Noogle also knows. Aliases. lib.misc.maybeAttrNullable.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.maybeAttrNullable"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.maybeAttrNullable. Edit source. Noogle also knows. Aliases. lib.misc.maybeAttrNullable.",
    "raw_url": "/f/lib/maybeAttrNullable.html",
    "excerpt": "lib.maybeAttrNullable. Edit source. Noogle also knows. Aliases. lib.misc.maybeAttrNullable.",
    "sub_results": []
  },
  {
    "url": "/f/lib/makeSearchPath.html",
    "content": "lib.makeSearchPath. Construct a Unix-style, colon-separated search path consisting of the given subDir appended to each of the given paths. Example. makeSearchPath \"bin\" [\"/root\" \"/usr\" \"/usr/local\"] => \"/root/bin:/usr/bin:/usr/local/bin\" makeSearchPath \"bin\" [\"\"] => \"/bin\" Type. makeSearchPath :: string -> [string] -> string Arguments. [subDir] Directory name to append. [paths] List of base paths. Edit source. Noogle also knows. Aliases. lib.strings.makeSearchPath.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.makeSearchPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.makeSearchPath. Construct a Unix-style, colon-separated search path consisting of the given subDir appended to each of the given paths. Example. makeSearchPath \"bin\" [\"/root\" \"/usr\" \"/usr/local\"] =&gt; \"/root/bin:/usr/bin:/usr/local/bin\" makeSearchPath \"bin\" [\"\"] =&gt; \"/bin\" Type. makeSearchPath :: string -&gt; [string] -&gt; string Arguments. [subDir] Directory name to append. [paths] List of base paths. Edit source. Noogle also knows. Aliases. lib.strings.makeSearchPath.",
    "raw_url": "/f/lib/makeSearchPath.html",
    "excerpt": "lib.makeSearchPath. Construct a Unix-style, colon-separated search path consisting of the given subDir appended to each of the given paths. Example. makeSearchPath \"bin\" [\"/root\" \"/usr\" \"/usr/local\"] =&gt; \"/root/bin:/usr/bin:/usr/local/bin\" makeSearchPath \"bin\" [\"\"]",
    "sub_results": []
  },
  {
    "url": "/f/lib/setType.html",
    "content": "lib.setType. Edit source. Noogle also knows. Aliases. lib.types.setType.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.setType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.setType. Edit source. Noogle also knows. Aliases. lib.types.setType.",
    "raw_url": "/f/lib/setType.html",
    "excerpt": "lib.setType. Edit source. Noogle also knows. Aliases. lib.types.setType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/pathExists.html",
    "content": "lib.pathExists Primop. Takes 1 arguments. path. Return true if the path path exists at evaluation time, and false otherwise. Noogle also knows. Aliases. builtins.pathExists. lib.trivial.pathExists.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.pathExists Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.pathExists Primop. Takes 1 arguments. path. Return true if the path path exists at evaluation time, and false otherwise. Noogle also knows. Aliases. builtins.pathExists. lib.trivial.pathExists.",
    "raw_url": "/f/lib/pathExists.html",
    "excerpt": "lib.pathExists Primop. Takes 1 arguments. path. Return true if the path path exists at evaluation time, and false otherwise. Noogle also knows. Aliases. builtins.pathExists. lib.trivial.pathExists.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mapAttrsRecursive.html",
    "content": "lib.mapAttrsRecursive. Like mapAttrs, except that it recursively applies itself to the leaf attributes of a potentially-nested attribute set: the second argument of the function will never be an attrset. Also, the first argument of the argument function is a list of the attribute names that form the path to the leaf attribute. For a function that gives you control over what counts as a leaf, see mapAttrsRecursiveCond. Example. mapAttrsRecursive (path: value: concatStringsSep \"-\" (path ++ [value])) { n = { a = \"A\"; m = { b = \"B\"; c = \"C\"; }; }; d = \"D\"; } => { n = { a = \"n-a-A\"; m = { b = \"n-m-b-B\"; c = \"n-m-c-C\"; }; }; d = \"d-D\"; } Type. mapAttrsRecursive :: ([String] -> a -> b) -> AttrSet -> AttrSet Arguments. [f] A function, given a list of attribute names and a value, returns a new value. [set] Set to recursively map over. Edit source. Noogle also knows. Aliases. lib.attrsets.mapAttrsRecursive.",
    "word_count": 163,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mapAttrsRecursive"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 67
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 121
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 133
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mapAttrsRecursive. Like mapAttrs, except that it recursively applies itself to the leaf attributes of a potentially-nested attribute set: the second argument of the function will never be an attrset. Also, the first argument of the argument function is a list of the attribute names that form the path to the leaf attribute. For a function that gives you control over what counts as a leaf, see mapAttrsRecursiveCond. Example. mapAttrsRecursive (path: value: concatStringsSep \"-\" (path ++ [value])) { n = { a = \"A\"; m = { b = \"B\"; c = \"C\"; }; }; d = \"D\"; } =&gt; { n = { a = \"n-a-A\"; m = { b = \"n-m-b-B\"; c = \"n-m-c-C\"; }; }; d = \"d-D\"; } Type. mapAttrsRecursive :: ([String] -&gt; a -&gt; b) -&gt; AttrSet -&gt; AttrSet Arguments. [f] A function, given a list of attribute names and a value, returns a new value. [set] Set to recursively map over. Edit source. Noogle also knows. Aliases. lib.attrsets.mapAttrsRecursive.",
    "raw_url": "/f/lib/mapAttrsRecursive.html",
    "excerpt": "lib.mapAttrsRecursive. Like mapAttrs, except that it recursively applies itself to the leaf attributes of a potentially-nested attribute set: the second argument of the function will never be an attrset. Also,",
    "sub_results": []
  },
  {
    "url": "/f/lib/chooseDevOutputs.html",
    "content": "lib.chooseDevOutputs. Pick the outputs of packages to place in buildInputs. Type. chooseDevOutputs :: [Derivation] -> [String] Arguments. [drvs] List of packages to pick dev outputs from. Edit source. Noogle also knows. Aliases. lib.attrsets.chooseDevOutputs.",
    "word_count": 33,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.chooseDevOutputs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 10
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 16
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.chooseDevOutputs. Pick the outputs of packages to place in buildInputs. Type. chooseDevOutputs :: [Derivation] -&gt; [String] Arguments. [drvs] List of packages to pick dev outputs from. Edit source. Noogle also knows. Aliases. lib.attrsets.chooseDevOutputs.",
    "raw_url": "/f/lib/chooseDevOutputs.html",
    "excerpt": "lib.chooseDevOutputs. Pick the outputs of packages to place in buildInputs. Type. chooseDevOutputs :: [Derivation] -&gt; [String] Arguments. [drvs] List of packages to pick dev outputs from. Edit source. Noogle also",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileContents.html",
    "content": "lib.fileContents. Read the contents of a file removing the trailing \\n. Example. $ echo \"1.0\" > ./version fileContents ./version => \"1.0\" Type. fileContents :: path -> string Arguments. [file] Edit source. Noogle also knows. Aliases. lib.strings.fileContents.",
    "word_count": 36,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileContents"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileContents. Read the contents of a file removing the trailing \\n. Example. $ echo \"1.0\" &gt; ./version fileContents ./version =&gt; \"1.0\" Type. fileContents :: path -&gt; string Arguments. [file] Edit source. Noogle also knows. Aliases. lib.strings.fileContents.",
    "raw_url": "/f/lib/fileContents.html",
    "excerpt": "lib.fileContents. Read the contents of a file removing the trailing \\n. Example. $ echo \"1.0\" &gt; ./version fileContents ./version =&gt; \"1.0\" Type. fileContents :: path -&gt; string Arguments. [file] Edit",
    "sub_results": []
  },
  {
    "url": "/f/lib/makeExtensible.html",
    "content": "lib.makeExtensible. Create an overridable, recursive attribute set. For example: nix-repl> obj = makeExtensible (self: { }) nix-repl> obj { __unfix__ = «lambda»; extend = «lambda»; } nix-repl> obj = obj.extend (self: super: { foo = \"foo\"; }) nix-repl> obj { __unfix__ = «lambda»; extend = «lambda»; foo = \"foo\"; } nix-repl> obj = obj.extend (self: super: { foo = super.foo + \" + \"; bar = \"bar\"; foobar = self.foo + self.bar; }) nix-repl> obj { __unfix__ = «lambda»; bar = \"bar\"; extend = «lambda»; foo = \"foo + \"; foobar = \"foo + bar\"; } Edit source. Noogle also knows. Aliases. lib.fixedPoints.makeExtensible.",
    "word_count": 103,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.makeExtensible"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.makeExtensible. Create an overridable, recursive attribute set. For example: nix-repl&gt; obj = makeExtensible (self: { }) nix-repl&gt; obj { __unfix__ = «lambda»; extend = «lambda»; } nix-repl&gt; obj = obj.extend (self: super: { foo = \"foo\"; }) nix-repl&gt; obj { __unfix__ = «lambda»; extend = «lambda»; foo = \"foo\"; } nix-repl&gt; obj = obj.extend (self: super: { foo = super.foo + \" + \"; bar = \"bar\"; foobar = self.foo + self.bar; }) nix-repl&gt; obj { __unfix__ = «lambda»; bar = \"bar\"; extend = «lambda»; foo = \"foo + \"; foobar = \"foo + bar\"; } Edit source. Noogle also knows. Aliases. lib.fixedPoints.makeExtensible.",
    "raw_url": "/f/lib/makeExtensible.html",
    "excerpt": "lib.makeExtensible. Create an overridable, recursive attribute set. For example: nix-repl&gt; obj = makeExtensible (self: { }) nix-repl&gt; obj { __unfix__ = «lambda»; extend = «lambda»; } nix-repl&gt; obj = obj.extend",
    "sub_results": []
  },
  {
    "url": "/f/lib/all.html",
    "content": "lib.all Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for all elements of list. Example. all (x: x < 3) [ 1 2 ] => true all (x: x < 3) [ 1 2 3 ] => false Type. all :: (a -> bool) -> [a] -> bool Edit source. Noogle also knows. Aliases. builtins.all. lib.lists.all.",
    "word_count": 61,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.all Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 43
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.all Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for all elements of list. Example. all (x: x &lt; 3) [ 1 2 ] =&gt; true all (x: x &lt; 3) [ 1 2 3 ] =&gt; false Type. all :: (a -&gt; bool) -&gt; [a] -&gt; bool Edit source. Noogle also knows. Aliases. builtins.all. lib.lists.all.",
    "raw_url": "/f/lib/all.html",
    "excerpt": "lib.all Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for all elements of list. Example. all (x: x &lt; 3) [ 1 2 ] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/makeScopeWithSplicing.html",
    "content": "lib.makeScopeWithSplicing. backward compatibility with old uncurried form; deprecated. Arguments. [splicePackages] [newScope] [otherSplices] [keep] [extra] [f] Edit source. Noogle also knows. Aliases. lib.customisation.makeScopeWithSplicing. pkgs.makeScopeWithSplicing.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.makeScopeWithSplicing"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.makeScopeWithSplicing. backward compatibility with old uncurried form; deprecated. Arguments. [splicePackages] [newScope] [otherSplices] [keep] [extra] [f] Edit source. Noogle also knows. Aliases. lib.customisation.makeScopeWithSplicing. pkgs.makeScopeWithSplicing.",
    "raw_url": "/f/lib/makeScopeWithSplicing.html",
    "excerpt": "lib.makeScopeWithSplicing. backward compatibility with old uncurried form; deprecated. Arguments. [splicePackages] [newScope] [otherSplices] [keep] [extra] [f] Edit source. Noogle also knows. Aliases. lib.customisation.makeScopeWithSplicing. pkgs.makeScopeWithSplicing.",
    "sub_results": []
  },
  {
    "url": "/f/lib/hasAttr.html",
    "content": "lib.hasAttr Primop. Takes 2 arguments. s, set. hasAttr returns true if set has an attribute named s, and false otherwise. This is a dynamic version of the ? operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. builtins.hasAttr. lib.attrsets.hasAttr.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.hasAttr Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.hasAttr Primop. Takes 2 arguments. s, set. hasAttr returns true if set has an attribute named s, and false otherwise. This is a dynamic version of the ? operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. builtins.hasAttr. lib.attrsets.hasAttr.",
    "raw_url": "/f/lib/hasAttr.html",
    "excerpt": "lib.hasAttr Primop. Takes 2 arguments. s, set. hasAttr returns true if set has an attribute named s, and false otherwise. This is a dynamic version of the ? operator, since",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkSinkUndeclaredOptions.html",
    "content": "lib.mkSinkUndeclaredOptions. This option accepts anything, but it does not produce any result. This is useful for sharing a module across different module sets without having to implement similar features as long as the values of the options are not accessed. Arguments. [attrs] Edit source. Noogle also knows. Aliases. lib.options.mkSinkUndeclaredOptions.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkSinkUndeclaredOptions"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkSinkUndeclaredOptions. This option accepts anything, but it does not produce any result. This is useful for sharing a module across different module sets without having to implement similar features as long as the values of the options are not accessed. Arguments. [attrs] Edit source. Noogle also knows. Aliases. lib.options.mkSinkUndeclaredOptions.",
    "raw_url": "/f/lib/mkSinkUndeclaredOptions.html",
    "excerpt": "lib.mkSinkUndeclaredOptions. This option accepts anything, but it does not produce any result. This is useful for sharing a module across different module sets without having to implement similar features as",
    "sub_results": []
  },
  {
    "url": "/f/lib/isOption.html",
    "content": "lib.isOption. Returns true when the given argument is an option. Example. isOption 1 // => false isOption (mkOption {}) // => true Type. isOption :: a -> bool Edit source. Noogle also knows. Aliases. lib.options.isOption.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isOption. Returns true when the given argument is an option. Example. isOption 1 // =&gt; false isOption (mkOption {}) // =&gt; true Type. isOption :: a -&gt; bool Edit source. Noogle also knows. Aliases. lib.options.isOption.",
    "raw_url": "/f/lib/isOption.html",
    "excerpt": "lib.isOption. Returns true when the given argument is an option. Example. isOption 1 // =&gt; false isOption (mkOption {}) // =&gt; true Type. isOption :: a -&gt; bool Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/id.html",
    "content": "lib.id. The identity function For when you need a function that does “nothing”. Type. id :: a -> a Arguments. [x] The value to return. Edit source. Noogle also knows. Aliases. lib.trivial.id.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.id"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 19
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.id. The identity function For when you need a function that does “nothing”. Type. id :: a -&gt; a Arguments. [x] The value to return. Edit source. Noogle also knows. Aliases. lib.trivial.id.",
    "raw_url": "/f/lib/id.html",
    "excerpt": "lib.id. The identity function For when you need a function that does “nothing”. Type. id :: a -&gt; a Arguments. [x] The value to return. Edit source. Noogle also knows.",
    "sub_results": []
  },
  {
    "url": "/f/lib/stringsWithDeps/packEntry.html",
    "content": "lib.stringsWithDeps.packEntry. Edit source. Noogle also knows. Aliases. lib.packEntry.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.stringsWithDeps.packEntry"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.stringsWithDeps.packEntry. Edit source. Noogle also knows. Aliases. lib.packEntry.",
    "raw_url": "/f/lib/stringsWithDeps/packEntry.html",
    "excerpt": "lib.stringsWithDeps.packEntry. Edit source. Noogle also knows. Aliases. lib.packEntry.",
    "sub_results": []
  },
  {
    "url": "/f/lib/stringsWithDeps/textClosureMap.html",
    "content": "lib.stringsWithDeps.textClosureMap. Edit source. Noogle also knows. Aliases. lib.textClosureMap.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.stringsWithDeps.textClosureMap"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.stringsWithDeps.textClosureMap. Edit source. Noogle also knows. Aliases. lib.textClosureMap.",
    "raw_url": "/f/lib/stringsWithDeps/textClosureMap.html",
    "excerpt": "lib.stringsWithDeps.textClosureMap. Edit source. Noogle also knows. Aliases. lib.textClosureMap.",
    "sub_results": []
  },
  {
    "url": "/f/lib/stringsWithDeps/stringAfter.html",
    "content": "lib.stringsWithDeps.stringAfter. Edit source. Noogle also knows. Aliases. lib.stringAfter.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.stringsWithDeps.stringAfter"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.stringsWithDeps.stringAfter. Edit source. Noogle also knows. Aliases. lib.stringAfter.",
    "raw_url": "/f/lib/stringsWithDeps/stringAfter.html",
    "excerpt": "lib.stringsWithDeps.stringAfter. Edit source. Noogle also knows. Aliases. lib.stringAfter.",
    "sub_results": []
  },
  {
    "url": "/f/lib/stringsWithDeps/noDepEntry.html",
    "content": "lib.stringsWithDeps.noDepEntry. Edit source. Noogle also knows. Aliases. lib.noDepEntry.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.stringsWithDeps.noDepEntry"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.stringsWithDeps.noDepEntry. Edit source. Noogle also knows. Aliases. lib.noDepEntry.",
    "raw_url": "/f/lib/stringsWithDeps/noDepEntry.html",
    "excerpt": "lib.stringsWithDeps.noDepEntry. Edit source. Noogle also knows. Aliases. lib.noDepEntry.",
    "sub_results": []
  },
  {
    "url": "/f/lib/stringsWithDeps/textClosureList.html",
    "content": "lib.stringsWithDeps.textClosureList. !!! The interface of this function is kind of messed up, since it's way too overloaded and almost but not quite computes a topological sort of the depstrings. Arguments. [predefined] [arg] Edit source. Noogle also knows. Aliases. lib.textClosureList.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.stringsWithDeps.textClosureList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.stringsWithDeps.textClosureList. !!! The interface of this function is kind of messed up, since it's way too overloaded and almost but not quite computes a topological sort of the depstrings. Arguments. [predefined] [arg] Edit source. Noogle also knows. Aliases. lib.textClosureList.",
    "raw_url": "/f/lib/stringsWithDeps/textClosureList.html",
    "excerpt": "lib.stringsWithDeps.textClosureList. !!! The interface of this function is kind of messed up, since it's way too overloaded and almost but not quite computes a topological sort of the depstrings. Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/stringsWithDeps/fullDepEntry.html",
    "content": "lib.stringsWithDeps.fullDepEntry. Edit source. Noogle also knows. Aliases. lib.fullDepEntry.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.stringsWithDeps.fullDepEntry"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.stringsWithDeps.fullDepEntry. Edit source. Noogle also knows. Aliases. lib.fullDepEntry.",
    "raw_url": "/f/lib/stringsWithDeps/fullDepEntry.html",
    "excerpt": "lib.stringsWithDeps.fullDepEntry. Edit source. Noogle also knows. Aliases. lib.fullDepEntry.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkAliasAndWrapDefinitions.html",
    "content": "lib.mkAliasAndWrapDefinitions. Edit source. Noogle also knows. Aliases. lib.modules.mkAliasAndWrapDefinitions.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkAliasAndWrapDefinitions"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkAliasAndWrapDefinitions. Edit source. Noogle also knows. Aliases. lib.modules.mkAliasAndWrapDefinitions.",
    "raw_url": "/f/lib/mkAliasAndWrapDefinitions.html",
    "excerpt": "lib.mkAliasAndWrapDefinitions. Edit source. Noogle also knows. Aliases. lib.modules.mkAliasAndWrapDefinitions.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mdDoc.html",
    "content": "lib.mdDoc. Transition marker for documentation that's already migrated to markdown syntax. This is a no-op and no longer needed. Edit source. Noogle also knows. Aliases. lib.options.mdDoc.",
    "word_count": 26,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mdDoc"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mdDoc. Transition marker for documentation that's already migrated to markdown syntax. This is a no-op and no longer needed. Edit source. Noogle also knows. Aliases. lib.options.mdDoc.",
    "raw_url": "/f/lib/mdDoc.html",
    "excerpt": "lib.mdDoc. Transition marker for documentation that's already migrated to markdown syntax. This is a no-op and no longer needed. Edit source. Noogle also knows. Aliases. lib.options.mdDoc.",
    "sub_results": []
  },
  {
    "url": "/f/lib/imap1.html",
    "content": "lib.imap1. Map with index starting from 1. Example. imap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] => [ \"a-1\" \"b-2\" ] Type. imap1 :: (int -> a -> b) -> [a] -> [b] Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.lists.imap1.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.imap1"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 7
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.imap1. Map with index starting from 1. Example. imap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] =&gt; [ \"a-1\" \"b-2\" ] Type. imap1 :: (int -&gt; a -&gt; b) -&gt; [a] -&gt; [b] Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.lists.imap1.",
    "raw_url": "/f/lib/imap1.html",
    "excerpt": "lib.imap1. Map with index starting from 1. Example. imap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] =&gt; [ \"a-1\" \"b-2\" ] Type. imap1 :: (int -&gt; a -&gt; b) -&gt; [a]",
    "sub_results": []
  },
  {
    "url": "/f/lib/listDfs.html",
    "content": "lib.listDfs. Depth-First Search (DFS) for lists list != []. before a b == true means that b depends on a (there's an edge from b to a). Example. listDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ] == { minimal = \"/\"; # minimal element visited = [ \"/home/user\" ]; # seen elements (in reverse order) rest = [ \"/home\" \"other\" ]; # everything else } listDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ] == { cycle = \"/\"; # cycle encountered at this element loops = [ \"/\" ]; # and continues to these elements visited = [ \"/\" \"/home/user\" ]; # elements leading to the cycle (in reverse order) rest = [ \"/home\" \"other\" ]; # everything else Arguments. [stopOnCycles] [before] [list] Edit source. Noogle also knows. Aliases. lib.lists.listDfs.",
    "word_count": 133,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.listDfs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 27
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 122
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.listDfs. Depth-First Search (DFS) for lists list != []. before a b == true means that b depends on a (there's an edge from b to a). Example. listDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ] == { minimal = \"/\"; # minimal element visited = [ \"/home/user\" ]; # seen elements (in reverse order) rest = [ \"/home\" \"other\" ]; # everything else } listDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ] == { cycle = \"/\"; # cycle encountered at this element loops = [ \"/\" ]; # and continues to these elements visited = [ \"/\" \"/home/user\" ]; # elements leading to the cycle (in reverse order) rest = [ \"/home\" \"other\" ]; # everything else Arguments. [stopOnCycles] [before] [list] Edit source. Noogle also knows. Aliases. lib.lists.listDfs.",
    "raw_url": "/f/lib/listDfs.html",
    "excerpt": "lib.listDfs. Depth-First Search (DFS) for lists list != []. before a b == true means that b depends on a (there's an edge from b to a). Example. listDfs true",
    "sub_results": []
  },
  {
    "url": "/f/lib/canCleanSource.html",
    "content": "lib.canCleanSource. Edit source. Noogle also knows. Aliases. lib.sources.canCleanSource.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.canCleanSource"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.canCleanSource. Edit source. Noogle also knows. Aliases. lib.sources.canCleanSource.",
    "raw_url": "/f/lib/canCleanSource.html",
    "excerpt": "lib.canCleanSource. Edit source. Noogle also knows. Aliases. lib.sources.canCleanSource.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkForce.html",
    "content": "lib.mkForce. Noogle also knows. Aliases. lib.modules.mkForce.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkForce"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkForce. Noogle also knows. Aliases. lib.modules.mkForce.",
    "raw_url": "/f/lib/mkForce.html",
    "excerpt": "lib.mkForce. Noogle also knows. Aliases. lib.modules.mkForce.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/zipLists.html",
    "content": "lib.lists.zipLists. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. Example. zipLists [ 1 2 ] [ \"a\" \"b\" ] => [ { fst = 1; snd = \"a\"; } { fst = 2; snd = \"b\"; } ] Type. zipLists :: [a] -> [b] -> [{ fst :: a; snd :: b; }] Edit source. Noogle also knows. Aliases. lib.zipLists.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.zipLists"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 21
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.zipLists. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. Example. zipLists [ 1 2 ] [ \"a\" \"b\" ] =&gt; [ { fst = 1; snd = \"a\"; } { fst = 2; snd = \"b\"; } ] Type. zipLists :: [a] -&gt; [b] -&gt; [{ fst :: a; snd :: b; }] Edit source. Noogle also knows. Aliases. lib.zipLists.",
    "raw_url": "/f/lib/lists/zipLists.html",
    "excerpt": "lib.lists.zipLists. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. Example. zipLists [ 1 2 ] [ \"a\" \"b\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/optional.html",
    "content": "lib.lists.optional. Return a singleton list or an empty list, depending on a boolean value. Useful when building lists with optional elements (e.g. ++ optional (system == \"i686-linux\") firefox). Example. optional true \"foo\" => [ \"foo\" ] optional false \"foo\" => [ ] Type. optional :: bool -> a -> [a] Arguments. [cond] [elem] Edit source. Noogle also knows. Aliases. lib.optional.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.optional"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 28
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 42
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.optional. Return a singleton list or an empty list, depending on a boolean value. Useful when building lists with optional elements (e.g. ++ optional (system == \"i686-linux\") firefox). Example. optional true \"foo\" =&gt; [ \"foo\" ] optional false \"foo\" =&gt; [ ] Type. optional :: bool -&gt; a -&gt; [a] Arguments. [cond] [elem] Edit source. Noogle also knows. Aliases. lib.optional.",
    "raw_url": "/f/lib/lists/optional.html",
    "excerpt": "lib.lists.optional. Return a singleton list or an empty list, depending on a boolean value. Useful when building lists with optional elements (e.g. ++ optional (system == \"i686-linux\") firefox). Example. optional",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/genList.html",
    "content": "lib.lists.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x * x) 5 returns the list [ 0 1 4 9 16 ]. Noogle also knows. Aliases. builtins.genList. lib.genList. lib.strings.genList.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.genList Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x * x) 5 returns the list [ 0 1 4 9 16 ]. Noogle also knows. Aliases. builtins.genList. lib.genList. lib.strings.genList.",
    "raw_url": "/f/lib/lists/genList.html",
    "excerpt": "lib.lists.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x *",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/foldr.html",
    "content": "lib.lists.foldr. “right fold” a binary function op between successive elements of list with nul as the starting value, i.e., foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul)). Example. concat = foldr (a: b: a + b) \"z\" concat [ \"a\" \"b\" \"c\" ] => \"abcz\" # different types strange = foldr (int: str: toString (int + 1) + str) \"a\" strange [ 1 2 3 4 ] => \"2345a\" Type. foldr :: (a -> b -> b) -> b -> [a] -> b Arguments. [op] [nul] [list] Edit source. Noogle also knows. Aliases. lib.foldr.",
    "word_count": 102,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.foldr"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 35
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 77
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 91
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.foldr. “right fold” a binary function op between successive elements of list with nul as the starting value, i.e., foldr op nul [x_1 x_2 ... x_n] == op x_1 (op x_2 ... (op x_n nul)). Example. concat = foldr (a: b: a + b) \"z\" concat [ \"a\" \"b\" \"c\" ] =&gt; \"abcz\" # different types strange = foldr (int: str: toString (int + 1) + str) \"a\" strange [ 1 2 3 4 ] =&gt; \"2345a\" Type. foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b Arguments. [op] [nul] [list] Edit source. Noogle also knows. Aliases. lib.foldr.",
    "raw_url": "/f/lib/lists/foldr.html",
    "excerpt": "lib.lists.foldr. “right fold” a binary function op between successive elements of list with nul as the starting value, i.e., foldr op nul [x_1 x_2 ... x_n] == op x_1 (op",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/allUnique.html",
    "content": "lib.lists.allUnique. Check if list contains only unique elements. O(n^2) complexity. Example. allUnique [ 3 2 3 4 ] => false allUnique [ 3 2 4 1 ] => true Type. allUnique :: [a] -> bool Arguments. [list] Edit source. Noogle also knows. Aliases. lib.allUnique.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.allUnique"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 29
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.allUnique. Check if list contains only unique elements. O(n^2) complexity. Example. allUnique [ 3 2 3 4 ] =&gt; false allUnique [ 3 2 4 1 ] =&gt; true Type. allUnique :: [a] -&gt; bool Arguments. [list] Edit source. Noogle also knows. Aliases. lib.allUnique.",
    "raw_url": "/f/lib/lists/allUnique.html",
    "excerpt": "lib.lists.allUnique. Check if list contains only unique elements. O(n^2) complexity. Example. allUnique [ 3 2 3 4 ] =&gt; false allUnique [ 3 2 4 1 ] =&gt; true Type.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/replicate.html",
    "content": "lib.lists.replicate. Return a list with n copies of an element. Example. replicate 3 \"a\" => [ \"a\" \"a\" \"a\" ] replicate 2 true => [ true true ] Type. replicate :: int -> a -> [a] Arguments. [n] [elem] Edit source. Noogle also knows. Aliases. lib.replicate. lib.strings.replicate.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.replicate"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 28
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 36
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.replicate. Return a list with n copies of an element. Example. replicate 3 \"a\" =&gt; [ \"a\" \"a\" \"a\" ] replicate 2 true =&gt; [ true true ] Type. replicate :: int -&gt; a -&gt; [a] Arguments. [n] [elem] Edit source. Noogle also knows. Aliases. lib.replicate. lib.strings.replicate.",
    "raw_url": "/f/lib/lists/replicate.html",
    "excerpt": "lib.lists.replicate. Return a list with n copies of an element. Example. replicate 3 \"a\" =&gt; [ \"a\" \"a\" \"a\" ] replicate 2 true =&gt; [ true true ] Type. replicate",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/optionals.html",
    "content": "lib.lists.optionals. Return a list or an empty list, depending on a boolean value. Example. optionals true [ 2 3 ] => [ 2 3 ] optionals false [ 2 3 ] => [ ] Type. optionals :: bool -> [a] -> [a] Arguments. [cond] Condition. [elems] List to return if condition is true. Edit source. Noogle also knows. Aliases. lib.optionals.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.optionals"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.optionals. Return a list or an empty list, depending on a boolean value. Example. optionals true [ 2 3 ] =&gt; [ 2 3 ] optionals false [ 2 3 ] =&gt; [ ] Type. optionals :: bool -&gt; [a] -&gt; [a] Arguments. [cond] Condition. [elems] List to return if condition is true. Edit source. Noogle also knows. Aliases. lib.optionals.",
    "raw_url": "/f/lib/lists/optionals.html",
    "excerpt": "lib.lists.optionals. Return a list or an empty list, depending on a boolean value. Example. optionals true [ 2 3 ] =&gt; [ 2 3 ] optionals false [ 2 3",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/naturalSort.html",
    "content": "lib.lists.naturalSort. Sort list using \"Natural sorting\". Numeric portions of strings are sorted in numeric order. Example. naturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"] => [\"disk8\" \"disk9\" \"disk11\" \"disk100\"] naturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"] => [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"] naturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"] => [ \"v0.0.9\" \"v0.2\" \"v0.15\" ] Arguments. [lst] Edit source. Noogle also knows. Aliases. lib.naturalSort.",
    "word_count": 53,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.naturalSort"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 44
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.naturalSort. Sort list using \"Natural sorting\". Numeric portions of strings are sorted in numeric order. Example. naturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"] =&gt; [\"disk8\" \"disk9\" \"disk11\" \"disk100\"] naturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"] =&gt; [\"10.5.16.62\" \"10.46.133.149\" \"10.54.16.25\"] naturalSort [\"v0.2\" \"v0.15\" \"v0.0.9\"] =&gt; [ \"v0.0.9\" \"v0.2\" \"v0.15\" ] Arguments. [lst] Edit source. Noogle also knows. Aliases. lib.naturalSort.",
    "raw_url": "/f/lib/lists/naturalSort.html",
    "excerpt": "lib.lists.naturalSort. Sort list using \"Natural sorting\". Numeric portions of strings are sorted in numeric order. Example. naturalSort [\"disk11\" \"disk8\" \"disk100\" \"disk9\"] =&gt; [\"disk8\" \"disk9\" \"disk11\" \"disk100\"] naturalSort [\"10.46.133.149\" \"10.5.16.62\" \"10.54.16.25\"]",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/findFirstIndex.html",
    "content": "lib.lists.findFirstIndex. Find the first index in the list matching the specified predicate or return default if no such element exists. Example. findFirstIndex (x: x > 3) null [ 0 6 4 ] => 1 findFirstIndex (x: x > 9) null [ 0 6 4 ] => null Type. findFirstIndex :: (a -> Bool) -> b -> [a] -> (Int | b) Arguments. [pred] Predicate. [default] Default value to return. [list] Input list. Edit source.",
    "word_count": 74,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.findFirstIndex"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 61
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.findFirstIndex. Find the first index in the list matching the specified predicate or return default if no such element exists. Example. findFirstIndex (x: x &gt; 3) null [ 0 6 4 ] =&gt; 1 findFirstIndex (x: x &gt; 9) null [ 0 6 4 ] =&gt; null Type. findFirstIndex :: (a -&gt; Bool) -&gt; b -&gt; [a] -&gt; (Int | b) Arguments. [pred] Predicate. [default] Default value to return. [list] Input list. Edit source.",
    "raw_url": "/f/lib/lists/findFirstIndex.html",
    "excerpt": "lib.lists.findFirstIndex. Find the first index in the list matching the specified predicate or return default if no such element exists. Example. findFirstIndex (x: x &gt; 3) null [ 0 6",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/forEach.html",
    "content": "lib.lists.forEach. Apply the function to each element in the list. Same as map, but arguments flipped. Example. forEach [ 1 2 ] (x: toString x ) => [ \"1\" \"2\" ] Type. forEach :: [a] -> (a -> b) -> [b] Arguments. [xs] [f] Edit source. Noogle also knows. Aliases. lib.forEach.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.forEach"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.forEach. Apply the function to each element in the list. Same as map, but arguments flipped. Example. forEach [ 1 2 ] (x: toString x ) =&gt; [ \"1\" \"2\" ] Type. forEach :: [a] -&gt; (a -&gt; b) -&gt; [b] Arguments. [xs] [f] Edit source. Noogle also knows. Aliases. lib.forEach.",
    "raw_url": "/f/lib/lists/forEach.html",
    "excerpt": "lib.lists.forEach. Apply the function to each element in the list. Same as map, but arguments flipped. Example. forEach [ 1 2 ] (x: toString x ) =&gt; [ \"1\" \"2\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/drop.html",
    "content": "lib.lists.drop. Remove the first (at most) N elements of a list. Example. drop 2 [ \"a\" \"b\" \"c\" \"d\" ] => [ \"c\" \"d\" ] drop 2 [ ] => [ ] Type. drop :: int -> [a] -> [a] Arguments. [count] Number of elements to drop. [list] Input list. Edit source. Noogle also knows. Aliases. lib.drop.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.drop"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.drop. Remove the first (at most) N elements of a list. Example. drop 2 [ \"a\" \"b\" \"c\" \"d\" ] =&gt; [ \"c\" \"d\" ] drop 2 [ ] =&gt; [ ] Type. drop :: int -&gt; [a] -&gt; [a] Arguments. [count] Number of elements to drop. [list] Input list. Edit source. Noogle also knows. Aliases. lib.drop.",
    "raw_url": "/f/lib/lists/drop.html",
    "excerpt": "lib.lists.drop. Remove the first (at most) N elements of a list. Example. drop 2 [ \"a\" \"b\" \"c\" \"d\" ] =&gt; [ \"c\" \"d\" ] drop 2 [ ] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/count.html",
    "content": "lib.lists.count. Count how many elements of list match the supplied predicate function. Example. count (x: x == 3) [ 3 2 3 4 6 ] => 2 Type. count :: (a -> bool) -> [a] -> int Arguments. [pred] Predicate. Edit source. Noogle also knows. Aliases. lib.count.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.count"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 27
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 37
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.count. Count how many elements of list match the supplied predicate function. Example. count (x: x == 3) [ 3 2 3 4 6 ] =&gt; 2 Type. count :: (a -&gt; bool) -&gt; [a] -&gt; int Arguments. [pred] Predicate. Edit source. Noogle also knows. Aliases. lib.count.",
    "raw_url": "/f/lib/lists/count.html",
    "excerpt": "lib.lists.count. Count how many elements of list match the supplied predicate function. Example. count (x: x == 3) [ 3 2 3 4 6 ] =&gt; 2 Type. count ::",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/subtractLists.html",
    "content": "lib.lists.subtractLists. Subtracts list 'e' from another list. O(nm) complexity. Example. subtractLists [ 3 2 ] [ 1 2 3 4 5 3 ] => [ 1 4 5 ] Arguments. [e] Edit source. Noogle also knows. Aliases. lib.subtractLists.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.subtractLists"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.subtractLists. Subtracts list 'e' from another list. O(nm) complexity. Example. subtractLists [ 3 2 ] [ 1 2 3 4 5 3 ] =&gt; [ 1 4 5 ] Arguments. [e] Edit source. Noogle also knows. Aliases. lib.subtractLists.",
    "raw_url": "/f/lib/lists/subtractLists.html",
    "excerpt": "lib.lists.subtractLists. Subtracts list 'e' from another list. O(nm) complexity. Example. subtractLists [ 3 2 ] [ 1 2 3 4 5 3 ] =&gt; [ 1 4 5 ] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/take.html",
    "content": "lib.lists.take. Return the first (at most) N elements of a list. Example. take 2 [ \"a\" \"b\" \"c\" \"d\" ] => [ \"a\" \"b\" ] take 2 [ ] => [ ] Type. take :: int -> [a] -> [a] Arguments. [count] Number of elements to take. Edit source. Noogle also knows. Aliases. lib.take.",
    "word_count": 54,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.take"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.take. Return the first (at most) N elements of a list. Example. take 2 [ \"a\" \"b\" \"c\" \"d\" ] =&gt; [ \"a\" \"b\" ] take 2 [ ] =&gt; [ ] Type. take :: int -&gt; [a] -&gt; [a] Arguments. [count] Number of elements to take. Edit source. Noogle also knows. Aliases. lib.take.",
    "raw_url": "/f/lib/lists/take.html",
    "excerpt": "lib.lists.take. Return the first (at most) N elements of a list. Example. take 2 [ \"a\" \"b\" \"c\" \"d\" ] =&gt; [ \"a\" \"b\" ] take 2 [ ] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/head.html",
    "content": "lib.lists.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether a list is empty by comparing it with []. Noogle also knows. Aliases. builtins.head. lib.head. lib.strings.head.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.head Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether a list is empty by comparing it with []. Noogle also knows. Aliases. builtins.head. lib.head. lib.strings.head.",
    "raw_url": "/f/lib/lists/head.html",
    "excerpt": "lib.lists.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/all.html",
    "content": "lib.lists.all Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for all elements of list. Example. all (x: x < 3) [ 1 2 ] => true all (x: x < 3) [ 1 2 3 ] => false Type. all :: (a -> bool) -> [a] -> bool Edit source. Noogle also knows. Aliases. builtins.all. lib.all.",
    "word_count": 61,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.all Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 43
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.all Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for all elements of list. Example. all (x: x &lt; 3) [ 1 2 ] =&gt; true all (x: x &lt; 3) [ 1 2 3 ] =&gt; false Type. all :: (a -&gt; bool) -&gt; [a] -&gt; bool Edit source. Noogle also knows. Aliases. builtins.all. lib.all.",
    "raw_url": "/f/lib/lists/all.html",
    "excerpt": "lib.lists.all Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for all elements of list. Example. all (x: x &lt; 3) [ 1 2 ] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/imap1.html",
    "content": "lib.lists.imap1. Map with index starting from 1. Example. imap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] => [ \"a-1\" \"b-2\" ] Type. imap1 :: (int -> a -> b) -> [a] -> [b] Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.imap1.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.imap1"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 7
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.imap1. Map with index starting from 1. Example. imap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] =&gt; [ \"a-1\" \"b-2\" ] Type. imap1 :: (int -&gt; a -&gt; b) -&gt; [a] -&gt; [b] Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.imap1.",
    "raw_url": "/f/lib/lists/imap1.html",
    "excerpt": "lib.lists.imap1. Map with index starting from 1. Example. imap1 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] =&gt; [ \"a-1\" \"b-2\" ] Type. imap1 :: (int -&gt; a -&gt; b) -&gt; [a]",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/listDfs.html",
    "content": "lib.lists.listDfs. Depth-First Search (DFS) for lists list != []. before a b == true means that b depends on a (there's an edge from b to a). Example. listDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ] == { minimal = \"/\"; # minimal element visited = [ \"/home/user\" ]; # seen elements (in reverse order) rest = [ \"/home\" \"other\" ]; # everything else } listDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ] == { cycle = \"/\"; # cycle encountered at this element loops = [ \"/\" ]; # and continues to these elements visited = [ \"/\" \"/home/user\" ]; # elements leading to the cycle (in reverse order) rest = [ \"/home\" \"other\" ]; # everything else Arguments. [stopOnCycles] [before] [list] Edit source. Noogle also knows. Aliases. lib.listDfs.",
    "word_count": 133,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.listDfs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 27
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 122
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.listDfs. Depth-First Search (DFS) for lists list != []. before a b == true means that b depends on a (there's an edge from b to a). Example. listDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ] == { minimal = \"/\"; # minimal element visited = [ \"/home/user\" ]; # seen elements (in reverse order) rest = [ \"/home\" \"other\" ]; # everything else } listDfs true hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ] == { cycle = \"/\"; # cycle encountered at this element loops = [ \"/\" ]; # and continues to these elements visited = [ \"/\" \"/home/user\" ]; # elements leading to the cycle (in reverse order) rest = [ \"/home\" \"other\" ]; # everything else Arguments. [stopOnCycles] [before] [list] Edit source. Noogle also knows. Aliases. lib.listDfs.",
    "raw_url": "/f/lib/lists/listDfs.html",
    "excerpt": "lib.lists.listDfs. Depth-First Search (DFS) for lists list != []. before a b == true means that b depends on a (there's an edge from b to a). Example. listDfs true",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/init.html",
    "content": "lib.lists.init. Return all elements but the last. This function throws an error if the list is empty. Example. init [ 1 2 3 ] => [ 1 2 ] Type. init :: [a] -> [a] Arguments. [list] Edit source. Noogle also knows. Aliases. lib.init.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.init"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 29
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.init. Return all elements but the last. This function throws an error if the list is empty. Example. init [ 1 2 3 ] =&gt; [ 1 2 ] Type. init :: [a] -&gt; [a] Arguments. [list] Edit source. Noogle also knows. Aliases. lib.init.",
    "raw_url": "/f/lib/lists/init.html",
    "excerpt": "lib.lists.init. Return all elements but the last. This function throws an error if the list is empty. Example. init [ 1 2 3 ] =&gt; [ 1 2 ] Type.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/hasPrefix.html",
    "content": "lib.lists.hasPrefix. Whether the first list is a prefix of the second list. Example. hasPrefix [ 1 2 ] [ 1 2 3 4 ] => true hasPrefix [ 0 1 ] [ 1 2 3 4 ] => false Type. hasPrefix :: [a] -> [a] -> bool Arguments. [list1] [list2] Edit source. Noogle also knows. Aliases. lib.hasPrefix. lib.path.hasPrefix. lib.strings.hasPrefix.",
    "word_count": 59,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.hasPrefix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 39
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.hasPrefix. Whether the first list is a prefix of the second list. Example. hasPrefix [ 1 2 ] [ 1 2 3 4 ] =&gt; true hasPrefix [ 0 1 ] [ 1 2 3 4 ] =&gt; false Type. hasPrefix :: [a] -&gt; [a] -&gt; bool Arguments. [list1] [list2] Edit source. Noogle also knows. Aliases. lib.hasPrefix. lib.path.hasPrefix. lib.strings.hasPrefix.",
    "raw_url": "/f/lib/lists/hasPrefix.html",
    "excerpt": "lib.lists.hasPrefix. Whether the first list is a prefix of the second list. Example. hasPrefix [ 1 2 ] [ 1 2 3 4 ] =&gt; true hasPrefix [ 0 1",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/filter.html",
    "content": "lib.lists.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. builtins.filter. lib.filter. lib.strings.filter.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.filter Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. builtins.filter. lib.filter. lib.strings.filter.",
    "raw_url": "/f/lib/lists/filter.html",
    "excerpt": "lib.lists.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. builtins.filter. lib.filter. lib.strings.filter.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/removePrefix.html",
    "content": "lib.lists.removePrefix. Remove the first list as a prefix from the second list. Error if the first list isn't a prefix of the second list. Example. removePrefix [ 1 2 ] [ 1 2 3 4 ] => [ 3 4 ] removePrefix [ 0 1 ] [ 1 2 3 4 ] => <error> Type. removePrefix :: [a] -> [a] -> [a] Arguments. [list1] [list2] Edit source. Noogle also knows. Aliases. lib.removePrefix. lib.path.removePrefix. lib.strings.removePrefix.",
    "word_count": 74,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.removePrefix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 54
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 62
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.removePrefix. Remove the first list as a prefix from the second list. Error if the first list isn't a prefix of the second list. Example. removePrefix [ 1 2 ] [ 1 2 3 4 ] =&gt; [ 3 4 ] removePrefix [ 0 1 ] [ 1 2 3 4 ] =&gt; &lt;error&gt; Type. removePrefix :: [a] -&gt; [a] -&gt; [a] Arguments. [list1] [list2] Edit source. Noogle also knows. Aliases. lib.removePrefix. lib.path.removePrefix. lib.strings.removePrefix.",
    "raw_url": "/f/lib/lists/removePrefix.html",
    "excerpt": "lib.lists.removePrefix. Remove the first list as a prefix from the second list. Error if the first list isn't a prefix of the second list. Example. removePrefix [ 1 2 ]",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/concatMap.html",
    "content": "lib.lists.concatMap Primop. Takes 2 arguments. f, list. Map and concatenate the result. Example. concatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"] => [ \"a\" \"z\" \"b\" \"z\" ] Type. concatMap :: (a -> [b]) -> [a] -> [b] Edit source. Noogle also knows. Aliases. builtins.concatMap. lib.concatMap.",
    "word_count": 45,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.concatMap Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.concatMap Primop. Takes 2 arguments. f, list. Map and concatenate the result. Example. concatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"] =&gt; [ \"a\" \"z\" \"b\" \"z\" ] Type. concatMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b] Edit source. Noogle also knows. Aliases. builtins.concatMap. lib.concatMap.",
    "raw_url": "/f/lib/lists/concatMap.html",
    "excerpt": "lib.lists.concatMap Primop. Takes 2 arguments. f, list. Map and concatenate the result. Example. concatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"] =&gt; [ \"a\" \"z\" \"b\" \"z\" ] Type. concatMap ::",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/mutuallyExclusive.html",
    "content": "lib.lists.mutuallyExclusive. Test if two lists have no common element. It should be slightly more efficient than (intersectLists a b == []). Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.mutuallyExclusive.",
    "word_count": 31,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.mutuallyExclusive"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 21
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.mutuallyExclusive. Test if two lists have no common element. It should be slightly more efficient than (intersectLists a b == []). Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.mutuallyExclusive.",
    "raw_url": "/f/lib/lists/mutuallyExclusive.html",
    "excerpt": "lib.lists.mutuallyExclusive. Test if two lists have no common element. It should be slightly more efficient than (intersectLists a b == []). Arguments. [a] [b] Edit source. Noogle also knows. Aliases.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/foldl.html",
    "content": "lib.lists.foldl. “left fold”, like foldr, but from the left: foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n). Example. lconcat = foldl (a: b: a + b) \"z\" lconcat [ \"a\" \"b\" \"c\" ] => \"zabc\" # different types lstrange = foldl (str: int: str + toString (int + 1)) \"a\" lstrange [ 1 2 3 4 ] => \"a2345\" Type. foldl :: (b -> a -> b) -> b -> [a] -> b Arguments. [op] [nul] [list] Edit source. Noogle also knows. Aliases. lib.foldl.",
    "word_count": 93,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.foldl"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 68
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 82
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.foldl. “left fold”, like foldr, but from the left: foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n). Example. lconcat = foldl (a: b: a + b) \"z\" lconcat [ \"a\" \"b\" \"c\" ] =&gt; \"zabc\" # different types lstrange = foldl (str: int: str + toString (int + 1)) \"a\" lstrange [ 1 2 3 4 ] =&gt; \"a2345\" Type. foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b Arguments. [op] [nul] [list] Edit source. Noogle also knows. Aliases. lib.foldl.",
    "raw_url": "/f/lib/lists/foldl.html",
    "excerpt": "lib.lists.foldl. “left fold”, like foldr, but from the left: foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n). Example. lconcat = foldl",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/toposort.html",
    "content": "lib.lists.toposort. Sort a list based on a partial ordering using DFS. This implementation is O(N^2), if your ordering is linear, use sort instead. before a b == true means that b should be after a in the result. Example. toposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ] == { result = [ \"/\" \"/home\" \"/home/user\" \"other\" ]; } toposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ] == { cycle = [ \"/home/user\" \"/\" \"/\" ]; # path leading to a cycle loops = [ \"/\" ]; } # loops back to these elements toposort hasPrefix [ \"other\" \"/home/user\" \"/home\" \"/\" ] == { result = [ \"other\" \"/\" \"/home\" \"/home/user\" ]; } toposort (a: b: a < b) [ 3 2 1 ] == { result = [ 1 2 3 ]; } Arguments. [before] [list] Edit source. Noogle also knows. Aliases. lib.toposort.",
    "word_count": 144,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.toposort"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 38
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 134
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.toposort. Sort a list based on a partial ordering using DFS. This implementation is O(N^2), if your ordering is linear, use sort instead. before a b == true means that b should be after a in the result. Example. toposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ] == { result = [ \"/\" \"/home\" \"/home/user\" \"other\" ]; } toposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ] == { cycle = [ \"/home/user\" \"/\" \"/\" ]; # path leading to a cycle loops = [ \"/\" ]; } # loops back to these elements toposort hasPrefix [ \"other\" \"/home/user\" \"/home\" \"/\" ] == { result = [ \"other\" \"/\" \"/home\" \"/home/user\" ]; } toposort (a: b: a &lt; b) [ 3 2 1 ] == { result = [ 1 2 3 ]; } Arguments. [before] [list] Edit source. Noogle also knows. Aliases. lib.toposort.",
    "raw_url": "/f/lib/lists/toposort.html",
    "excerpt": "lib.lists.toposort. Sort a list based on a partial ordering using DFS. This implementation is O(N^2), if your ordering is linear, use sort instead. before a b == true means that",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/unique.html",
    "content": "lib.lists.unique. Remove duplicate elements from the list. O(n^2) complexity. Example. unique [ 3 2 3 4 ] => [ 3 2 4 ] Type. unique :: [a] -> [a] Edit source. Noogle also knows. Aliases. lib.types.unique. lib.unique.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.unique"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.unique. Remove duplicate elements from the list. O(n^2) complexity. Example. unique [ 3 2 3 4 ] =&gt; [ 3 2 4 ] Type. unique :: [a] -&gt; [a] Edit source. Noogle also knows. Aliases. lib.types.unique. lib.unique.",
    "raw_url": "/f/lib/lists/unique.html",
    "excerpt": "lib.lists.unique. Remove duplicate elements from the list. O(n^2) complexity. Example. unique [ 3 2 3 4 ] =&gt; [ 3 2 4 ] Type. unique :: [a] -&gt; [a] Edit",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/singleton.html",
    "content": "lib.lists.singleton. Create a list consisting of a single element. singleton x is sometimes more convenient with respect to indentation than [x] when x spans multiple lines. Example. singleton \"foo\" => [ \"foo\" ] Type. singleton :: a -> [a] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.singleton.",
    "word_count": 48,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.singleton"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 33
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.singleton. Create a list consisting of a single element. singleton x is sometimes more convenient with respect to indentation than [x] when x spans multiple lines. Example. singleton \"foo\" =&gt; [ \"foo\" ] Type. singleton :: a -&gt; [a] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.singleton.",
    "raw_url": "/f/lib/lists/singleton.html",
    "excerpt": "lib.lists.singleton. Create a list consisting of a single element. singleton x is sometimes more convenient with respect to indentation than [x] when x spans multiple lines. Example. singleton \"foo\" =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/sublist.html",
    "content": "lib.lists.sublist. Return a list consisting of at most count elements of list, starting at index start. Example. sublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ] => [ \"b\" \"c\" \"d\" ] sublist 1 3 [ ] => [ ] Type. sublist :: int -> int -> [a] -> [a] Arguments. [start] Index at which to start the sublist. [count] Number of elements to take. [list] Input list. Edit source. Noogle also knows. Aliases. lib.sublist.",
    "word_count": 76,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.sublist"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 41
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 51
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.sublist. Return a list consisting of at most count elements of list, starting at index start. Example. sublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ] =&gt; [ \"b\" \"c\" \"d\" ] sublist 1 3 [ ] =&gt; [ ] Type. sublist :: int -&gt; int -&gt; [a] -&gt; [a] Arguments. [start] Index at which to start the sublist. [count] Number of elements to take. [list] Input list. Edit source. Noogle also knows. Aliases. lib.sublist.",
    "raw_url": "/f/lib/lists/sublist.html",
    "excerpt": "lib.lists.sublist. Return a list consisting of at most count elements of list, starting at index start. Example. sublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ] =&gt; [ \"b\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/intersectLists.html",
    "content": "lib.lists.intersectLists. Intersects list 'e' and another list. O(nm) complexity. Example. intersectLists [ 1 2 3 ] [ 6 3 2 ] => [ 3 2 ] Arguments. [e] Edit source. Noogle also knows. Aliases. lib.intersectLists.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.intersectLists"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.intersectLists. Intersects list 'e' and another list. O(nm) complexity. Example. intersectLists [ 1 2 3 ] [ 6 3 2 ] =&gt; [ 3 2 ] Arguments. [e] Edit source. Noogle also knows. Aliases. lib.intersectLists.",
    "raw_url": "/f/lib/lists/intersectLists.html",
    "excerpt": "lib.lists.intersectLists. Intersects list 'e' and another list. O(nm) complexity. Example. intersectLists [ 1 2 3 ] [ 6 3 2 ] =&gt; [ 3 2 ] Arguments. [e] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/commonPrefix.html",
    "content": "lib.lists.commonPrefix. The common prefix of two lists. Example. commonPrefix [ 1 2 3 4 5 6 ] [ 1 2 4 8 ] => [ 1 2 ] commonPrefix [ 1 2 3 ] [ 1 2 3 4 5 ] => [ 1 2 3 ] commonPrefix [ 1 2 3 ] [ 4 5 6 ] => [ ] Type. commonPrefix :: [a] -> [a] -> [a] Arguments. [list1] [list2] Edit source.",
    "word_count": 74,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.commonPrefix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 7
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 61
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 69
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.commonPrefix. The common prefix of two lists. Example. commonPrefix [ 1 2 3 4 5 6 ] [ 1 2 4 8 ] =&gt; [ 1 2 ] commonPrefix [ 1 2 3 ] [ 1 2 3 4 5 ] =&gt; [ 1 2 3 ] commonPrefix [ 1 2 3 ] [ 4 5 6 ] =&gt; [ ] Type. commonPrefix :: [a] -&gt; [a] -&gt; [a] Arguments. [list1] [list2] Edit source.",
    "raw_url": "/f/lib/lists/commonPrefix.html",
    "excerpt": "lib.lists.commonPrefix. The common prefix of two lists. Example. commonPrefix [ 1 2 3 4 5 6 ] [ 1 2 4 8 ] =&gt; [ 1 2 ] commonPrefix [",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/concatLists.html",
    "content": "lib.lists.concatLists Primop. Takes 1 arguments. lists. Concatenate a list of lists into a single list. Noogle also knows. Aliases. builtins.concatLists. lib.concatLists.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.concatLists Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.concatLists Primop. Takes 1 arguments. lists. Concatenate a list of lists into a single list. Noogle also knows. Aliases. builtins.concatLists. lib.concatLists.",
    "raw_url": "/f/lib/lists/concatLists.html",
    "excerpt": "lib.lists.concatLists Primop. Takes 1 arguments. lists. Concatenate a list of lists into a single list. Noogle also knows. Aliases. builtins.concatLists. lib.concatLists.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/isList.html",
    "content": "lib.lists.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. builtins.isList. lib.isList. lib.strings.isList.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.isList Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. builtins.isList. lib.isList. lib.strings.isList.",
    "raw_url": "/f/lib/lists/isList.html",
    "excerpt": "lib.lists.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. builtins.isList. lib.isList. lib.strings.isList.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/partition.html",
    "content": "lib.lists.partition Primop. Takes 2 arguments. pred, list. Splits the elements of a list in two lists, right and wrong, depending on the evaluation of a predicate. Example. partition (x: x > 2) [ 5 1 2 3 4 ] => { right = [ 5 3 4 ]; wrong = [ 1 2 ]; } Type. (a -> bool) -> [a] -> { right :: [a]; wrong :: [a]; } Edit source. Noogle also knows. Aliases. builtins.partition. lib.partition.",
    "word_count": 78,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.partition Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.partition Primop. Takes 2 arguments. pred, list. Splits the elements of a list in two lists, right and wrong, depending on the evaluation of a predicate. Example. partition (x: x &gt; 2) [ 5 1 2 3 4 ] =&gt; { right = [ 5 3 4 ]; wrong = [ 1 2 ]; } Type. (a -&gt; bool) -&gt; [a] -&gt; { right :: [a]; wrong :: [a]; } Edit source. Noogle also knows. Aliases. builtins.partition. lib.partition.",
    "raw_url": "/f/lib/lists/partition.html",
    "excerpt": "lib.lists.partition Primop. Takes 2 arguments. pred, list. Splits the elements of a list in two lists, right and wrong, depending on the evaluation of a predicate. Example. partition (x: x",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/range.html",
    "content": "lib.lists.range. Return a list of integers from first up to and including last. Example. range 2 4 => [ 2 3 4 ] range 3 2 => [ ] Type. range :: int -> int -> [int] Arguments. [first] First integer in the range. [last] Last integer in the range. Edit source. Noogle also knows. Aliases. lib.range.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.range"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 29
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 37
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.range. Return a list of integers from first up to and including last. Example. range 2 4 =&gt; [ 2 3 4 ] range 3 2 =&gt; [ ] Type. range :: int -&gt; int -&gt; [int] Arguments. [first] First integer in the range. [last] Last integer in the range. Edit source. Noogle also knows. Aliases. lib.range.",
    "raw_url": "/f/lib/lists/range.html",
    "excerpt": "lib.lists.range. Return a list of integers from first up to and including last. Example. range 2 4 =&gt; [ 2 3 4 ] range 3 2 =&gt; [ ] Type.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/crossLists.html",
    "content": "lib.lists.crossLists. Return the image of the cross product of some lists by a function. Example. crossLists (x:y: \"${toString x}${toString y}\") [[1 2] [3 4]] => [ \"13\" \"14\" \"23\" \"24\" ] Edit source. Noogle also knows. Aliases. lib.crossLists.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.crossLists"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.crossLists. Return the image of the cross product of some lists by a function. Example. crossLists (x:y: \"${toString x}${toString y}\") [[1 2] [3 4]] =&gt; [ \"13\" \"14\" \"23\" \"24\" ] Edit source. Noogle also knows. Aliases. lib.crossLists.",
    "raw_url": "/f/lib/lists/crossLists.html",
    "excerpt": "lib.lists.crossLists. Return the image of the cross product of some lists by a function. Example. crossLists (x:y: \"${toString x}${toString y}\") [[1 2] [3 4]] =&gt; [ \"13\" \"14\" \"23\" \"24\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/map.html",
    "content": "lib.lists.map Primop. Takes 2 arguments. f, list. Apply the function f to each element in the list list. For example, map (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ] evaluates to [ \"foobar\" \"foobla\" \"fooabc\" ]. Noogle also knows. Aliases. builtins.map.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.map Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.map Primop. Takes 2 arguments. f, list. Apply the function f to each element in the list list. For example, map (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ] evaluates to [ \"foobar\" \"foobla\" \"fooabc\" ]. Noogle also knows. Aliases. builtins.map.",
    "raw_url": "/f/lib/lists/map.html",
    "excerpt": "lib.lists.map Primop. Takes 2 arguments. f, list. Apply the function f to each element in the list list. For example, map (x: \"foo\" + x) [ \"bar\" \"bla\" \"abc\" ]",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/sort.html",
    "content": "lib.lists.sort Primop. Takes 2 arguments. comparator, list. Sort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the second argument. The returned list is sorted in an increasing order. The implementation does a quick-sort. Example. sort (a: b: a < b) [ 5 3 7 ] => [ 3 5 7 ] Edit source. Noogle also knows. Aliases. builtins.sort. lib.sort.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.sort Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 46
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.sort Primop. Takes 2 arguments. comparator, list. Sort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the second argument. The returned list is sorted in an increasing order. The implementation does a quick-sort. Example. sort (a: b: a &lt; b) [ 5 3 7 ] =&gt; [ 3 5 7 ] Edit source. Noogle also knows. Aliases. builtins.sort. lib.sort.",
    "raw_url": "/f/lib/lists/sort.html",
    "excerpt": "lib.lists.sort Primop. Takes 2 arguments. comparator, list. Sort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/length.html",
    "content": "lib.lists.length Primop. Takes 1 arguments. e. Return the length of the list e. Noogle also knows. Aliases. builtins.length. lib.length.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.length Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.length Primop. Takes 1 arguments. e. Return the length of the list e. Noogle also knows. Aliases. builtins.length. lib.length.",
    "raw_url": "/f/lib/lists/length.html",
    "excerpt": "lib.lists.length Primop. Takes 1 arguments. e. Return the length of the list e. Noogle also knows. Aliases. builtins.length. lib.length.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/findFirst.html",
    "content": "lib.lists.findFirst. Find the first element in the list matching the specified predicate or return default if no such element exists. Example. findFirst (x: x > 3) 7 [ 1 6 4 ] => 6 findFirst (x: x > 9) 7 [ 1 6 4 ] => 7 Type. findFirst :: (a -> bool) -> a -> [a] -> a Arguments. [pred] Predicate. [default] Default value to return. [list] Input list. Edit source. Noogle also knows. Aliases. lib.findFirst.",
    "word_count": 77,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.findFirst"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 59
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.findFirst. Find the first element in the list matching the specified predicate or return default if no such element exists. Example. findFirst (x: x &gt; 3) 7 [ 1 6 4 ] =&gt; 6 findFirst (x: x &gt; 9) 7 [ 1 6 4 ] =&gt; 7 Type. findFirst :: (a -&gt; bool) -&gt; a -&gt; [a] -&gt; a Arguments. [pred] Predicate. [default] Default value to return. [list] Input list. Edit source. Noogle also knows. Aliases. lib.findFirst.",
    "raw_url": "/f/lib/lists/findFirst.html",
    "excerpt": "lib.lists.findFirst. Find the first element in the list matching the specified predicate or return default if no such element exists. Example. findFirst (x: x &gt; 3) 7 [ 1 6",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/remove.html",
    "content": "lib.lists.remove. Remove elements equal to 'e' from a list. Useful for buildInputs. Example. remove 3 [ 1 3 4 3 ] => [ 1 4 ] Type. remove :: a -> [a] -> [a] Arguments. [e] Element to remove from the list. Edit source. Noogle also knows. Aliases. lib.remove.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.remove"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 26
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 34
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.remove. Remove elements equal to 'e' from a list. Useful for buildInputs. Example. remove 3 [ 1 3 4 3 ] =&gt; [ 1 4 ] Type. remove :: a -&gt; [a] -&gt; [a] Arguments. [e] Element to remove from the list. Edit source. Noogle also knows. Aliases. lib.remove.",
    "raw_url": "/f/lib/lists/remove.html",
    "excerpt": "lib.lists.remove. Remove elements equal to 'e' from a list. Useful for buildInputs. Example. remove 3 [ 1 3 4 3 ] =&gt; [ 1 4 ] Type. remove :: a",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/foldl'.html",
    "content": "lib.lists.foldl' (Prime). Reduce a list by applying a binary operator from left to right, starting with an initial accumulator. Before each application of the operator, the accumulator value is evaluated. This behavior makes this function stricter than foldl. Unlike builtins.foldl', the initial accumulator argument is evaluated before the first iteration. A call like. foldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ] is (denotationally) equivalent to the following, but with the added benefit that foldl' itself will never overflow the stack. let acc₁ = builtins.seq acc₀ (op acc₀ x₀ ); acc₂ = builtins.seq acc₁ (op acc₁ x₁ ); acc₃ = builtins.seq acc₂ (op acc₂ x₂ ); ... accₙ = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁); accₙ₊₁ = builtins.seq accₙ (op accₙ xₙ ); in accₙ₊₁ # Or ignoring builtins.seq op (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ Example. foldl' (acc: x: acc + x) 0 [1 2 3] => 6 Type. foldl' :: (acc -> x -> acc) -> acc -> [x] -> acc Arguments. [op] The binary operation to run, where the two arguments are: acc: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration. x: The corresponding list element for this iteration. [acc] The initial accumulator value. [list] The list to fold. Edit source. Noogle also knows. Aliases. lib.foldl'",
    "word_count": 227,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.foldl' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 143
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 156
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 170
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.foldl' (Prime). Reduce a list by applying a binary operator from left to right, starting with an initial accumulator. Before each application of the operator, the accumulator value is evaluated. This behavior makes this function stricter than foldl. Unlike builtins.foldl', the initial accumulator argument is evaluated before the first iteration. A call like. foldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ] is (denotationally) equivalent to the following, but with the added benefit that foldl' itself will never overflow the stack. let acc₁ = builtins.seq acc₀ (op acc₀ x₀ ); acc₂ = builtins.seq acc₁ (op acc₁ x₁ ); acc₃ = builtins.seq acc₂ (op acc₂ x₂ ); ... accₙ = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁); accₙ₊₁ = builtins.seq accₙ (op accₙ xₙ ); in accₙ₊₁ # Or ignoring builtins.seq op (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ Example. foldl' (acc: x: acc + x) 0 [1 2 3] =&gt; 6 Type. foldl' :: (acc -&gt; x -&gt; acc) -&gt; acc -&gt; [x] -&gt; acc Arguments. [op] The binary operation to run, where the two arguments are: acc: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration. x: The corresponding list element for this iteration. [acc] The initial accumulator value. [list] The list to fold. Edit source. Noogle also knows. Aliases. lib.foldl'",
    "raw_url": "/f/lib/lists/foldl'.html",
    "excerpt": "lib.lists.foldl' (Prime). Reduce a list by applying a binary operator from left to right, starting with an initial accumulator. Before each application of the operator, the accumulator value is evaluated.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/compareLists.html",
    "content": "lib.lists.compareLists. Compare two lists element-by-element. Example. compareLists compare [] [] => 0 compareLists compare [] [ \"a\" ] => -1 compareLists compare [ \"a\" ] [] => 1 compareLists compare [ \"a\" \"b\" ] [ \"a\" \"c\" ] => -1 Arguments. [cmp] [a] [b] Edit source. Noogle also knows. Aliases. lib.compareLists.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.compareLists"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 5
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.compareLists. Compare two lists element-by-element. Example. compareLists compare [] [] =&gt; 0 compareLists compare [] [ \"a\" ] =&gt; -1 compareLists compare [ \"a\" ] [] =&gt; 1 compareLists compare [ \"a\" \"b\" ] [ \"a\" \"c\" ] =&gt; -1 Arguments. [cmp] [a] [b] Edit source. Noogle also knows. Aliases. lib.compareLists.",
    "raw_url": "/f/lib/lists/compareLists.html",
    "excerpt": "lib.lists.compareLists. Compare two lists element-by-element. Example. compareLists compare [] [] =&gt; 0 compareLists compare [] [ \"a\" ] =&gt; -1 compareLists compare [ \"a\" ] [] =&gt; 1 compareLists compare",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/fold.html",
    "content": "lib.lists.fold. fold is an alias of foldr for historic reasons. Edit source. Noogle also knows. Aliases. lib.fold.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.fold"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.fold. fold is an alias of foldr for historic reasons. Edit source. Noogle also knows. Aliases. lib.fold.",
    "raw_url": "/f/lib/lists/fold.html",
    "excerpt": "lib.lists.fold. fold is an alias of foldr for historic reasons. Edit source. Noogle also knows. Aliases. lib.fold.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/groupBy.html",
    "content": "lib.lists.groupBy Primop. Takes 2 arguments. f, list. Groups elements of list together by the string returned from the function f called on each element. It returns an attribute set where each attribute value contains the elements of list that are mapped to the same corresponding attribute name returned by f. For example, builtins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"] evaluates to. { b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; } Noogle also knows. Aliases. builtins.groupBy. lib.groupBy.",
    "word_count": 80,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.groupBy Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.groupBy Primop. Takes 2 arguments. f, list. Groups elements of list together by the string returned from the function f called on each element. It returns an attribute set where each attribute value contains the elements of list that are mapped to the same corresponding attribute name returned by f. For example, builtins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"] evaluates to. { b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; } Noogle also knows. Aliases. builtins.groupBy. lib.groupBy.",
    "raw_url": "/f/lib/lists/groupBy.html",
    "excerpt": "lib.lists.groupBy Primop. Takes 2 arguments. f, list. Groups elements of list together by the string returned from the function f called on each element. It returns an attribute set where",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/imap0.html",
    "content": "lib.lists.imap0. Map with index starting from 0. Example. imap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] => [ \"a-0\" \"b-1\" ] Type. imap0 :: (int -> a -> b) -> [a] -> [b] Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.imap0.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.imap0"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 7
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.imap0. Map with index starting from 0. Example. imap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] =&gt; [ \"a-0\" \"b-1\" ] Type. imap0 :: (int -&gt; a -&gt; b) -&gt; [a] -&gt; [b] Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.imap0.",
    "raw_url": "/f/lib/lists/imap0.html",
    "excerpt": "lib.lists.imap0. Map with index starting from 0. Example. imap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] =&gt; [ \"a-0\" \"b-1\" ] Type. imap0 :: (int -&gt; a -&gt; b) -&gt; [a]",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/tail.html",
    "content": "lib.lists.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should generally be avoided since it's inefficient: unlike Haskell's tail, it takes O(n) time, so recursing over a list by repeatedly calling tail takes O(n^2) time. Noogle also knows. Aliases. builtins.tail. lib.tail. lib.strings.tail.",
    "word_count": 62,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.tail Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should generally be avoided since it's inefficient: unlike Haskell's tail, it takes O(n) time, so recursing over a list by repeatedly calling tail takes O(n^2) time. Noogle also knows. Aliases. builtins.tail. lib.tail. lib.strings.tail.",
    "raw_url": "/f/lib/lists/tail.html",
    "excerpt": "lib.lists.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/elemAt.html",
    "content": "lib.lists.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of bounds. Noogle also knows. Aliases. builtins.elemAt. lib.elemAt. lib.strings.elemAt.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.elemAt Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of bounds. Noogle also knows. Aliases. builtins.elemAt. lib.elemAt. lib.strings.elemAt.",
    "raw_url": "/f/lib/lists/elemAt.html",
    "excerpt": "lib.lists.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/flatten.html",
    "content": "lib.lists.flatten. Flatten the argument into a single list; that is, nested lists are spliced into the top-level lists. Example. flatten [1 [2 [3] 4] 5] => [1 2 3 4 5] flatten 1 => [1] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.flatten.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.flatten"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.flatten. Flatten the argument into a single list; that is, nested lists are spliced into the top-level lists. Example. flatten [1 [2 [3] 4] 5] =&gt; [1 2 3 4 5] flatten 1 =&gt; [1] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.flatten.",
    "raw_url": "/f/lib/lists/flatten.html",
    "excerpt": "lib.lists.flatten. Flatten the argument into a single list; that is, nested lists are spliced into the top-level lists. Example. flatten [1 [2 [3] 4] 5] =&gt; [1 2 3 4",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/any.html",
    "content": "lib.lists.any Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for at least one element of list. Example. any isString [ 1 \"a\" { } ] => true any isString [ 1 { } ] => false Type. any :: (a -> bool) -> [a] -> bool Edit source. Noogle also knows. Aliases. builtins.any. lib.any.",
    "word_count": 59,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.any Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 21
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.any Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for at least one element of list. Example. any isString [ 1 \"a\" { } ] =&gt; true any isString [ 1 { } ] =&gt; false Type. any :: (a -&gt; bool) -&gt; [a] -&gt; bool Edit source. Noogle also knows. Aliases. builtins.any. lib.any.",
    "raw_url": "/f/lib/lists/any.html",
    "excerpt": "lib.lists.any Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for at least one element of list. Example. any isString [ 1 \"a\" { } ]",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/findSingle.html",
    "content": "lib.lists.findSingle. Find the sole element in the list matching the specified predicate, returns default if no such element exists, or multiple if there are multiple matching elements. Example. findSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ] => \"multiple\" findSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ] => 3 findSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ] => \"none\" Type. findSingle :: (a -> bool) -> a -> a -> [a] -> a Arguments. [pred] Predicate. [default] Default value to return if element was not found. [multiple] Default value to return if more than one element was found. [list] Input list. Edit source. Noogle also knows. Aliases. lib.findSingle.",
    "word_count": 117,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.findSingle"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 27
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 68
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 82
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.findSingle. Find the sole element in the list matching the specified predicate, returns default if no such element exists, or multiple if there are multiple matching elements. Example. findSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ] =&gt; \"multiple\" findSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ] =&gt; 3 findSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ] =&gt; \"none\" Type. findSingle :: (a -&gt; bool) -&gt; a -&gt; a -&gt; [a] -&gt; a Arguments. [pred] Predicate. [default] Default value to return if element was not found. [multiple] Default value to return if more than one element was found. [list] Input list. Edit source. Noogle also knows. Aliases. lib.findSingle.",
    "raw_url": "/f/lib/lists/findSingle.html",
    "excerpt": "lib.lists.findSingle. Find the sole element in the list matching the specified predicate, returns default if no such element exists, or multiple if there are multiple matching elements. Example. findSingle (x:",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/reverseList.html",
    "content": "lib.lists.reverseList. Reverse the order of the elements of a list. Example. reverseList [ \"b\" \"o\" \"j\" ] => [ \"j\" \"o\" \"b\" ] Type. reverseList :: [a] -> [a] Arguments. [xs] Edit source. Noogle also knows. Aliases. lib.reverseList.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.reverseList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.reverseList. Reverse the order of the elements of a list. Example. reverseList [ \"b\" \"o\" \"j\" ] =&gt; [ \"j\" \"o\" \"b\" ] Type. reverseList :: [a] -&gt; [a] Arguments. [xs] Edit source. Noogle also knows. Aliases. lib.reverseList.",
    "raw_url": "/f/lib/lists/reverseList.html",
    "excerpt": "lib.lists.reverseList. Reverse the order of the elements of a list. Example. reverseList [ \"b\" \"o\" \"j\" ] =&gt; [ \"j\" \"o\" \"b\" ] Type. reverseList :: [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/last.html",
    "content": "lib.lists.last. Return the last element of a list. This function throws an error if the list is empty. Example. last [ 1 2 3 ] => 3 Type. last :: [a] -> a Arguments. [list] Edit source. Noogle also knows. Aliases. lib.last.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.last"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 27
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 33
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.last. Return the last element of a list. This function throws an error if the list is empty. Example. last [ 1 2 3 ] =&gt; 3 Type. last :: [a] -&gt; a Arguments. [list] Edit source. Noogle also knows. Aliases. lib.last.",
    "raw_url": "/f/lib/lists/last.html",
    "excerpt": "lib.lists.last. Return the last element of a list. This function throws an error if the list is empty. Example. last [ 1 2 3 ] =&gt; 3 Type. last ::",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/elem.html",
    "content": "lib.lists.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. builtins.elem. lib.elem. lib.strings.elem.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.elem Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. builtins.elem. lib.elem. lib.strings.elem.",
    "raw_url": "/f/lib/lists/elem.html",
    "excerpt": "lib.lists.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. builtins.elem. lib.elem. lib.strings.elem.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/toList.html",
    "content": "lib.lists.toList. If argument is a list, return it; else, wrap it in a singleton list. If you're using this, you should almost certainly reconsider if there isn't a more \"well-typed\" approach. Example. toList [ 1 2 ] => [ 1 2 ] toList \"hi\" => [ \"hi \"] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.toList.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.toList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 48
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.toList. If argument is a list, return it; else, wrap it in a singleton list. If you're using this, you should almost certainly reconsider if there isn't a more \"well-typed\" approach. Example. toList [ 1 2 ] =&gt; [ 1 2 ] toList \"hi\" =&gt; [ \"hi \"] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.toList.",
    "raw_url": "/f/lib/lists/toList.html",
    "excerpt": "lib.lists.toList. If argument is a list, return it; else, wrap it in a singleton list. If you're using this, you should almost certainly reconsider if there isn't a more \"well-typed\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/zipListsWith.html",
    "content": "lib.lists.zipListsWith. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. How both lists are merged is defined by the first argument. Example. zipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"] => [\"he\" \"lo\"] Type. zipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c] Arguments. [f] Function to zip elements of both lists. [fst] First list. [snd] Second list. Edit source. Noogle also knows. Aliases. lib.zipListsWith.",
    "word_count": 82,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.zipListsWith"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 32
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 46
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 60
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.zipListsWith. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. How both lists are merged is defined by the first argument. Example. zipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"] =&gt; [\"he\" \"lo\"] Type. zipListsWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c] Arguments. [f] Function to zip elements of both lists. [fst] First list. [snd] Second list. Edit source. Noogle also knows. Aliases. lib.zipListsWith.",
    "raw_url": "/f/lib/lists/zipListsWith.html",
    "excerpt": "lib.lists.zipListsWith. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. How both lists are merged is defined by the",
    "sub_results": []
  },
  {
    "url": "/f/lib/lists/groupBy'.html",
    "content": "lib.lists.groupBy' (Prime). Splits the elements of a list into many lists, using the return value of a predicate. Predicate should return a string which becomes keys of attrset groupBy returns. groupBy' allows to customise the combining function and initial value. Example. groupBy (x: boolToString (x > 2)) [ 5 1 2 3 4 ] => { true = [ 5 3 4 ]; false = [ 1 2 ]; } groupBy (x: x.name) [ {name = \"icewm\"; script = \"icewm &\";} {name = \"xfce\"; script = \"xfce4-session &\";} {name = \"icewm\"; script = \"icewmbg &\";} {name = \"mate\"; script = \"gnome-session &\";} ] => { icewm = [ { name = \"icewm\"; script = \"icewm &\"; } { name = \"icewm\"; script = \"icewmbg &\"; } ]; mate = [ { name = \"mate\"; script = \"gnome-session &\"; } ]; xfce = [ { name = \"xfce\"; script = \"xfce4-session &\"; } ]; } groupBy' builtins.add 0 (x: boolToString (x > 2)) [ 5 1 2 3 4 ] => { true = 12; false = 3; } Arguments. [op] [nul] [pred] [lst] Edit source. Noogle also knows. Aliases. lib.groupBy'",
    "word_count": 190,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lists.groupBy' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 40
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 178
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lists.groupBy' (Prime). Splits the elements of a list into many lists, using the return value of a predicate. Predicate should return a string which becomes keys of attrset groupBy returns. groupBy' allows to customise the combining function and initial value. Example. groupBy (x: boolToString (x &gt; 2)) [ 5 1 2 3 4 ] =&gt; { true = [ 5 3 4 ]; false = [ 1 2 ]; } groupBy (x: x.name) [ {name = \"icewm\"; script = \"icewm &\";} {name = \"xfce\"; script = \"xfce4-session &\";} {name = \"icewm\"; script = \"icewmbg &\";} {name = \"mate\"; script = \"gnome-session &\";} ] =&gt; { icewm = [ { name = \"icewm\"; script = \"icewm &\"; } { name = \"icewm\"; script = \"icewmbg &\"; } ]; mate = [ { name = \"mate\"; script = \"gnome-session &\"; } ]; xfce = [ { name = \"xfce\"; script = \"xfce4-session &\"; } ]; } groupBy' builtins.add 0 (x: boolToString (x &gt; 2)) [ 5 1 2 3 4 ] =&gt; { true = 12; false = 3; } Arguments. [op] [nul] [pred] [lst] Edit source. Noogle also knows. Aliases. lib.groupBy'",
    "raw_url": "/f/lib/lists/groupBy'.html",
    "excerpt": "lib.lists.groupBy' (Prime). Splits the elements of a list into many lists, using the return value of a predicate. Predicate should return a string which becomes keys of attrset groupBy returns.",
    "sub_results": []
  },
  {
    "url": "/f/lib/nvs.html",
    "content": "lib.nvs. Edit source. Noogle also knows. Aliases. lib.misc.nvs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.nvs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.nvs. Edit source. Noogle also knows. Aliases. lib.misc.nvs.",
    "raw_url": "/f/lib/nvs.html",
    "excerpt": "lib.nvs. Edit source. Noogle also knows. Aliases. lib.misc.nvs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeDefinitions.html",
    "content": "lib.mergeDefinitions. Edit source. Noogle also knows. Aliases. lib.modules.mergeDefinitions.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeDefinitions"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeDefinitions. Edit source. Noogle also knows. Aliases. lib.modules.mergeDefinitions.",
    "raw_url": "/f/lib/mergeDefinitions.html",
    "excerpt": "lib.mergeDefinitions. Edit source. Noogle also knows. Aliases. lib.modules.mergeDefinitions.",
    "sub_results": []
  },
  {
    "url": "/f/lib/isPath.html",
    "content": "lib.isPath Primop. Takes 1 arguments. e. Return true if e evaluates to a path, and false otherwise. Noogle also knows. Aliases. builtins.isPath. lib.strings.isPath.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isPath Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isPath Primop. Takes 1 arguments. e. Return true if e evaluates to a path, and false otherwise. Noogle also knows. Aliases. builtins.isPath. lib.strings.isPath.",
    "raw_url": "/f/lib/isPath.html",
    "excerpt": "lib.isPath Primop. Takes 1 arguments. e. Return true if e evaluates to a path, and false otherwise. Noogle also knows. Aliases. builtins.isPath. lib.strings.isPath.",
    "sub_results": []
  },
  {
    "url": "/f/lib/concatImapStringsSep.html",
    "content": "lib.concatImapStringsSep. Same as concatMapStringsSep, but the mapping function additionally receives the position of its argument. Example. concatImapStringsSep \"-\" (pos: x: toString (x / pos)) [ 6 6 6 ] => \"6-3-2\" Type. concatIMapStringsSep :: string -> (int -> a -> string) -> [a] -> string Arguments. [sep] Separator to add between elements. [f] Function that receives elements and their positions. [list] List of input strings. Edit source. Noogle also knows. Aliases. lib.strings.concatImapStringsSep.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concatImapStringsSep"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 45
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concatImapStringsSep. Same as concatMapStringsSep, but the mapping function additionally receives the position of its argument. Example. concatImapStringsSep \"-\" (pos: x: toString (x / pos)) [ 6 6 6 ] =&gt; \"6-3-2\" Type. concatIMapStringsSep :: string -&gt; (int -&gt; a -&gt; string) -&gt; [a] -&gt; string Arguments. [sep] Separator to add between elements. [f] Function that receives elements and their positions. [list] List of input strings. Edit source. Noogle also knows. Aliases. lib.strings.concatImapStringsSep.",
    "raw_url": "/f/lib/concatImapStringsSep.html",
    "excerpt": "lib.concatImapStringsSep. Same as concatMapStringsSep, but the mapping function additionally receives the position of its argument. Example. concatImapStringsSep \"-\" (pos: x: toString (x / pos)) [ 6 6 6 ] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/setPrio.html",
    "content": "lib.setPrio. Set the nix-env priority of the package. Arguments. [priority] Edit source. Noogle also knows. Aliases. lib.meta.setPrio.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.setPrio"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.setPrio. Set the nix-env priority of the package. Arguments. [priority] Edit source. Noogle also knows. Aliases. lib.meta.setPrio.",
    "raw_url": "/f/lib/setPrio.html",
    "excerpt": "lib.setPrio. Set the nix-env priority of the package. Arguments. [priority] Edit source. Noogle also knows. Aliases. lib.meta.setPrio.",
    "sub_results": []
  },
  {
    "url": "/f/lib/toInt.html",
    "content": "lib.toInt. Parse a string as an int. Does not support parsing of integers with preceding zero due to ambiguity between zero-padded and octal numbers. See toIntBase10. Example. toInt \"1337\" => 1337 toInt \"-4\" => -4 toInt \" 123 \" => 123 toInt \"00024\" => error: Ambiguity in interpretation of 00024 between octal and zero padded integer. toInt \"3.14\" => error: floating point JSON numbers are not supported Type. string -> int Arguments. [str] Edit source. Noogle also knows. Aliases. lib.strings.toInt.",
    "word_count": 80,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toInt"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 67
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 71
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toInt. Parse a string as an int. Does not support parsing of integers with preceding zero due to ambiguity between zero-padded and octal numbers. See toIntBase10. Example. toInt \"1337\" =&gt; 1337 toInt \"-4\" =&gt; -4 toInt \" 123 \" =&gt; 123 toInt \"00024\" =&gt; error: Ambiguity in interpretation of 00024 between octal and zero padded integer. toInt \"3.14\" =&gt; error: floating point JSON numbers are not supported Type. string -&gt; int Arguments. [str] Edit source. Noogle also knows. Aliases. lib.strings.toInt.",
    "raw_url": "/f/lib/toInt.html",
    "excerpt": "lib.toInt. Parse a string as an int. Does not support parsing of integers with preceding zero due to ambiguity between zero-padded and octal numbers. See toIntBase10. Example. toInt \"1337\" =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/showOption.html",
    "content": "lib.showOption. Convert an option, described as a list of the option parts to a human-readable version. Example. (showOption [\"foo\" \"bar\" \"baz\"]) == \"foo.bar.baz\" (showOption [\"foo\" \"bar.baz\" \"tux\"]) == \"foo.\\\"bar.baz\\\".tux\" (showOption [\"windowManager\" \"2bwm\" \"enable\"]) == \"windowManager.\\\"2bwm\\\".enable\" Placeholders will not be quoted as they are not actual values: (showOption [\"foo\" \"*\" \"bar\"]) == \"foo.*.bar\" (showOption [\"foo\" \"<name>\" \"bar\"]) == \"foo.<name>.bar\" Arguments. [parts] Edit source. Noogle also knows. Aliases. lib.options.showOption.",
    "word_count": 67,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.showOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 58
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.showOption. Convert an option, described as a list of the option parts to a human-readable version. Example. (showOption [\"foo\" \"bar\" \"baz\"]) == \"foo.bar.baz\" (showOption [\"foo\" \"bar.baz\" \"tux\"]) == \"foo.\\\"bar.baz\\\".tux\" (showOption [\"windowManager\" \"2bwm\" \"enable\"]) == \"windowManager.\\\"2bwm\\\".enable\" Placeholders will not be quoted as they are not actual values: (showOption [\"foo\" \"*\" \"bar\"]) == \"foo.*.bar\" (showOption [\"foo\" \"&lt;name&gt;\" \"bar\"]) == \"foo.&lt;name&gt;.bar\" Arguments. [parts] Edit source. Noogle also knows. Aliases. lib.options.showOption.",
    "raw_url": "/f/lib/showOption.html",
    "excerpt": "lib.showOption. Convert an option, described as a list of the option parts to a human-readable version. Example. (showOption [\"foo\" \"bar\" \"baz\"]) == \"foo.bar.baz\" (showOption [\"foo\" \"bar.baz\" \"tux\"]) == \"foo.\\\"bar.baz\\\".tux\" (showOption",
    "sub_results": []
  },
  {
    "url": "/f/lib/kernel/freeform.html",
    "content": "lib.kernel.freeform. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.kernel.freeform"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.kernel.freeform. Edit source.",
    "raw_url": "/f/lib/kernel/freeform.html",
    "excerpt": "lib.kernel.freeform. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/kernel/whenHelpers.html",
    "content": "lib.kernel.whenHelpers. Common patterns/legacy used in common-config/hardened/config.nix. Arguments. [version] Edit source.",
    "word_count": 10,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.kernel.whenHelpers"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 6
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.kernel.whenHelpers. Common patterns/legacy used in common-config/hardened/config.nix. Arguments. [version] Edit source.",
    "raw_url": "/f/lib/kernel/whenHelpers.html",
    "excerpt": "lib.kernel.whenHelpers. Common patterns/legacy used in common-config/hardened/config.nix. Arguments. [version] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/kernel/option.html",
    "content": "lib.kernel.option. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.kernel.option"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.kernel.option. Edit source.",
    "raw_url": "/f/lib/kernel/option.html",
    "excerpt": "lib.kernel.option. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/toHexString.html",
    "content": "lib.toHexString. Convert the given positive integer to a string of its hexadecimal representation. For example: toHexString 0 => \"0\" toHexString 16 => \"10\" toHexString 250 => \"FA\" Arguments. [i] Edit source. Noogle also knows. Aliases. lib.trivial.toHexString.",
    "word_count": 36,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toHexString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toHexString. Convert the given positive integer to a string of its hexadecimal representation. For example: toHexString 0 =&gt; \"0\" toHexString 16 =&gt; \"10\" toHexString 250 =&gt; \"FA\" Arguments. [i] Edit source. Noogle also knows. Aliases. lib.trivial.toHexString.",
    "raw_url": "/f/lib/toHexString.html",
    "excerpt": "lib.toHexString. Convert the given positive integer to a string of its hexadecimal representation. For example: toHexString 0 =&gt; \"0\" toHexString 16 =&gt; \"10\" toHexString 250 =&gt; \"FA\" Arguments. [i] Edit",
    "sub_results": []
  },
  {
    "url": "/f/lib/traceValFn.html",
    "content": "lib.traceValFn. Trace the supplied value after applying a function to it, and return the original value. Example. traceValFn (v: \"mystring ${v}\") \"foo\" trace: mystring foo => \"foo\" Type. traceValFn :: (a -> b) -> a -> a Arguments. [f] Function to apply. [x] Value to trace and return. Edit source. Noogle also knows. Aliases. lib.debug.traceValFn.",
    "word_count": 55,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.traceValFn"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 27
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 37
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.traceValFn. Trace the supplied value after applying a function to it, and return the original value. Example. traceValFn (v: \"mystring ${v}\") \"foo\" trace: mystring foo =&gt; \"foo\" Type. traceValFn :: (a -&gt; b) -&gt; a -&gt; a Arguments. [f] Function to apply. [x] Value to trace and return. Edit source. Noogle also knows. Aliases. lib.debug.traceValFn.",
    "raw_url": "/f/lib/traceValFn.html",
    "excerpt": "lib.traceValFn. Trace the supplied value after applying a function to it, and return the original value. Example. traceValFn (v: \"mystring ${v}\") \"foo\" trace: mystring foo =&gt; \"foo\" Type. traceValFn ::",
    "sub_results": []
  },
  {
    "url": "/f/lib/add.html",
    "content": "lib.add Primop. Takes 2 arguments. e1, e2. Return the sum of the numbers e1 and e2. Noogle also knows. Aliases. builtins.add. lib.trivial.add.",
    "word_count": 22,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.add Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.add Primop. Takes 2 arguments. e1, e2. Return the sum of the numbers e1 and e2. Noogle also knows. Aliases. builtins.add. lib.trivial.add.",
    "raw_url": "/f/lib/add.html",
    "excerpt": "lib.add Primop. Takes 2 arguments. e1, e2. Return the sum of the numbers e1 and e2. Noogle also knows. Aliases. builtins.add. lib.trivial.add.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lowPrioSet.html",
    "content": "lib.lowPrioSet. Apply lowPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.meta.lowPrioSet.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lowPrioSet"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lowPrioSet. Apply lowPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.meta.lowPrioSet.",
    "raw_url": "/f/lib/lowPrioSet.html",
    "excerpt": "lib.lowPrioSet. Apply lowPrio to an attrset with derivations. Arguments. [set] Edit source. Noogle also knows. Aliases. lib.meta.lowPrioSet.",
    "sub_results": []
  },
  {
    "url": "/f/lib/removeSuffix.html",
    "content": "lib.removeSuffix. Return a string without the specified suffix, if the suffix matches. Example. removeSuffix \"front\" \"homefront\" => \"home\" removeSuffix \"xxx\" \"homefront\" => \"homefront\" Type. string -> string -> string Arguments. [suffix] Suffix to remove if it matches. [str] Input string. Edit source. Noogle also knows. Aliases. lib.strings.removeSuffix.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.removeSuffix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.removeSuffix. Return a string without the specified suffix, if the suffix matches. Example. removeSuffix \"front\" \"homefront\" =&gt; \"home\" removeSuffix \"xxx\" \"homefront\" =&gt; \"homefront\" Type. string -&gt; string -&gt; string Arguments. [suffix] Suffix to remove if it matches. [str] Input string. Edit source. Noogle also knows. Aliases. lib.strings.removeSuffix.",
    "raw_url": "/f/lib/removeSuffix.html",
    "excerpt": "lib.removeSuffix. Return a string without the specified suffix, if the suffix matches. Example. removeSuffix \"front\" \"homefront\" =&gt; \"home\" removeSuffix \"xxx\" \"homefront\" =&gt; \"homefront\" Type. string -&gt; string -&gt; string Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mesonBool.html",
    "content": "lib.mesonBool. Create a -D={true,false} string that can be passed to typical Meson invocations. Example. mesonBool \"hardened\" true => \"-Dhardened=true\" mesonBool \"static\" false => \"-Dstatic=false\" Type. mesonBool :: string -> bool -> string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [condition] [flag] Edit source. Noogle also knows. Aliases. lib.strings.mesonBool.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mesonBool"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 24
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mesonBool. Create a -D={true,false} string that can be passed to typical Meson invocations. Example. mesonBool \"hardened\" true =&gt; \"-Dhardened=true\" mesonBool \"static\" false =&gt; \"-Dstatic=false\" Type. mesonBool :: string -&gt; bool -&gt; string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [condition] [flag] Edit source. Noogle also knows. Aliases. lib.strings.mesonBool.",
    "raw_url": "/f/lib/mesonBool.html",
    "excerpt": "lib.mesonBool. Create a -D={true,false} string that can be passed to typical Meson invocations. Example. mesonBool \"hardened\" true =&gt; \"-Dhardened=true\" mesonBool \"static\" false =&gt; \"-Dstatic=false\" Type. mesonBool :: string -&gt; bool",
    "sub_results": []
  },
  {
    "url": "/f/lib/traceSeqN.html",
    "content": "lib.traceSeqN. Like traceSeq, but only evaluate down to depth n. This is very useful because lots of traceSeq usages lead to an infinite recursion. Example. traceSeqN 2 { a.b.c = 3; } null trace: { a = { b = {…}; }; } => null Type. traceSeqN :: Int -> a -> b -> b Arguments. [depth] [x] [y] Edit source. Noogle also knows. Aliases. lib.debug.traceSeqN.",
    "word_count": 66,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.traceSeqN"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 45
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.traceSeqN. Like traceSeq, but only evaluate down to depth n. This is very useful because lots of traceSeq usages lead to an infinite recursion. Example. traceSeqN 2 { a.b.c = 3; } null trace: { a = { b = {…}; }; } =&gt; null Type. traceSeqN :: Int -&gt; a -&gt; b -&gt; b Arguments. [depth] [x] [y] Edit source. Noogle also knows. Aliases. lib.debug.traceSeqN.",
    "raw_url": "/f/lib/traceSeqN.html",
    "excerpt": "lib.traceSeqN. Like traceSeq, but only evaluate down to depth n. This is very useful because lots of traceSeq usages lead to an infinite recursion. Example. traceSeqN 2 { a.b.c =",
    "sub_results": []
  },
  {
    "url": "/f/lib/optionalString.html",
    "content": "lib.optionalString. Depending on the boolean `cond', return either the given string or the empty string. Useful to concatenate against a bigger string. Example. optionalString true \"some-string\" => \"some-string\" optionalString false \"some-string\" => \"\" Type. optionalString :: bool -> string -> string Arguments. [cond] Condition. [string] String to return if condition is true. Edit source. Noogle also knows. Aliases. lib.strings.optionalString.",
    "word_count": 59,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.optionalString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 22
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 33
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.optionalString. Depending on the boolean `cond', return either the given string or the empty string. Useful to concatenate against a bigger string. Example. optionalString true \"some-string\" =&gt; \"some-string\" optionalString false \"some-string\" =&gt; \"\" Type. optionalString :: bool -&gt; string -&gt; string Arguments. [cond] Condition. [string] String to return if condition is true. Edit source. Noogle also knows. Aliases. lib.strings.optionalString.",
    "raw_url": "/f/lib/optionalString.html",
    "excerpt": "lib.optionalString. Depending on the boolean `cond', return either the given string or the empty string. Useful to concatenate against a bigger string. Example. optionalString true \"some-string\" =&gt; \"some-string\" optionalString false",
    "sub_results": []
  },
  {
    "url": "/f/lib/isFunction.html",
    "content": "lib.isFunction. Check whether something is a function or something annotated with function args. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.trivial.isFunction.",
    "word_count": 22,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isFunction"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 13
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isFunction. Check whether something is a function or something annotated with function args. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.trivial.isFunction.",
    "raw_url": "/f/lib/isFunction.html",
    "excerpt": "lib.isFunction. Check whether something is a function or something annotated with function args. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.trivial.isFunction.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkAfter.html",
    "content": "lib.mkAfter. Noogle also knows. Aliases. lib.modules.mkAfter.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkAfter"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkAfter. Noogle also knows. Aliases. lib.modules.mkAfter.",
    "raw_url": "/f/lib/mkAfter.html",
    "excerpt": "lib.mkAfter. Noogle also knows. Aliases. lib.modules.mkAfter.",
    "sub_results": []
  },
  {
    "url": "/f/lib/min.html",
    "content": "lib.min. Return minimum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.min.",
    "word_count": 16,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.min"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 6
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.min. Return minimum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.min.",
    "raw_url": "/f/lib/min.html",
    "excerpt": "lib.min. Return minimum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.min.",
    "sub_results": []
  },
  {
    "url": "/f/lib/makeExtensibleWithCustomName.html",
    "content": "lib.makeExtensibleWithCustomName. Same as makeExtensible but the name of the extending attribute is customized. Arguments. [extenderName] [rattrs] Edit source. Noogle also knows. Aliases. lib.fixedPoints.makeExtensibleWithCustomName.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.makeExtensibleWithCustomName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 13
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.makeExtensibleWithCustomName. Same as makeExtensible but the name of the extending attribute is customized. Arguments. [extenderName] [rattrs] Edit source. Noogle also knows. Aliases. lib.fixedPoints.makeExtensibleWithCustomName.",
    "raw_url": "/f/lib/makeExtensibleWithCustomName.html",
    "excerpt": "lib.makeExtensibleWithCustomName. Same as makeExtensible but the name of the extending attribute is customized. Arguments. [extenderName] [rattrs] Edit source. Noogle also knows. Aliases. lib.fixedPoints.makeExtensibleWithCustomName.",
    "sub_results": []
  },
  {
    "url": "/f/lib/init.html",
    "content": "lib.init. Return all elements but the last. This function throws an error if the list is empty. Example. init [ 1 2 3 ] => [ 1 2 ] Type. init :: [a] -> [a] Arguments. [list] Edit source. Noogle also knows. Aliases. lib.lists.init.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.init"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 29
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.init. Return all elements but the last. This function throws an error if the list is empty. Example. init [ 1 2 3 ] =&gt; [ 1 2 ] Type. init :: [a] -&gt; [a] Arguments. [list] Edit source. Noogle also knows. Aliases. lib.lists.init.",
    "raw_url": "/f/lib/init.html",
    "excerpt": "lib.init. Return all elements but the last. This function throws an error if the list is empty. Example. init [ 1 2 3 ] =&gt; [ 1 2 ] Type.",
    "sub_results": []
  },
  {
    "url": "/f/lib/defaultFunctor.html",
    "content": "lib.defaultFunctor. Edit source. Noogle also knows. Aliases. lib.types.defaultFunctor.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.defaultFunctor"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.defaultFunctor. Edit source. Noogle also knows. Aliases. lib.types.defaultFunctor.",
    "raw_url": "/f/lib/defaultFunctor.html",
    "excerpt": "lib.defaultFunctor. Edit source. Noogle also knows. Aliases. lib.types.defaultFunctor.",
    "sub_results": []
  },
  {
    "url": "/f/lib/hasPrefix.html",
    "content": "lib.hasPrefix. Whether the first list is a prefix of the second list. Example. hasPrefix [ 1 2 ] [ 1 2 3 4 ] => true hasPrefix [ 0 1 ] [ 1 2 3 4 ] => false Type. hasPrefix :: [a] -> [a] -> bool Arguments. [list1] [list2] Edit source. Noogle also knows. Aliases. lib.lists.hasPrefix. lib.path.hasPrefix. lib.strings.hasPrefix.",
    "word_count": 59,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.hasPrefix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 39
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.hasPrefix. Whether the first list is a prefix of the second list. Example. hasPrefix [ 1 2 ] [ 1 2 3 4 ] =&gt; true hasPrefix [ 0 1 ] [ 1 2 3 4 ] =&gt; false Type. hasPrefix :: [a] -&gt; [a] -&gt; bool Arguments. [list1] [list2] Edit source. Noogle also knows. Aliases. lib.lists.hasPrefix. lib.path.hasPrefix. lib.strings.hasPrefix.",
    "raw_url": "/f/lib/hasPrefix.html",
    "excerpt": "lib.hasPrefix. Whether the first list is a prefix of the second list. Example. hasPrefix [ 1 2 ] [ 1 2 3 4 ] =&gt; true hasPrefix [ 0 1",
    "sub_results": []
  },
  {
    "url": "/f/lib/replaceChars.html",
    "content": "lib.replaceChars Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s. Example: builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\" evaluates to \"fabir\". Noogle also knows. Aliases. builtins.replaceStrings. lib.replaceStrings. lib.strings.replaceChars. lib.strings.replaceStrings.",
    "word_count": 66,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.replaceChars Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.replaceChars Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s. Example: builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\" evaluates to \"fabir\". Noogle also knows. Aliases. builtins.replaceStrings. lib.replaceStrings. lib.strings.replaceChars. lib.strings.replaceStrings.",
    "raw_url": "/f/lib/replaceChars.html",
    "excerpt": "lib.replaceChars Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy,",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkOverride.html",
    "content": "lib.mkOverride. Edit source. Noogle also knows. Aliases. lib.modules.mkOverride.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkOverride"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkOverride. Edit source. Noogle also knows. Aliases. lib.modules.mkOverride.",
    "raw_url": "/f/lib/mkOverride.html",
    "excerpt": "lib.mkOverride. Edit source. Noogle also knows. Aliases. lib.modules.mkOverride.",
    "sub_results": []
  },
  {
    "url": "/f/lib/concatMapAttrs.html",
    "content": "lib.concatMapAttrs. Map each attribute in the given set and merge them into a new attribute set. Example. concatMapAttrs (name: value: { ${name} = value; ${name + value} = value; }) { x = \"a\"; y = \"b\"; } => { x = \"a\"; xa = \"a\"; y = \"b\"; yb = \"b\"; } Type. concatMapAttrs :: (String -> a -> AttrSet) -> AttrSet -> AttrSet Arguments. [f] [v] Edit source. Noogle also knows. Aliases. lib.attrsets.concatMapAttrs.",
    "word_count": 75,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concatMapAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 53
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 65
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concatMapAttrs. Map each attribute in the given set and merge them into a new attribute set. Example. concatMapAttrs (name: value: { ${name} = value; ${name + value} = value; }) { x = \"a\"; y = \"b\"; } =&gt; { x = \"a\"; xa = \"a\"; y = \"b\"; yb = \"b\"; } Type. concatMapAttrs :: (String -&gt; a -&gt; AttrSet) -&gt; AttrSet -&gt; AttrSet Arguments. [f] [v] Edit source. Noogle also knows. Aliases. lib.attrsets.concatMapAttrs.",
    "raw_url": "/f/lib/concatMapAttrs.html",
    "excerpt": "lib.concatMapAttrs. Map each attribute in the given set and merge them into a new attribute set. Example. concatMapAttrs (name: value: { ${name} = value; ${name + value} = value; })",
    "sub_results": []
  },
  {
    "url": "/f/lib/getValues.html",
    "content": "lib.getValues. Extracts values of all \"value\" keys of the given list. Example. getValues [ { value = 1; } { value = 2; } ] // => [ 1 2 ] getValues [ ] // => [ ] Type. getValues :: [ { value :: a; } ] -> [a] Edit source. Noogle also knows. Aliases. lib.options.getValues.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getValues"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 38
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getValues. Extracts values of all \"value\" keys of the given list. Example. getValues [ { value = 1; } { value = 2; } ] // =&gt; [ 1 2 ] getValues [ ] // =&gt; [ ] Type. getValues :: [ { value :: a; } ] -&gt; [a] Edit source. Noogle also knows. Aliases. lib.options.getValues.",
    "raw_url": "/f/lib/getValues.html",
    "excerpt": "lib.getValues. Extracts values of all \"value\" keys of the given list. Example. getValues [ { value = 1; } { value = 2; } ] // =&gt; [ 1 2",
    "sub_results": []
  },
  {
    "url": "/f/lib/filter.html",
    "content": "lib.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. builtins.filter. lib.lists.filter. lib.strings.filter.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.filter Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. builtins.filter. lib.lists.filter. lib.strings.filter.",
    "raw_url": "/f/lib/filter.html",
    "excerpt": "lib.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. builtins.filter. lib.lists.filter. lib.strings.filter.",
    "sub_results": []
  },
  {
    "url": "/f/lib/traceValSeq.html",
    "content": "lib.traceValSeq. A combination of traceVal and traceSeq. Edit source. Noogle also knows. Aliases. lib.debug.traceValSeq.",
    "word_count": 14,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.traceValSeq"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.traceValSeq. A combination of traceVal and traceSeq. Edit source. Noogle also knows. Aliases. lib.debug.traceValSeq.",
    "raw_url": "/f/lib/traceValSeq.html",
    "excerpt": "lib.traceValSeq. A combination of traceVal and traceSeq. Edit source. Noogle also knows. Aliases. lib.debug.traceValSeq.",
    "sub_results": []
  },
  {
    "url": "/f/lib/runTests.html",
    "content": "lib.runTests. Evaluates a set of tests. A test is an attribute set {expr, expected}, denoting an expression and its expected result. The result is a list of failed tests, each represented as {name, expected, result}, expected. What was passed as expected. result. The actual result of the test Used for regression testing of the functions in lib; see tests.nix for more examples. Important: Only attributes that start with test are executed. If you want to run only a subset of the tests add the attribute tests = [\"testName\"]; Example. runTests { testAndOk = { expr = lib.and true false; expected = false; }; testAndFail = { expr = lib.and true false; expected = true; }; } -> [ { name = \"testAndFail\"; expected = true; result = false; } ] Type. runTests :: { tests = [ String ]; ${testName} :: { expr :: a; expected :: a; }; } -> [ { name :: String; expected :: a; result :: a; } ] Arguments. [tests] Tests to run. Edit source. Noogle also knows. Aliases. lib.debug.runTests.",
    "word_count": 176,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.runTests"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 88
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 130
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 164
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.runTests. Evaluates a set of tests. A test is an attribute set {expr, expected}, denoting an expression and its expected result. The result is a list of failed tests, each represented as {name, expected, result}, expected. What was passed as expected. result. The actual result of the test Used for regression testing of the functions in lib; see tests.nix for more examples. Important: Only attributes that start with test are executed. If you want to run only a subset of the tests add the attribute tests = [\"testName\"]; Example. runTests { testAndOk = { expr = lib.and true false; expected = false; }; testAndFail = { expr = lib.and true false; expected = true; }; } -&gt; [ { name = \"testAndFail\"; expected = true; result = false; } ] Type. runTests :: { tests = [ String ]; ${testName} :: { expr :: a; expected :: a; }; } -&gt; [ { name :: String; expected :: a; result :: a; } ] Arguments. [tests] Tests to run. Edit source. Noogle also knows. Aliases. lib.debug.runTests.",
    "raw_url": "/f/lib/runTests.html",
    "excerpt": "lib.runTests. Evaluates a set of tests. A test is an attribute set {expr, expected}, denoting an expression and its expected result. The result is a list of failed tests, each",
    "sub_results": []
  },
  {
    "url": "/f/lib/removePrefix.html",
    "content": "lib.removePrefix. Remove the first list as a prefix from the second list. Error if the first list isn't a prefix of the second list. Example. removePrefix [ 1 2 ] [ 1 2 3 4 ] => [ 3 4 ] removePrefix [ 0 1 ] [ 1 2 3 4 ] => <error> Type. removePrefix :: [a] -> [a] -> [a] Arguments. [list1] [list2] Edit source. Noogle also knows. Aliases. lib.lists.removePrefix. lib.path.removePrefix. lib.strings.removePrefix.",
    "word_count": 74,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.removePrefix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 54
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 62
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.removePrefix. Remove the first list as a prefix from the second list. Error if the first list isn't a prefix of the second list. Example. removePrefix [ 1 2 ] [ 1 2 3 4 ] =&gt; [ 3 4 ] removePrefix [ 0 1 ] [ 1 2 3 4 ] =&gt; &lt;error&gt; Type. removePrefix :: [a] -&gt; [a] -&gt; [a] Arguments. [list1] [list2] Edit source. Noogle also knows. Aliases. lib.lists.removePrefix. lib.path.removePrefix. lib.strings.removePrefix.",
    "raw_url": "/f/lib/removePrefix.html",
    "excerpt": "lib.removePrefix. Remove the first list as a prefix from the second list. Error if the first list isn't a prefix of the second list. Example. removePrefix [ 1 2 ]",
    "sub_results": []
  },
  {
    "url": "/f/lib/applyModuleArgsIfFunction.html",
    "content": "lib.applyModuleArgsIfFunction. Edit source. Noogle also knows. Aliases. lib.modules.applyModuleArgsIfFunction.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.applyModuleArgsIfFunction"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.applyModuleArgsIfFunction. Edit source. Noogle also knows. Aliases. lib.modules.applyModuleArgsIfFunction.",
    "raw_url": "/f/lib/applyModuleArgsIfFunction.html",
    "excerpt": "lib.applyModuleArgsIfFunction. Edit source. Noogle also knows. Aliases. lib.modules.applyModuleArgsIfFunction.",
    "sub_results": []
  },
  {
    "url": "/f/lib/recursiveUpdateUntil.html",
    "content": "lib.recursiveUpdateUntil. Does the same as the update operator '//' except that attributes are merged until the given predicate is verified. The predicate should accept 3 arguments which are the path to reach the attribute, a part of the first attribute set and a part of the second attribute set. When the predicate is satisfied, the value of the first attribute set is replaced by the value of the second attribute set. Example. recursiveUpdateUntil (path: l: r: path == [\"foo\"]) { # first attribute set foo.bar = 1; foo.baz = 2; bar = 3; } { #second attribute set foo.bar = 1; foo.quz = 2; baz = 4; } => { foo.bar = 1; # 'foo.*' from the second set foo.quz = 2; # bar = 3; # 'bar' from the first set baz = 4; # 'baz' from the second set } Type. recursiveUpdateUntil :: ( [ String ] -> AttrSet -> AttrSet -> Bool ) -> AttrSet -> AttrSet -> AttrSet Arguments. [pred] Predicate, taking the path to the current attribute as a list of strings for attribute names, and the two values at that path from the original arguments. [lhs] Left attribute set of the merge. [rhs] Right attribute set of the merge. Edit source. Noogle also knows. Aliases. lib.attrsets.recursiveUpdateUntil.",
    "word_count": 212,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.recursiveUpdateUntil"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 71
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 142
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 162
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.recursiveUpdateUntil. Does the same as the update operator '//' except that attributes are merged until the given predicate is verified. The predicate should accept 3 arguments which are the path to reach the attribute, a part of the first attribute set and a part of the second attribute set. When the predicate is satisfied, the value of the first attribute set is replaced by the value of the second attribute set. Example. recursiveUpdateUntil (path: l: r: path == [\"foo\"]) { # first attribute set foo.bar = 1; foo.baz = 2; bar = 3; } { #second attribute set foo.bar = 1; foo.quz = 2; baz = 4; } =&gt; { foo.bar = 1; # 'foo.*' from the second set foo.quz = 2; # bar = 3; # 'bar' from the first set baz = 4; # 'baz' from the second set } Type. recursiveUpdateUntil :: ( [ String ] -&gt; AttrSet -&gt; AttrSet -&gt; Bool ) -&gt; AttrSet -&gt; AttrSet -&gt; AttrSet Arguments. [pred] Predicate, taking the path to the current attribute as a list of strings for attribute names, and the two values at that path from the original arguments. [lhs] Left attribute set of the merge. [rhs] Right attribute set of the merge. Edit source. Noogle also knows. Aliases. lib.attrsets.recursiveUpdateUntil.",
    "raw_url": "/f/lib/recursiveUpdateUntil.html",
    "excerpt": "lib.recursiveUpdateUntil. Does the same as the update operator '//' except that attributes are merged until the given predicate is verified. The predicate should accept 3 arguments which are the path",
    "sub_results": []
  },
  {
    "url": "/f/lib/cmakeBool.html",
    "content": "lib.cmakeBool. Create a -D={TRUE,FALSE} string that can be passed to typical CMake invocations. Example. cmakeBool \"ENABLE_STATIC_LIBS\" false => \"-DENABLESTATIC_LIBS:BOOL=FALSE\" Type. cmakeBool :: string -> bool -> string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [condition] [flag] Edit source. Noogle also knows. Aliases. lib.strings.cmakeBool.",
    "word_count": 55,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.cmakeBool"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 45
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.cmakeBool. Create a -D={TRUE,FALSE} string that can be passed to typical CMake invocations. Example. cmakeBool \"ENABLE_STATIC_LIBS\" false =&gt; \"-DENABLESTATIC_LIBS:BOOL=FALSE\" Type. cmakeBool :: string -&gt; bool -&gt; string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [condition] [flag] Edit source. Noogle also knows. Aliases. lib.strings.cmakeBool.",
    "raw_url": "/f/lib/cmakeBool.html",
    "excerpt": "lib.cmakeBool. Create a -D={TRUE,FALSE} string that can be passed to typical CMake invocations. Example. cmakeBool \"ENABLE_STATIC_LIBS\" false =&gt; \"-DENABLESTATIC_LIBS:BOOL=FALSE\" Type. cmakeBool :: string -&gt; bool -&gt; string @param condition The",
    "sub_results": []
  },
  {
    "url": "/f/lib/concatMap.html",
    "content": "lib.concatMap Primop. Takes 2 arguments. f, list. Map and concatenate the result. Example. concatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"] => [ \"a\" \"z\" \"b\" \"z\" ] Type. concatMap :: (a -> [b]) -> [a] -> [b] Edit source. Noogle also knows. Aliases. builtins.concatMap. lib.lists.concatMap.",
    "word_count": 45,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concatMap Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concatMap Primop. Takes 2 arguments. f, list. Map and concatenate the result. Example. concatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"] =&gt; [ \"a\" \"z\" \"b\" \"z\" ] Type. concatMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b] Edit source. Noogle also knows. Aliases. builtins.concatMap. lib.lists.concatMap.",
    "raw_url": "/f/lib/concatMap.html",
    "excerpt": "lib.concatMap Primop. Takes 2 arguments. f, list. Map and concatenate the result. Example. concatMap (x: [x] ++ [\"z\"]) [\"a\" \"b\"] =&gt; [ \"a\" \"z\" \"b\" \"z\" ] Type. concatMap ::",
    "sub_results": []
  },
  {
    "url": "/f/lib/textClosureMap.html",
    "content": "lib.textClosureMap. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.textClosureMap.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.textClosureMap"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.textClosureMap. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.textClosureMap.",
    "raw_url": "/f/lib/textClosureMap.html",
    "excerpt": "lib.textClosureMap. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.textClosureMap.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mapAttrsRecursiveCond.html",
    "content": "lib.mapAttrsRecursiveCond. Like mapAttrsRecursive, but it takes an additional predicate function that tells it whether to recurse into an attribute set. If it returns false, mapAttrsRecursiveCond does not recurse, but does apply the map function. If it returns true, it does recurse, and does not apply the map function. Example. # To prevent recursing into derivations (which are attribute # sets with the attribute \"type\" equal to \"derivation\"): mapAttrsRecursiveCond (as: !(as ? \"type\" && as.type == \"derivation\")) (x: ... do something ...) attrs Type. mapAttrsRecursiveCond :: (AttrSet -> Bool) -> ([String] -> a -> b) -> AttrSet -> AttrSet Arguments. [cond] A function, given the attribute set the recursion is currently at, determine if to recurse deeper into that attribute set. [f] A function, given a list of attribute names and a value, returns a new value. [set] Attribute set to recursively map over. Edit source. Noogle also knows. Aliases. lib.attrsets.mapAttrsRecursiveCond.",
    "word_count": 150,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mapAttrsRecursiveCond"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 48
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 82
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 98
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mapAttrsRecursiveCond. Like mapAttrsRecursive, but it takes an additional predicate function that tells it whether to recurse into an attribute set. If it returns false, mapAttrsRecursiveCond does not recurse, but does apply the map function. If it returns true, it does recurse, and does not apply the map function. Example. # To prevent recursing into derivations (which are attribute # sets with the attribute \"type\" equal to \"derivation\"): mapAttrsRecursiveCond (as: !(as ? \"type\" && as.type == \"derivation\")) (x: ... do something ...) attrs Type. mapAttrsRecursiveCond :: (AttrSet -&gt; Bool) -&gt; ([String] -&gt; a -&gt; b) -&gt; AttrSet -&gt; AttrSet Arguments. [cond] A function, given the attribute set the recursion is currently at, determine if to recurse deeper into that attribute set. [f] A function, given a list of attribute names and a value, returns a new value. [set] Attribute set to recursively map over. Edit source. Noogle also knows. Aliases. lib.attrsets.mapAttrsRecursiveCond.",
    "raw_url": "/f/lib/mapAttrsRecursiveCond.html",
    "excerpt": "lib.mapAttrsRecursiveCond. Like mapAttrsRecursive, but it takes an additional predicate function that tells it whether to recurse into an attribute set. If it returns false, mapAttrsRecursiveCond does not recurse, but does",
    "sub_results": []
  },
  {
    "url": "/f/lib/stringLength.html",
    "content": "lib.stringLength Primop. Takes 1 arguments. e. Return the length of the string e. If e is not a string, evaluation is aborted. Noogle also knows. Aliases. builtins.stringLength. lib.strings.stringLength.",
    "word_count": 28,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.stringLength Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.stringLength Primop. Takes 1 arguments. e. Return the length of the string e. If e is not a string, evaluation is aborted. Noogle also knows. Aliases. builtins.stringLength. lib.strings.stringLength.",
    "raw_url": "/f/lib/stringLength.html",
    "excerpt": "lib.stringLength Primop. Takes 1 arguments. e. Return the length of the string e. If e is not a string, evaluation is aborted. Noogle also knows. Aliases. builtins.stringLength. lib.strings.stringLength.",
    "sub_results": []
  },
  {
    "url": "/f/lib/getAttrFromPath.html",
    "content": "lib.getAttrFromPath. Like attrByPath, but without a default value. If it doesn't find the path it will throw an error. Example. x = { a = { b = 3; }; } getAttrFromPath [\"a\" \"b\"] x => 3 getAttrFromPath [\"z\" \"z\"] x => error: cannot find attribute `z.z' Type. getAttrFromPath :: [String] -> AttrSet -> Any Arguments. [attrPath] A list of strings representing the attribute path to get from set. [set] The nested attribute set to find the value in. Edit source. Noogle also knows. Aliases. lib.attrsets.getAttrFromPath.",
    "word_count": 86,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getAttrFromPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getAttrFromPath. Like attrByPath, but without a default value. If it doesn't find the path it will throw an error. Example. x = { a = { b = 3; }; } getAttrFromPath [\"a\" \"b\"] x =&gt; 3 getAttrFromPath [\"z\" \"z\"] x =&gt; error: cannot find attribute `z.z' Type. getAttrFromPath :: [String] -&gt; AttrSet -&gt; Any Arguments. [attrPath] A list of strings representing the attribute path to get from set. [set] The nested attribute set to find the value in. Edit source. Noogle also knows. Aliases. lib.attrsets.getAttrFromPath.",
    "raw_url": "/f/lib/getAttrFromPath.html",
    "excerpt": "lib.getAttrFromPath. Like attrByPath, but without a default value. If it doesn't find the path it will throw an error. Example. x = { a = { b = 3; };",
    "sub_results": []
  },
  {
    "url": "/f/lib/lazyGenericClosure.html",
    "content": "lib.lazyGenericClosure. Edit source. Noogle also knows. Aliases. lib.misc.lazyGenericClosure.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lazyGenericClosure"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lazyGenericClosure. Edit source. Noogle also knows. Aliases. lib.misc.lazyGenericClosure.",
    "raw_url": "/f/lib/lazyGenericClosure.html",
    "excerpt": "lib.lazyGenericClosure. Edit source. Noogle also knows. Aliases. lib.misc.lazyGenericClosure.",
    "sub_results": []
  },
  {
    "url": "/f/lib/addContextFrom.html",
    "content": "lib.addContextFrom. Appends string context from another string. This is an implementation detail of Nix and should be used carefully. Strings in Nix carry an invisible context which is a list of strings representing store paths. If the string is later used in a derivation attribute, the derivation will properly populate the inputDrvs and inputSrcs. Example. pkgs = import <nixpkgs> { }; addContextFrom pkgs.coreutils \"bar\" => \"bar\" Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.strings.addContextFrom.",
    "word_count": 76,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.addContextFrom"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 54
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 66
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.addContextFrom. Appends string context from another string. This is an implementation detail of Nix and should be used carefully. Strings in Nix carry an invisible context which is a list of strings representing store paths. If the string is later used in a derivation attribute, the derivation will properly populate the inputDrvs and inputSrcs. Example. pkgs = import &lt;nixpkgs&gt; { }; addContextFrom pkgs.coreutils \"bar\" =&gt; \"bar\" Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.strings.addContextFrom.",
    "raw_url": "/f/lib/addContextFrom.html",
    "excerpt": "lib.addContextFrom. Appends string context from another string. This is an implementation detail of Nix and should be used carefully. Strings in Nix carry an invisible context which is a list",
    "sub_results": []
  },
  {
    "url": "/f/lib/mutuallyExclusive.html",
    "content": "lib.mutuallyExclusive. Test if two lists have no common element. It should be slightly more efficient than (intersectLists a b == []). Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.lists.mutuallyExclusive.",
    "word_count": 31,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mutuallyExclusive"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 21
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mutuallyExclusive. Test if two lists have no common element. It should be slightly more efficient than (intersectLists a b == []). Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.lists.mutuallyExclusive.",
    "raw_url": "/f/lib/mutuallyExclusive.html",
    "excerpt": "lib.mutuallyExclusive. Test if two lists have no common element. It should be slightly more efficient than (intersectLists a b == []). Arguments. [a] [b] Edit source. Noogle also knows. Aliases.",
    "sub_results": []
  },
  {
    "url": "/f/lib/foldl.html",
    "content": "lib.foldl. “left fold”, like foldr, but from the left: foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n). Example. lconcat = foldl (a: b: a + b) \"z\" lconcat [ \"a\" \"b\" \"c\" ] => \"zabc\" # different types lstrange = foldl (str: int: str + toString (int + 1)) \"a\" lstrange [ 1 2 3 4 ] => \"a2345\" Type. foldl :: (b -> a -> b) -> b -> [a] -> b Arguments. [op] [nul] [list] Edit source. Noogle also knows. Aliases. lib.lists.foldl.",
    "word_count": 93,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.foldl"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 68
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 82
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.foldl. “left fold”, like foldr, but from the left: foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n). Example. lconcat = foldl (a: b: a + b) \"z\" lconcat [ \"a\" \"b\" \"c\" ] =&gt; \"zabc\" # different types lstrange = foldl (str: int: str + toString (int + 1)) \"a\" lstrange [ 1 2 3 4 ] =&gt; \"a2345\" Type. foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b Arguments. [op] [nul] [list] Edit source. Noogle also knows. Aliases. lib.lists.foldl.",
    "raw_url": "/f/lib/foldl.html",
    "excerpt": "lib.foldl. “left fold”, like foldr, but from the left: foldl op nul [x_1 x_2 ... x_n] == op (... (op (op nul x_1) x_2) ... x_n). Example. lconcat = foldl",
    "sub_results": []
  },
  {
    "url": "/f/lib/info.html",
    "content": "lib.info. Edit source. Noogle also knows. Aliases. lib.trivial.info.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.info"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.info. Edit source. Noogle also knows. Aliases. lib.trivial.info.",
    "raw_url": "/f/lib/info.html",
    "excerpt": "lib.info. Edit source. Noogle also knows. Aliases. lib.trivial.info.",
    "sub_results": []
  },
  {
    "url": "/f/lib/hasAttrByPath.html",
    "content": "lib.hasAttrByPath. Return if an attribute from nested attribute set exists. Example. x = { a = { b = 3; }; } hasAttrByPath [\"a\" \"b\"] x => true hasAttrByPath [\"z\" \"z\"] x => false Type. hasAttrByPath :: [String] -> AttrSet -> Bool Arguments. [attrPath] A list of strings representing the attribute path to check from set. [e] The nested attribute set to check. Edit source. Noogle also knows. Aliases. lib.attrsets.hasAttrByPath.",
    "word_count": 70,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.hasAttrByPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.hasAttrByPath. Return if an attribute from nested attribute set exists. Example. x = { a = { b = 3; }; } hasAttrByPath [\"a\" \"b\"] x =&gt; true hasAttrByPath [\"z\" \"z\"] x =&gt; false Type. hasAttrByPath :: [String] -&gt; AttrSet -&gt; Bool Arguments. [attrPath] A list of strings representing the attribute path to check from set. [e] The nested attribute set to check. Edit source. Noogle also knows. Aliases. lib.attrsets.hasAttrByPath.",
    "raw_url": "/f/lib/hasAttrByPath.html",
    "excerpt": "lib.hasAttrByPath. Return if an attribute from nested attribute set exists. Example. x = { a = { b = 3; }; } hasAttrByPath [\"a\" \"b\"] x =&gt; true hasAttrByPath [\"z\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/toposort.html",
    "content": "lib.toposort. Sort a list based on a partial ordering using DFS. This implementation is O(N^2), if your ordering is linear, use sort instead. before a b == true means that b should be after a in the result. Example. toposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ] == { result = [ \"/\" \"/home\" \"/home/user\" \"other\" ]; } toposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ] == { cycle = [ \"/home/user\" \"/\" \"/\" ]; # path leading to a cycle loops = [ \"/\" ]; } # loops back to these elements toposort hasPrefix [ \"other\" \"/home/user\" \"/home\" \"/\" ] == { result = [ \"other\" \"/\" \"/home\" \"/home/user\" ]; } toposort (a: b: a < b) [ 3 2 1 ] == { result = [ 1 2 3 ]; } Arguments. [before] [list] Edit source. Noogle also knows. Aliases. lib.lists.toposort.",
    "word_count": 144,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toposort"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 38
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 134
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toposort. Sort a list based on a partial ordering using DFS. This implementation is O(N^2), if your ordering is linear, use sort instead. before a b == true means that b should be after a in the result. Example. toposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" ] == { result = [ \"/\" \"/home\" \"/home/user\" \"other\" ]; } toposort hasPrefix [ \"/home/user\" \"other\" \"/\" \"/home\" \"/\" ] == { cycle = [ \"/home/user\" \"/\" \"/\" ]; # path leading to a cycle loops = [ \"/\" ]; } # loops back to these elements toposort hasPrefix [ \"other\" \"/home/user\" \"/home\" \"/\" ] == { result = [ \"other\" \"/\" \"/home\" \"/home/user\" ]; } toposort (a: b: a &lt; b) [ 3 2 1 ] == { result = [ 1 2 3 ]; } Arguments. [before] [list] Edit source. Noogle also knows. Aliases. lib.lists.toposort.",
    "raw_url": "/f/lib/toposort.html",
    "excerpt": "lib.toposort. Sort a list based on a partial ordering using DFS. This implementation is O(N^2), if your ordering is linear, use sort instead. before a b == true means that",
    "sub_results": []
  },
  {
    "url": "/f/lib/unique.html",
    "content": "lib.unique. Remove duplicate elements from the list. O(n^2) complexity. Example. unique [ 3 2 3 4 ] => [ 3 2 4 ] Type. unique :: [a] -> [a] Edit source. Noogle also knows. Aliases. lib.types.unique. lib.lists.unique.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.unique"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.unique. Remove duplicate elements from the list. O(n^2) complexity. Example. unique [ 3 2 3 4 ] =&gt; [ 3 2 4 ] Type. unique :: [a] -&gt; [a] Edit source. Noogle also knows. Aliases. lib.types.unique. lib.lists.unique.",
    "raw_url": "/f/lib/unique.html",
    "excerpt": "lib.unique. Remove duplicate elements from the list. O(n^2) complexity. Example. unique [ 3 2 3 4 ] =&gt; [ 3 2 4 ] Type. unique :: [a] -&gt; [a] Edit",
    "sub_results": []
  },
  {
    "url": "/f/lib/showFiles.html",
    "content": "lib.showFiles. Edit source. Noogle also knows. Aliases. lib.options.showFiles.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.showFiles"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.showFiles. Edit source. Noogle also knows. Aliases. lib.options.showFiles.",
    "raw_url": "/f/lib/showFiles.html",
    "excerpt": "lib.showFiles. Edit source. Noogle also knows. Aliases. lib.options.showFiles.",
    "sub_results": []
  },
  {
    "url": "/f/lib/isType.html",
    "content": "lib.isType. Edit source. Noogle also knows. Aliases. lib.types.isType.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isType. Edit source. Noogle also knows. Aliases. lib.types.isType.",
    "raw_url": "/f/lib/isType.html",
    "excerpt": "lib.isType. Edit source. Noogle also knows. Aliases. lib.types.isType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/getDev.html",
    "content": "lib.getDev. Get a package's dev output. If the output does not exist, fallback to .out and then to the default. Example. getDev pkgs.openssl => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getDev :: Derivation -> String Edit source. Noogle also knows. Aliases. lib.attrsets.getDev.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getDev"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getDev. Get a package's dev output. If the output does not exist, fallback to .out and then to the default. Example. getDev pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getDev :: Derivation -&gt; String Edit source. Noogle also knows. Aliases. lib.attrsets.getDev.",
    "raw_url": "/f/lib/getDev.html",
    "excerpt": "lib.getDev. Get a package's dev output. If the output does not exist, fallback to .out and then to the default. Example. getDev pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getDev :: Derivation -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/setAttrByPath.html",
    "content": "lib.setAttrByPath. Create a new attribute set with value set at the nested attribute location specified in attrPath. Example. setAttrByPath [\"a\" \"b\"] 3 => { a = { b = 3; }; } Type. setAttrByPath :: [String] -> Any -> AttrSet Arguments. [attrPath] A list of strings representing the attribute path to set. [value] The value to set at the location described by attrPath. Edit source. Noogle also knows. Aliases. lib.attrsets.setAttrByPath.",
    "word_count": 70,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.setAttrByPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.setAttrByPath. Create a new attribute set with value set at the nested attribute location specified in attrPath. Example. setAttrByPath [\"a\" \"b\"] 3 =&gt; { a = { b = 3; }; } Type. setAttrByPath :: [String] -&gt; Any -&gt; AttrSet Arguments. [attrPath] A list of strings representing the attribute path to set. [value] The value to set at the location described by attrPath. Edit source. Noogle also knows. Aliases. lib.attrsets.setAttrByPath.",
    "raw_url": "/f/lib/setAttrByPath.html",
    "excerpt": "lib.setAttrByPath. Create a new attribute set with value set at the nested attribute location specified in attrPath. Example. setAttrByPath [\"a\" \"b\"] 3 =&gt; { a = { b = 3;",
    "sub_results": []
  },
  {
    "url": "/f/lib/scrubOptionValue.html",
    "content": "lib.scrubOptionValue. This function recursively removes all derivation attributes from x except for the name attribute. This is to make the generation of options.xml much more efficient: the XML representation of derivations is very large (on the order of megabytes) and is not actually used by the manual generator. This function was made obsolete by renderOptionValue and is kept for compatibility with out-of-tree code. Arguments. [x] Edit source. Noogle also knows. Aliases. lib.options.scrubOptionValue.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.scrubOptionValue"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 63
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.scrubOptionValue. This function recursively removes all derivation attributes from x except for the name attribute. This is to make the generation of options.xml much more efficient: the XML representation of derivations is very large (on the order of megabytes) and is not actually used by the manual generator. This function was made obsolete by renderOptionValue and is kept for compatibility with out-of-tree code. Arguments. [x] Edit source. Noogle also knows. Aliases. lib.options.scrubOptionValue.",
    "raw_url": "/f/lib/scrubOptionValue.html",
    "excerpt": "lib.scrubOptionValue. This function recursively removes all derivation attributes from x except for the name attribute. This is to make the generation of options.xml much more efficient: the XML representation of",
    "sub_results": []
  },
  {
    "url": "/f/lib/readFile.html",
    "content": "lib.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. builtins.readFile. lib.strings.readFile. lib.trivial.readFile.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.readFile Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. builtins.readFile. lib.strings.readFile. lib.trivial.readFile.",
    "raw_url": "/f/lib/readFile.html",
    "excerpt": "lib.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. builtins.readFile. lib.strings.readFile. lib.trivial.readFile.",
    "sub_results": []
  },
  {
    "url": "/f/lib/getFiles.html",
    "content": "lib.getFiles. Extracts values of all \"file\" keys of the given list. Example. getFiles [ { file = \"file1\"; } { file = \"file2\"; } ] // => [ \"file1\" \"file2\" ] getFiles [ ] // => [ ] Type. getFiles :: [ { file :: a; } ] -> [a] Edit source. Noogle also knows. Aliases. lib.options.getFiles.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getFiles"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 38
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getFiles. Extracts values of all \"file\" keys of the given list. Example. getFiles [ { file = \"file1\"; } { file = \"file2\"; } ] // =&gt; [ \"file1\" \"file2\" ] getFiles [ ] // =&gt; [ ] Type. getFiles :: [ { file :: a; } ] -&gt; [a] Edit source. Noogle also knows. Aliases. lib.options.getFiles.",
    "raw_url": "/f/lib/getFiles.html",
    "excerpt": "lib.getFiles. Extracts values of all \"file\" keys of the given list. Example. getFiles [ { file = \"file1\"; } { file = \"file2\"; } ] // =&gt; [ \"file1\" \"file2\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/singleton.html",
    "content": "lib.singleton. Create a list consisting of a single element. singleton x is sometimes more convenient with respect to indentation than [x] when x spans multiple lines. Example. singleton \"foo\" => [ \"foo\" ] Type. singleton :: a -> [a] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.lists.singleton.",
    "word_count": 48,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.singleton"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 33
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.singleton. Create a list consisting of a single element. singleton x is sometimes more convenient with respect to indentation than [x] when x spans multiple lines. Example. singleton \"foo\" =&gt; [ \"foo\" ] Type. singleton :: a -&gt; [a] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.lists.singleton.",
    "raw_url": "/f/lib/singleton.html",
    "excerpt": "lib.singleton. Create a list consisting of a single element. singleton x is sometimes more convenient with respect to indentation than [x] when x spans multiple lines. Example. singleton \"foo\" =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/concatStringsSep.html",
    "content": "lib.concatStringsSep Primop. Takes 2 arguments. separator, list. Concatenate a list of strings with a separator between each element. Example. concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] => \"usr/local/bin\" Type. concatStringsSep :: string -> [string] -> string Edit source. Noogle also knows. Aliases. builtins.concatStringsSep. lib.strings.concatStringsSep.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concatStringsSep Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concatStringsSep Primop. Takes 2 arguments. separator, list. Concatenate a list of strings with a separator between each element. Example. concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] =&gt; \"usr/local/bin\" Type. concatStringsSep :: string -&gt; [string] -&gt; string Edit source. Noogle also knows. Aliases. builtins.concatStringsSep. lib.strings.concatStringsSep.",
    "raw_url": "/f/lib/concatStringsSep.html",
    "excerpt": "lib.concatStringsSep Primop. Takes 2 arguments. separator, list. Concatenate a list of strings with a separator between each element. Example. concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] =&gt; \"usr/local/bin\" Type. concatStringsSep :: string",
    "sub_results": []
  },
  {
    "url": "/f/lib/uniqList.html",
    "content": "lib.uniqList. Edit source. Noogle also knows. Aliases. lib.misc.uniqList.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.uniqList"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.uniqList. Edit source. Noogle also knows. Aliases. lib.misc.uniqList.",
    "raw_url": "/f/lib/uniqList.html",
    "excerpt": "lib.uniqList. Edit source. Noogle also knows. Aliases. lib.misc.uniqList.",
    "sub_results": []
  },
  {
    "url": "/f/lib/setAttrMerge.html",
    "content": "lib.setAttrMerge. Edit source. Noogle also knows. Aliases. lib.misc.setAttrMerge.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.setAttrMerge"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.setAttrMerge. Edit source. Noogle also knows. Aliases. lib.misc.setAttrMerge.",
    "raw_url": "/f/lib/setAttrMerge.html",
    "excerpt": "lib.setAttrMerge. Edit source. Noogle also knows. Aliases. lib.misc.setAttrMerge.",
    "sub_results": []
  },
  {
    "url": "/f/lib/genAttrs.html",
    "content": "lib.genAttrs. Generate an attribute set by mapping a function over a list of attribute names. Example. genAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name) => { foo = \"x_foo\"; bar = \"x_bar\"; } Type. genAttrs :: [ String ] -> (String -> Any) -> AttrSet Arguments. [names] Names of values in the resulting attribute set. [f] A function, given the name of the attribute, returns the attribute's value. Edit source. Noogle also knows. Aliases. lib.attrsets.genAttrs.",
    "word_count": 76,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.genAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 46
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.genAttrs. Generate an attribute set by mapping a function over a list of attribute names. Example. genAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name) =&gt; { foo = \"x_foo\"; bar = \"x_bar\"; } Type. genAttrs :: [ String ] -&gt; (String -&gt; Any) -&gt; AttrSet Arguments. [names] Names of values in the resulting attribute set. [f] A function, given the name of the attribute, returns the attribute's value. Edit source. Noogle also knows. Aliases. lib.attrsets.genAttrs.",
    "raw_url": "/f/lib/genAttrs.html",
    "excerpt": "lib.genAttrs. Generate an attribute set by mapping a function over a list of attribute names. Example. genAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name) =&gt; { foo = \"x_foo\";",
    "sub_results": []
  },
  {
    "url": "/f/lib/stringAfter.html",
    "content": "lib.stringAfter. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.stringAfter.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.stringAfter"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.stringAfter. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.stringAfter.",
    "raw_url": "/f/lib/stringAfter.html",
    "excerpt": "lib.stringAfter. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.stringAfter.",
    "sub_results": []
  },
  {
    "url": "/f/lib/sublist.html",
    "content": "lib.sublist. Return a list consisting of at most count elements of list, starting at index start. Example. sublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ] => [ \"b\" \"c\" \"d\" ] sublist 1 3 [ ] => [ ] Type. sublist :: int -> int -> [a] -> [a] Arguments. [start] Index at which to start the sublist. [count] Number of elements to take. [list] Input list. Edit source. Noogle also knows. Aliases. lib.lists.sublist.",
    "word_count": 76,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sublist"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 41
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 51
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sublist. Return a list consisting of at most count elements of list, starting at index start. Example. sublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ] =&gt; [ \"b\" \"c\" \"d\" ] sublist 1 3 [ ] =&gt; [ ] Type. sublist :: int -&gt; int -&gt; [a] -&gt; [a] Arguments. [start] Index at which to start the sublist. [count] Number of elements to take. [list] Input list. Edit source. Noogle also knows. Aliases. lib.lists.sublist.",
    "raw_url": "/f/lib/sublist.html",
    "excerpt": "lib.sublist. Return a list consisting of at most count elements of list, starting at index start. Example. sublist 1 3 [ \"a\" \"b\" \"c\" \"d\" \"e\" ] =&gt; [ \"b\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/sourceFilesBySuffices.html",
    "content": "lib.sourceFilesBySuffices. Get all files ending with the specified suffices from the given source directory or its descendants, omitting files that do not match any suffix. The result of the example below will include files like ./dir/module.c and ./dir/subdir/doc.xml if present. Example. sourceFilesBySuffices ./. [ \".xml\" \".c\" ] Type. sourceLike -> [String] -> Source Arguments. [src] Path or source containing the files to be returned. [exts] A list of file suffix strings. Edit source. Noogle also knows. Aliases. lib.sources.sourceFilesBySuffices.",
    "word_count": 78,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sourceFilesBySuffices"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 40
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 53
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sourceFilesBySuffices. Get all files ending with the specified suffices from the given source directory or its descendants, omitting files that do not match any suffix. The result of the example below will include files like ./dir/module.c and ./dir/subdir/doc.xml if present. Example. sourceFilesBySuffices ./. [ \".xml\" \".c\" ] Type. sourceLike -&gt; [String] -&gt; Source Arguments. [src] Path or source containing the files to be returned. [exts] A list of file suffix strings. Edit source. Noogle also knows. Aliases. lib.sources.sourceFilesBySuffices.",
    "raw_url": "/f/lib/sourceFilesBySuffices.html",
    "excerpt": "lib.sourceFilesBySuffices. Get all files ending with the specified suffices from the given source directory or its descendants, omitting files that do not match any suffix. The result of the example",
    "sub_results": []
  },
  {
    "url": "/f/lib/zip.html",
    "content": "lib.zip Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names. Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names. Example. zipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet Edit source. Noogle also knows. Aliases. builtins.zipAttrsWith. lib.zipAttrsWith. lib.attrsets.zip. lib.attrsets.zipAttrsWith.",
    "word_count": 118,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.zip Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 68
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 92
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.zip Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names. Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names. Example. zipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrsWith :: (String -&gt; [ Any ] -&gt; Any) -&gt; [ AttrSet ] -&gt; AttrSet Edit source. Noogle also knows. Aliases. builtins.zipAttrsWith. lib.zipAttrsWith. lib.attrsets.zip. lib.attrsets.zipAttrsWith.",
    "raw_url": "/f/lib/zip.html",
    "excerpt": "lib.zip Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names.",
    "sub_results": []
  },
  {
    "url": "/f/lib/assertMsg.html",
    "content": "lib.assertMsg. Throw if pred is false, else return pred. Intended to be used to augment asserts with helpful error messages. Example. assertMsg false \"nope\" stderr> error: nope assert assertMsg (\"foo\" == \"bar\") \"foo is not bar, silly\"; \"\" stderr> error: foo is not bar, silly Type. assertMsg :: Bool -> String -> Bool Arguments. [pred] Predicate that needs to succeed, otherwise msg is thrown. [msg] Message to throw in case pred fails. Edit source. Noogle also knows. Aliases. lib.asserts.assertMsg.",
    "word_count": 79,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.assertMsg"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 45
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 53
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.assertMsg. Throw if pred is false, else return pred. Intended to be used to augment asserts with helpful error messages. Example. assertMsg false \"nope\" stderr&gt; error: nope assert assertMsg (\"foo\" == \"bar\") \"foo is not bar, silly\"; \"\" stderr&gt; error: foo is not bar, silly Type. assertMsg :: Bool -&gt; String -&gt; Bool Arguments. [pred] Predicate that needs to succeed, otherwise msg is thrown. [msg] Message to throw in case pred fails. Edit source. Noogle also knows. Aliases. lib.asserts.assertMsg.",
    "raw_url": "/f/lib/assertMsg.html",
    "excerpt": "lib.assertMsg. Throw if pred is false, else return pred. Intended to be used to augment asserts with helpful error messages. Example. assertMsg false \"nope\" stderr&gt; error: nope assert assertMsg (\"foo\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/setAttr.html",
    "content": "lib.setAttr. Edit source. Noogle also knows. Aliases. lib.misc.setAttr.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.setAttr"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.setAttr. Edit source. Noogle also knows. Aliases. lib.misc.setAttr.",
    "raw_url": "/f/lib/setAttr.html",
    "excerpt": "lib.setAttr. Edit source. Noogle also knows. Aliases. lib.misc.setAttr.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeModules'.html",
    "content": "lib.mergeModules' (Prime). Edit source. Noogle also knows. Aliases. lib.modules.mergeModules'",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeModules' (Prime)"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeModules' (Prime). Edit source. Noogle also knows. Aliases. lib.modules.mergeModules'",
    "raw_url": "/f/lib/mergeModules'.html",
    "excerpt": "lib.mergeModules' (Prime). Edit source. Noogle also knows. Aliases. lib.modules.mergeModules'",
    "sub_results": []
  },
  {
    "url": "/f/lib/readPathsFromFile.html",
    "content": "lib.readPathsFromFile. Read a list of paths from file, relative to the rootPath. Lines beginning with # are treated as comments and ignored. Whitespace is significant. NOTE: This function is not performant and should be avoided. Example. readPathsFromFile /prefix ./pkgs/development/libraries/qt-5/5.4/qtbase/series => [ \"/prefix/dlopen-resolv.patch\" \"/prefix/tzdir.patch\" \"/prefix/dlopen-libXcursor.patch\" \"/prefix/dlopen-openssl.patch\" \"/prefix/dlopen-dbus.patch\" \"/prefix/xdg-config-dirs.patch\" \"/prefix/nix-profiles-library-paths.patch\" \"/prefix/compose-search-path.patch\" ] Edit source. Noogle also knows. Aliases. lib.strings.readPathsFromFile.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.readPathsFromFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.readPathsFromFile. Read a list of paths from file, relative to the rootPath. Lines beginning with # are treated as comments and ignored. Whitespace is significant. NOTE: This function is not performant and should be avoided. Example. readPathsFromFile /prefix ./pkgs/development/libraries/qt-5/5.4/qtbase/series =&gt; [ \"/prefix/dlopen-resolv.patch\" \"/prefix/tzdir.patch\" \"/prefix/dlopen-libXcursor.patch\" \"/prefix/dlopen-openssl.patch\" \"/prefix/dlopen-dbus.patch\" \"/prefix/xdg-config-dirs.patch\" \"/prefix/nix-profiles-library-paths.patch\" \"/prefix/compose-search-path.patch\" ] Edit source. Noogle also knows. Aliases. lib.strings.readPathsFromFile.",
    "raw_url": "/f/lib/readPathsFromFile.html",
    "excerpt": "lib.readPathsFromFile. Read a list of paths from file, relative to the rootPath. Lines beginning with # are treated as comments and ignored. Whitespace is significant. NOTE: This function is not",
    "sub_results": []
  },
  {
    "url": "/f/lib/getAttr.html",
    "content": "lib.getAttr Primop. Takes 2 arguments. s, set. getAttr returns the attribute named s from set. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the . operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. builtins.getAttr. lib.attrsets.getAttr.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getAttr Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getAttr Primop. Takes 2 arguments. s, set. getAttr returns the attribute named s from set. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the . operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. builtins.getAttr. lib.attrsets.getAttr.",
    "raw_url": "/f/lib/getAttr.html",
    "excerpt": "lib.getAttr Primop. Takes 2 arguments. s, set. getAttr returns the attribute named s from set. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the .",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkDefault.html",
    "content": "lib.mkDefault. Noogle also knows. Aliases. lib.modules.mkDefault.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkDefault"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkDefault. Noogle also knows. Aliases. lib.modules.mkDefault.",
    "raw_url": "/f/lib/mkDefault.html",
    "excerpt": "lib.mkDefault. Noogle also knows. Aliases. lib.modules.mkDefault.",
    "sub_results": []
  },
  {
    "url": "/f/lib/zipAttrsWithNames.html",
    "content": "lib.zipAttrsWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; } Type. zipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet Arguments. [names] List of attribute names to zip. [f] A function, accepts an attribute name, all the values, and returns a combined value. [sets] List of values from the list of attribute sets. Edit source. Noogle also knows. Aliases. lib.attrsets.zipAttrsWithNames.",
    "word_count": 96,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.zipAttrsWithNames"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 36
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 56
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.zipAttrsWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; } Type. zipAttrsWithNames :: [ String ] -&gt; (String -&gt; [ Any ] -&gt; Any) -&gt; [ AttrSet ] -&gt; AttrSet Arguments. [names] List of attribute names to zip. [f] A function, accepts an attribute name, all the values, and returns a combined value. [sets] List of values from the list of attribute sets. Edit source. Noogle also knows. Aliases. lib.attrsets.zipAttrsWithNames.",
    "raw_url": "/f/lib/zipAttrsWithNames.html",
    "excerpt": "lib.zipAttrsWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/splitVersion.html",
    "content": "lib.splitVersion Primop. Takes 1 arguments. s. Break a version string into its component parts. Example. splitVersion \"1.2.3\" => [\"1\" \"2\" \"3\"] Edit source. Noogle also knows. Aliases. builtins.splitVersion. lib.versions.splitVersion.",
    "word_count": 29,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.splitVersion Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.splitVersion Primop. Takes 1 arguments. s. Break a version string into its component parts. Example. splitVersion \"1.2.3\" =&gt; [\"1\" \"2\" \"3\"] Edit source. Noogle also knows. Aliases. builtins.splitVersion. lib.versions.splitVersion.",
    "raw_url": "/f/lib/splitVersion.html",
    "excerpt": "lib.splitVersion Primop. Takes 1 arguments. s. Break a version string into its component parts. Example. splitVersion \"1.2.3\" =&gt; [\"1\" \"2\" \"3\"] Edit source. Noogle also knows. Aliases. builtins.splitVersion. lib.versions.splitVersion.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/enum.html",
    "content": "lib.types.enum. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.enum"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.enum. Edit source.",
    "raw_url": "/f/lib/types/enum.html",
    "excerpt": "lib.types.enum. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/optionDescriptionPhrase.html",
    "content": "lib.types.optionDescriptionPhrase. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.optionDescriptionPhrase"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.optionDescriptionPhrase. Edit source.",
    "raw_url": "/f/lib/types/optionDescriptionPhrase.html",
    "excerpt": "lib.types.optionDescriptionPhrase. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/addCheck.html",
    "content": "lib.types.addCheck. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.addCheck"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.addCheck. Edit source.",
    "raw_url": "/f/lib/types/addCheck.html",
    "excerpt": "lib.types.addCheck. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/defaultTypeMerge.html",
    "content": "lib.types.defaultTypeMerge. Edit source. Noogle also knows. Aliases. lib.defaultTypeMerge.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.defaultTypeMerge"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.defaultTypeMerge. Edit source. Noogle also knows. Aliases. lib.defaultTypeMerge.",
    "raw_url": "/f/lib/types/defaultTypeMerge.html",
    "excerpt": "lib.types.defaultTypeMerge. Edit source. Noogle also knows. Aliases. lib.defaultTypeMerge.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/setType.html",
    "content": "lib.types.setType. Edit source. Noogle also knows. Aliases. lib.setType.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.setType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.setType. Edit source. Noogle also knows. Aliases. lib.setType.",
    "raw_url": "/f/lib/types/setType.html",
    "excerpt": "lib.types.setType. Edit source. Noogle also knows. Aliases. lib.setType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/listOf.html",
    "content": "lib.types.listOf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.listOf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.listOf. Edit source.",
    "raw_url": "/f/lib/types/listOf.html",
    "excerpt": "lib.types.listOf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/either.html",
    "content": "lib.types.either. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.either"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.either. Edit source.",
    "raw_url": "/f/lib/types/either.html",
    "excerpt": "lib.types.either. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/nonEmptyListOf.html",
    "content": "lib.types.nonEmptyListOf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.nonEmptyListOf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.nonEmptyListOf. Edit source.",
    "raw_url": "/f/lib/types/nonEmptyListOf.html",
    "excerpt": "lib.types.nonEmptyListOf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/defaultFunctor.html",
    "content": "lib.types.defaultFunctor. Edit source. Noogle also knows. Aliases. lib.defaultFunctor.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.defaultFunctor"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.defaultFunctor. Edit source. Noogle also knows. Aliases. lib.defaultFunctor.",
    "raw_url": "/f/lib/types/defaultFunctor.html",
    "excerpt": "lib.types.defaultFunctor. Edit source. Noogle also knows. Aliases. lib.defaultFunctor.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/deferredModuleWith.html",
    "content": "lib.types.deferredModuleWith. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.deferredModuleWith"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.deferredModuleWith. Edit source.",
    "raw_url": "/f/lib/types/deferredModuleWith.html",
    "excerpt": "lib.types.deferredModuleWith. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/attrsOf.html",
    "content": "lib.types.attrsOf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.attrsOf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.attrsOf. Edit source.",
    "raw_url": "/f/lib/types/attrsOf.html",
    "excerpt": "lib.types.attrsOf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/unique.html",
    "content": "lib.types.unique. Remove duplicate elements from the list. O(n^2) complexity. Example. unique [ 3 2 3 4 ] => [ 3 2 4 ] Type. unique :: [a] -> [a] Edit source. Noogle also knows. Aliases. lib.unique. lib.lists.unique.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.unique"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.unique. Remove duplicate elements from the list. O(n^2) complexity. Example. unique [ 3 2 3 4 ] =&gt; [ 3 2 4 ] Type. unique :: [a] -&gt; [a] Edit source. Noogle also knows. Aliases. lib.unique. lib.lists.unique.",
    "raw_url": "/f/lib/types/unique.html",
    "excerpt": "lib.types.unique. Remove duplicate elements from the list. O(n^2) complexity. Example. unique [ 3 2 3 4 ] =&gt; [ 3 2 4 ] Type. unique :: [a] -&gt; [a] Edit",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/isType.html",
    "content": "lib.types.isType. Edit source. Noogle also knows. Aliases. lib.isType.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.isType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.isType. Edit source. Noogle also knows. Aliases. lib.isType.",
    "raw_url": "/f/lib/types/isType.html",
    "excerpt": "lib.types.isType. Edit source. Noogle also knows. Aliases. lib.isType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/passwdEntry.html",
    "content": "lib.types.passwdEntry. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.passwdEntry"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.passwdEntry. Edit source.",
    "raw_url": "/f/lib/types/passwdEntry.html",
    "excerpt": "lib.types.passwdEntry. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/ints/between.html",
    "content": "lib.types.ints.between. Edit source. Noogle also knows. Aliases. lib.types.numbers.between.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.ints.between"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.ints.between. Edit source. Noogle also knows. Aliases. lib.types.numbers.between.",
    "raw_url": "/f/lib/types/ints/between.html",
    "excerpt": "lib.types.ints.between. Edit source. Noogle also knows. Aliases. lib.types.numbers.between.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/submodule.html",
    "content": "lib.types.submodule. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.submodule"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.submodule. Edit source.",
    "raw_url": "/f/lib/types/submodule.html",
    "excerpt": "lib.types.submodule. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/nullOr.html",
    "content": "lib.types.nullOr. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.nullOr"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.nullOr. Edit source.",
    "raw_url": "/f/lib/types/nullOr.html",
    "excerpt": "lib.types.nullOr. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/mkOptionType.html",
    "content": "lib.types.mkOptionType. Edit source. Noogle also knows. Aliases. lib.mkOptionType.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.mkOptionType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.mkOptionType. Edit source. Noogle also knows. Aliases. lib.mkOptionType.",
    "raw_url": "/f/lib/types/mkOptionType.html",
    "excerpt": "lib.types.mkOptionType. Edit source. Noogle also knows. Aliases. lib.mkOptionType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/coercedTo.html",
    "content": "lib.types.coercedTo. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.coercedTo"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.coercedTo. Edit source.",
    "raw_url": "/f/lib/types/coercedTo.html",
    "excerpt": "lib.types.coercedTo. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/uniq.html",
    "content": "lib.types.uniq. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.uniq"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.uniq. Edit source.",
    "raw_url": "/f/lib/types/uniq.html",
    "excerpt": "lib.types.uniq. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/functionTo.html",
    "content": "lib.types.functionTo. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.functionTo"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.functionTo. Edit source.",
    "raw_url": "/f/lib/types/functionTo.html",
    "excerpt": "lib.types.functionTo. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/isOptionType.html",
    "content": "lib.types.isOptionType. Noogle also knows. Aliases. lib.isOptionType.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.isOptionType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.isOptionType. Noogle also knows. Aliases. lib.isOptionType.",
    "raw_url": "/f/lib/types/isOptionType.html",
    "excerpt": "lib.types.isOptionType. Noogle also knows. Aliases. lib.isOptionType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/numbers/between.html",
    "content": "lib.types.numbers.between. Edit source. Noogle also knows. Aliases. lib.types.ints.between.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.numbers.between"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.numbers.between. Edit source. Noogle also knows. Aliases. lib.types.ints.between.",
    "raw_url": "/f/lib/types/numbers/between.html",
    "excerpt": "lib.types.numbers.between. Edit source. Noogle also knows. Aliases. lib.types.ints.between.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/strMatching.html",
    "content": "lib.types.strMatching. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.strMatching"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.strMatching. Edit source.",
    "raw_url": "/f/lib/types/strMatching.html",
    "excerpt": "lib.types.strMatching. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/submoduleWith.html",
    "content": "lib.types.submoduleWith. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.submoduleWith"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.submoduleWith. Edit source.",
    "raw_url": "/f/lib/types/submoduleWith.html",
    "excerpt": "lib.types.submoduleWith. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/lazyAttrsOf.html",
    "content": "lib.types.lazyAttrsOf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.lazyAttrsOf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.lazyAttrsOf. Edit source.",
    "raw_url": "/f/lib/types/lazyAttrsOf.html",
    "excerpt": "lib.types.lazyAttrsOf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/oneOf.html",
    "content": "lib.types.oneOf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.oneOf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.oneOf. Edit source.",
    "raw_url": "/f/lib/types/oneOf.html",
    "excerpt": "lib.types.oneOf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/separatedString.html",
    "content": "lib.types.separatedString. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.separatedString"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.separatedString. Edit source.",
    "raw_url": "/f/lib/types/separatedString.html",
    "excerpt": "lib.types.separatedString. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/types/loaOf.html",
    "content": "lib.types.loaOf. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.types.loaOf"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.types.loaOf. Edit source.",
    "raw_url": "/f/lib/types/loaOf.html",
    "excerpt": "lib.types.loaOf. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mapNullable.html",
    "content": "lib.mapNullable. Apply function if the supplied argument is non-null. Example. mapNullable (x: x+1) null => null mapNullable (x: x+1) 22 => 23 Arguments. [f] Function to call. [a] Argument to check for null before passing it to f. Edit source. Noogle also knows. Aliases. lib.trivial.mapNullable.",
    "word_count": 45,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mapNullable"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 22
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mapNullable. Apply function if the supplied argument is non-null. Example. mapNullable (x: x+1) null =&gt; null mapNullable (x: x+1) 22 =&gt; 23 Arguments. [f] Function to call. [a] Argument to check for null before passing it to f. Edit source. Noogle also knows. Aliases. lib.trivial.mapNullable.",
    "raw_url": "/f/lib/mapNullable.html",
    "excerpt": "lib.mapNullable. Apply function if the supplied argument is non-null. Example. mapNullable (x: x+1) null =&gt; null mapNullable (x: x+1) 22 =&gt; 23 Arguments. [f] Function to call. [a] Argument to",
    "sub_results": []
  },
  {
    "url": "/f/lib/concatMapStrings.html",
    "content": "lib.concatMapStrings. Map a function over a list and concatenate the resulting strings. Example. concatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"] => \"afooabar\" Type. concatMapStrings :: (a -> string) -> [a] -> string Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.strings.concatMapStrings.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concatMapStrings"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concatMapStrings. Map a function over a list and concatenate the resulting strings. Example. concatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"] =&gt; \"afooabar\" Type. concatMapStrings :: (a -&gt; string) -&gt; [a] -&gt; string Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.strings.concatMapStrings.",
    "raw_url": "/f/lib/concatMapStrings.html",
    "excerpt": "lib.concatMapStrings. Map a function over a list and concatenate the resulting strings. Example. concatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"] =&gt; \"afooabar\" Type. concatMapStrings :: (a -&gt; string) -&gt; [a]",
    "sub_results": []
  },
  {
    "url": "/f/lib/hydraJob.html",
    "content": "lib.hydraJob. Strip a derivation of all non-essential attributes, returning only those needed by hydra-eval-jobs. Also strictly evaluate the result to ensure that there are no thunks kept alive to prevent garbage collection. Type. hydraJob :: (Derivation | Null) -> (Derivation | Null) Arguments. [drv] Edit source. Noogle also knows. Aliases. lib.customisation.hydraJob.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.hydraJob"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.hydraJob. Strip a derivation of all non-essential attributes, returning only those needed by hydra-eval-jobs. Also strictly evaluate the result to ensure that there are no thunks kept alive to prevent garbage collection. Type. hydraJob :: (Derivation | Null) -&gt; (Derivation | Null) Arguments. [drv] Edit source. Noogle also knows. Aliases. lib.customisation.hydraJob.",
    "raw_url": "/f/lib/hydraJob.html",
    "excerpt": "lib.hydraJob. Strip a derivation of all non-essential attributes, returning only those needed by hydra-eval-jobs. Also strictly evaluate the result to ensure that there are no thunks kept alive to prevent",
    "sub_results": []
  },
  {
    "url": "/f/lib/isString.html",
    "content": "lib.isString Primop. Takes 1 arguments. e. Return true if e evaluates to a string, and false otherwise. Noogle also knows. Aliases. builtins.isString. lib.strings.isString.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isString Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isString Primop. Takes 1 arguments. e. Return true if e evaluates to a string, and false otherwise. Noogle also knows. Aliases. builtins.isString. lib.strings.isString.",
    "raw_url": "/f/lib/isString.html",
    "excerpt": "lib.isString Primop. Takes 1 arguments. e. Return true if e evaluates to a string, and false otherwise. Noogle also knows. Aliases. builtins.isString. lib.strings.isString.",
    "sub_results": []
  },
  {
    "url": "/f/lib/escapeXML.html",
    "content": "lib.escapeXML. Escapes a string such that it is safe to include verbatim in an XML document. Example. escapeXML ''\"test\" 'test' < & >'' => \"&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;\" Type. string -> string Edit source. Noogle also knows. Aliases. lib.strings.escapeXML.",
    "word_count": 40,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.escapeXML"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.escapeXML. Escapes a string such that it is safe to include verbatim in an XML document. Example. escapeXML ''\"test\" 'test' &lt; & &gt;'' =&gt; \"&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;\" Type. string -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.escapeXML.",
    "raw_url": "/f/lib/escapeXML.html",
    "excerpt": "lib.escapeXML. Escapes a string such that it is safe to include verbatim in an XML document. Example. escapeXML ''\"test\" 'test' &lt; & &gt;'' =&gt; \"&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;\" Type.",
    "sub_results": []
  },
  {
    "url": "/f/lib/intersectLists.html",
    "content": "lib.intersectLists. Intersects list 'e' and another list. O(nm) complexity. Example. intersectLists [ 1 2 3 ] [ 6 3 2 ] => [ 3 2 ] Arguments. [e] Edit source. Noogle also knows. Aliases. lib.lists.intersectLists.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.intersectLists"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.intersectLists. Intersects list 'e' and another list. O(nm) complexity. Example. intersectLists [ 1 2 3 ] [ 6 3 2 ] =&gt; [ 3 2 ] Arguments. [e] Edit source. Noogle also knows. Aliases. lib.lists.intersectLists.",
    "raw_url": "/f/lib/intersectLists.html",
    "excerpt": "lib.intersectLists. Intersects list 'e' and another list. O(nm) complexity. Example. intersectLists [ 1 2 3 ] [ 6 3 2 ] =&gt; [ 3 2 ] Arguments. [e] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/literalExpression.html",
    "content": "lib.literalExpression. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values, e.g. functions, or values that depend on other values or packages. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.options.literalExpression.",
    "word_count": 50,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.literalExpression"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.literalExpression. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values, e.g. functions, or values that depend on other values or packages. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.options.literalExpression.",
    "raw_url": "/f/lib/literalExpression.html",
    "excerpt": "lib.literalExpression. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values,",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkDerivedConfig.html",
    "content": "lib.mkDerivedConfig. mkDerivedConfig : Option a -> (a -> Definition b) -> Definition b Create config definitions with the same priority as the definition of another option. This should be used for option definitions where one option sets the value of another as a convenience. For instance a config file could be set with a text or source option, where text translates to a source value using mkDerivedConfig options.text (pkgs.writeText \"filename.conf\"). It takes care of setting the right priority using mkOverride. Arguments. [opt] [f] Edit source. Noogle also knows. Aliases. lib.modules.mkDerivedConfig.",
    "word_count": 90,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkDerivedConfig"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 80
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkDerivedConfig. mkDerivedConfig : Option a -&gt; (a -&gt; Definition b) -&gt; Definition b Create config definitions with the same priority as the definition of another option. This should be used for option definitions where one option sets the value of another as a convenience. For instance a config file could be set with a text or source option, where text translates to a source value using mkDerivedConfig options.text (pkgs.writeText \"filename.conf\"). It takes care of setting the right priority using mkOverride. Arguments. [opt] [f] Edit source. Noogle also knows. Aliases. lib.modules.mkDerivedConfig.",
    "raw_url": "/f/lib/mkDerivedConfig.html",
    "excerpt": "lib.mkDerivedConfig. mkDerivedConfig : Option a -&gt; (a -&gt; Definition b) -&gt; Definition b Create config definitions with the same priority as the definition of another option. This should be used",
    "sub_results": []
  },
  {
    "url": "/f/lib/checkFlag.html",
    "content": "lib.checkFlag. Edit source. Noogle also knows. Aliases. lib.misc.checkFlag.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.checkFlag"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.checkFlag. Edit source. Noogle also knows. Aliases. lib.misc.checkFlag.",
    "raw_url": "/f/lib/checkFlag.html",
    "excerpt": "lib.checkFlag. Edit source. Noogle also knows. Aliases. lib.misc.checkFlag.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trace.html",
    "content": "lib.trace Primop. Takes 2 arguments. e1, e2. Evaluate e1 and print its abstract syntax representation on standard error. Then return e2. This function is useful for debugging. Noogle also knows. Aliases. builtins.trace.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trace Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trace Primop. Takes 2 arguments. e1, e2. Evaluate e1 and print its abstract syntax representation on standard error. Then return e2. This function is useful for debugging. Noogle also knows. Aliases. builtins.trace.",
    "raw_url": "/f/lib/trace.html",
    "excerpt": "lib.trace Primop. Takes 2 arguments. e1, e2. Evaluate e1 and print its abstract syntax representation on standard error. Then return e2. This function is useful for debugging. Noogle also knows.",
    "sub_results": []
  },
  {
    "url": "/f/lib/concatLists.html",
    "content": "lib.concatLists Primop. Takes 1 arguments. lists. Concatenate a list of lists into a single list. Noogle also knows. Aliases. builtins.concatLists. lib.lists.concatLists.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concatLists Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concatLists Primop. Takes 1 arguments. lists. Concatenate a list of lists into a single list. Noogle also knows. Aliases. builtins.concatLists. lib.lists.concatLists.",
    "raw_url": "/f/lib/concatLists.html",
    "excerpt": "lib.concatLists Primop. Takes 1 arguments. lists. Concatenate a list of lists into a single list. Noogle also knows. Aliases. builtins.concatLists. lib.lists.concatLists.",
    "sub_results": []
  },
  {
    "url": "/f/lib/traceSeq.html",
    "content": "lib.traceSeq. builtins.trace, but the value is builtins.deepSeqed first. Example. trace { a.b.c = 3; } null trace: { a = <CODE>; } => null traceSeq { a.b.c = 3; } null trace: { a = { b = { c = 3; }; }; } => null Type. traceSeq :: a -> b -> b Arguments. [x] The value to trace. [y] The value to return. Edit source. Noogle also knows. Aliases. lib.debug.traceSeq.",
    "word_count": 73,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.traceSeq"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 8
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.traceSeq. builtins.trace, but the value is builtins.deepSeqed first. Example. trace { a.b.c = 3; } null trace: { a = &lt;CODE&gt;; } =&gt; null traceSeq { a.b.c = 3; } null trace: { a = { b = { c = 3; }; }; } =&gt; null Type. traceSeq :: a -&gt; b -&gt; b Arguments. [x] The value to trace. [y] The value to return. Edit source. Noogle also knows. Aliases. lib.debug.traceSeq.",
    "raw_url": "/f/lib/traceSeq.html",
    "excerpt": "lib.traceSeq. builtins.trace, but the value is builtins.deepSeqed first. Example. trace { a.b.c = 3; } null trace: { a = &lt;CODE&gt;; } =&gt; null traceSeq { a.b.c = 3; }",
    "sub_results": []
  },
  {
    "url": "/f/lib/path/hasPrefix.html",
    "content": "lib.path.hasPrefix. Whether the first path is a component-wise prefix of the second path. Laws: hasPrefix p q is only true if q == append p s for some subpath s. hasPrefix is a non-strict partial order over the set of all path values. Example. hasPrefix /foo /foo/bar => true hasPrefix /foo /foo => true hasPrefix /foo/bar /foo => false hasPrefix /. /foo => true Type. hasPrefix :: Path -> Path -> Bool Arguments. [path1] Edit source. Noogle also knows. Aliases. lib.hasPrefix. lib.lists.hasPrefix. lib.strings.hasPrefix.",
    "word_count": 83,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.path.hasPrefix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 43
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 64
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 72
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.path.hasPrefix. Whether the first path is a component-wise prefix of the second path. Laws: hasPrefix p q is only true if q == append p s for some subpath s. hasPrefix is a non-strict partial order over the set of all path values. Example. hasPrefix /foo /foo/bar =&gt; true hasPrefix /foo /foo =&gt; true hasPrefix /foo/bar /foo =&gt; false hasPrefix /. /foo =&gt; true Type. hasPrefix :: Path -&gt; Path -&gt; Bool Arguments. [path1] Edit source. Noogle also knows. Aliases. lib.hasPrefix. lib.lists.hasPrefix. lib.strings.hasPrefix.",
    "raw_url": "/f/lib/path/hasPrefix.html",
    "excerpt": "lib.path.hasPrefix. Whether the first path is a component-wise prefix of the second path. Laws: hasPrefix p q is only true if q == append p s for some subpath s.",
    "sub_results": []
  },
  {
    "url": "/f/lib/path/removePrefix.html",
    "content": "lib.path.removePrefix. Remove the first path as a component-wise prefix from the second path. The result is a normalised subpath string. Laws: Inverts append for normalised subpath string: removePrefix p (append p s) == subpath.normalise s. Example. removePrefix /foo /foo/bar/baz => \"./bar/baz\" removePrefix /foo /foo => \"./.\" removePrefix /foo/bar /foo => <error> removePrefix /. /foo => \"./foo\" Type. removePrefix :: Path -> Path -> String Arguments. [path1] Edit source. Noogle also knows. Aliases. lib.removePrefix. lib.lists.removePrefix. lib.strings.removePrefix.",
    "word_count": 75,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.path.removePrefix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 35
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 56
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 64
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.path.removePrefix. Remove the first path as a component-wise prefix from the second path. The result is a normalised subpath string. Laws: Inverts append for normalised subpath string: removePrefix p (append p s) == subpath.normalise s. Example. removePrefix /foo /foo/bar/baz =&gt; \"./bar/baz\" removePrefix /foo /foo =&gt; \"./.\" removePrefix /foo/bar /foo =&gt; &lt;error&gt; removePrefix /. /foo =&gt; \"./foo\" Type. removePrefix :: Path -&gt; Path -&gt; String Arguments. [path1] Edit source. Noogle also knows. Aliases. lib.removePrefix. lib.lists.removePrefix. lib.strings.removePrefix.",
    "raw_url": "/f/lib/path/removePrefix.html",
    "excerpt": "lib.path.removePrefix. Remove the first path as a component-wise prefix from the second path. The result is a normalised subpath string. Laws: Inverts append for normalised subpath string: removePrefix p (append",
    "sub_results": []
  },
  {
    "url": "/f/lib/path/splitRoot.html",
    "content": "lib.path.splitRoot. Split the filesystem root from a path. The result is an attribute set with these attributes: root: The filesystem root of the path, meaning that this directory has no parent directory. subpath: The normalised subpath string that when appended to root returns the original path. Laws: Appending the root and subpath gives the original path: p == append (splitRoot p).root (splitRoot p).subpath. Trying to get the parent directory of root using readDir returns root itself: dirOf (splitRoot p).root == (splitRoot p).root. Example. splitRoot /foo/bar => { root = /.; subpath = \"./foo/bar\"; } splitRoot /. => { root = /.; subpath = \"./.\"; } # Nix neutralises `..` path components for all path values automatically splitRoot /foo/../bar => { root = /.; subpath = \"./bar\"; } splitRoot \"/foo/bar\" => <error> Type. splitRoot :: Path -> { root :: Path, subpath :: String } Arguments. [path] The path to split the root off of. Edit source.",
    "word_count": 156,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.path.splitRoot"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 82
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 131
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 144
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.path.splitRoot. Split the filesystem root from a path. The result is an attribute set with these attributes: root: The filesystem root of the path, meaning that this directory has no parent directory. subpath: The normalised subpath string that when appended to root returns the original path. Laws: Appending the root and subpath gives the original path: p == append (splitRoot p).root (splitRoot p).subpath. Trying to get the parent directory of root using readDir returns root itself: dirOf (splitRoot p).root == (splitRoot p).root. Example. splitRoot /foo/bar =&gt; { root = /.; subpath = \"./foo/bar\"; } splitRoot /. =&gt; { root = /.; subpath = \"./.\"; } # Nix neutralises `..` path components for all path values automatically splitRoot /foo/../bar =&gt; { root = /.; subpath = \"./bar\"; } splitRoot \"/foo/bar\" =&gt; &lt;error&gt; Type. splitRoot :: Path -&gt; { root :: Path, subpath :: String } Arguments. [path] The path to split the root off of. Edit source.",
    "raw_url": "/f/lib/path/splitRoot.html",
    "excerpt": "lib.path.splitRoot. Split the filesystem root from a path. The result is an attribute set with these attributes: root: The filesystem root of the path, meaning that this directory has no",
    "sub_results": []
  },
  {
    "url": "/f/lib/path/subpath/join.html",
    "content": "lib.path.subpath.join. Join subpath strings together using /, returning a normalised subpath string. Like concatStringsSep \"/\" but safer, specifically: All elements must be valid subpath strings. The result gets normalised. The edge case of an empty list gets properly handled by returning the neutral subpath \"./.\". Laws: Associativity: subpath.join [ x (subpath.join [ y z ]) ] == subpath.join [ (subpath.join [ x y ]) z ] Identity - \"./.\" is the neutral element for normalised paths: subpath.join [ ] == \"./.\" subpath.join [ (subpath.normalise p) \"./.\" ] == subpath.normalise p subpath.join [ \"./.\" (subpath.normalise p) ] == subpath.normalise p. Normalisation - the result is normalised: subpath.join ps == subpath.normalise (subpath.join ps). For non-empty lists, the implementation is equivalent to normalising the result of concatStringsSep \"/\". Note that the above laws can be derived from this one: ps != [] -> subpath.join ps == subpath.normalise (concatStringsSep \"/\" ps). Example. subpath.join [ \"foo\" \"bar/baz\" ] => \"./foo/bar/baz\" # normalise the result subpath.join [ \"./foo\" \".\" \"bar//./baz/\" ] => \"./foo/bar/baz\" # passing an empty list results in the current directory subpath.join [ ] => \"./.\" # elements must be valid subpath strings subpath.join [ /foo ] => <error> subpath.join [ \"\" ] => <error> subpath.join [ \"/foo\" ] => <error> subpath.join [ \"../foo\" ] => <error> Type. subpath.join :: [ String ] -> String Arguments. [subpaths] The list of subpaths to join together. Edit source.",
    "word_count": 232,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.path.subpath.join"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 147
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 213
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 221
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.path.subpath.join. Join subpath strings together using /, returning a normalised subpath string. Like concatStringsSep \"/\" but safer, specifically: All elements must be valid subpath strings. The result gets normalised. The edge case of an empty list gets properly handled by returning the neutral subpath \"./.\". Laws: Associativity: subpath.join [ x (subpath.join [ y z ]) ] == subpath.join [ (subpath.join [ x y ]) z ] Identity - \"./.\" is the neutral element for normalised paths: subpath.join [ ] == \"./.\" subpath.join [ (subpath.normalise p) \"./.\" ] == subpath.normalise p subpath.join [ \"./.\" (subpath.normalise p) ] == subpath.normalise p. Normalisation - the result is normalised: subpath.join ps == subpath.normalise (subpath.join ps). For non-empty lists, the implementation is equivalent to normalising the result of concatStringsSep \"/\". Note that the above laws can be derived from this one: ps != [] -&gt; subpath.join ps == subpath.normalise (concatStringsSep \"/\" ps). Example. subpath.join [ \"foo\" \"bar/baz\" ] =&gt; \"./foo/bar/baz\" # normalise the result subpath.join [ \"./foo\" \".\" \"bar//./baz/\" ] =&gt; \"./foo/bar/baz\" # passing an empty list results in the current directory subpath.join [ ] =&gt; \"./.\" # elements must be valid subpath strings subpath.join [ /foo ] =&gt; &lt;error&gt; subpath.join [ \"\" ] =&gt; &lt;error&gt; subpath.join [ \"/foo\" ] =&gt; &lt;error&gt; subpath.join [ \"../foo\" ] =&gt; &lt;error&gt; Type. subpath.join :: [ String ] -&gt; String Arguments. [subpaths] The list of subpaths to join together. Edit source.",
    "raw_url": "/f/lib/path/subpath/join.html",
    "excerpt": "lib.path.subpath.join. Join subpath strings together using /, returning a normalised subpath string. Like concatStringsSep \"/\" but safer, specifically: All elements must be valid subpath strings. The result gets normalised. The",
    "sub_results": []
  },
  {
    "url": "/f/lib/path/subpath/normalise.html",
    "content": "lib.path.subpath.normalise. Normalise a subpath. Throw an error if the subpath isn't valid. Limit repeating / to a single one. Remove redundant . components. Remove trailing / and /.. Add leading ./. Laws: Idempotency - normalising multiple times gives the same result: subpath.normalise (subpath.normalise p) == subpath.normalise p. Uniqueness - there's only a single normalisation for the paths that lead to the same file system node: subpath.normalise p != subpath.normalise q -> $(realpath ${p}) != $(realpath ${q}). Don't change the result when appended to a Nix path value: append base p == append base (subpath.normalise p). Don't change the path according to realpath: $(realpath ${p}) == $(realpath ${subpath.normalise p}). Only error on invalid subpaths: builtins.tryEval (subpath.normalise p)).success == subpath.isValid p. Example. # limit repeating `/` to a single one subpath.normalise \"foo//bar\" => \"./foo/bar\" # remove redundant `.` components subpath.normalise \"foo/./bar\" => \"./foo/bar\" # add leading `./` subpath.normalise \"foo/bar\" => \"./foo/bar\" # remove trailing `/` subpath.normalise \"foo/bar/\" => \"./foo/bar\" # remove trailing `/.` subpath.normalise \"foo/bar/.\" => \"./foo/bar\" # Return the current directory as `./.` subpath.normalise \".\" => \"./.\" # error on `..` path components subpath.normalise \"foo/../bar\" => <error> # error on empty string subpath.normalise \"\" => <error> # error on absolute path subpath.normalise \"/foo\" => <error> Type. subpath.normalise :: String -> String Arguments. [subpath] The subpath string to normalise. Edit source.",
    "word_count": 219,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.path.subpath.normalise"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 119
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 204
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 210
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.path.subpath.normalise. Normalise a subpath. Throw an error if the subpath isn't valid. Limit repeating / to a single one. Remove redundant . components. Remove trailing / and /.. Add leading ./. Laws: Idempotency - normalising multiple times gives the same result: subpath.normalise (subpath.normalise p) == subpath.normalise p. Uniqueness - there's only a single normalisation for the paths that lead to the same file system node: subpath.normalise p != subpath.normalise q -&gt; $(realpath ${p}) != $(realpath ${q}). Don't change the result when appended to a Nix path value: append base p == append base (subpath.normalise p). Don't change the path according to realpath: $(realpath ${p}) == $(realpath ${subpath.normalise p}). Only error on invalid subpaths: builtins.tryEval (subpath.normalise p)).success == subpath.isValid p. Example. # limit repeating `/` to a single one subpath.normalise \"foo//bar\" =&gt; \"./foo/bar\" # remove redundant `.` components subpath.normalise \"foo/./bar\" =&gt; \"./foo/bar\" # add leading `./` subpath.normalise \"foo/bar\" =&gt; \"./foo/bar\" # remove trailing `/` subpath.normalise \"foo/bar/\" =&gt; \"./foo/bar\" # remove trailing `/.` subpath.normalise \"foo/bar/.\" =&gt; \"./foo/bar\" # Return the current directory as `./.` subpath.normalise \".\" =&gt; \"./.\" # error on `..` path components subpath.normalise \"foo/../bar\" =&gt; &lt;error&gt; # error on empty string subpath.normalise \"\" =&gt; &lt;error&gt; # error on absolute path subpath.normalise \"/foo\" =&gt; &lt;error&gt; Type. subpath.normalise :: String -&gt; String Arguments. [subpath] The subpath string to normalise. Edit source.",
    "raw_url": "/f/lib/path/subpath/normalise.html",
    "excerpt": "lib.path.subpath.normalise. Normalise a subpath. Throw an error if the subpath isn't valid. Limit repeating / to a single one. Remove redundant . components. Remove trailing / and /.. Add leading",
    "sub_results": []
  },
  {
    "url": "/f/lib/path/subpath/components.html",
    "content": "lib.path.subpath.components. Split a subpath into its path component strings. Throw an error if the subpath isn't valid. Note that the returned path components are also valid subpath strings, though they are intentionally not normalised. Laws: Splitting a subpath into components and joining the components gives the same subpath but normalised: subpath.join (subpath.components s) == subpath.normalise s. Example. subpath.components \".\" => [ ] subpath.components \"./foo//bar/./baz/\" => [ \"foo\" \"bar\" \"baz\" ] subpath.components \"/foo\" => <error> Type. subpath.components :: String -> [ String ] Arguments. [subpath] The subpath string to split into components. Edit source.",
    "word_count": 93,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.path.subpath.components"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 56
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 74
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 82
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.path.subpath.components. Split a subpath into its path component strings. Throw an error if the subpath isn't valid. Note that the returned path components are also valid subpath strings, though they are intentionally not normalised. Laws: Splitting a subpath into components and joining the components gives the same subpath but normalised: subpath.join (subpath.components s) == subpath.normalise s. Example. subpath.components \".\" =&gt; [ ] subpath.components \"./foo//bar/./baz/\" =&gt; [ \"foo\" \"bar\" \"baz\" ] subpath.components \"/foo\" =&gt; &lt;error&gt; Type. subpath.components :: String -&gt; [ String ] Arguments. [subpath] The subpath string to split into components. Edit source.",
    "raw_url": "/f/lib/path/subpath/components.html",
    "excerpt": "lib.path.subpath.components. Split a subpath into its path component strings. Throw an error if the subpath isn't valid. Note that the returned path components are also valid subpath strings, though they",
    "sub_results": []
  },
  {
    "url": "/f/lib/path/subpath/isValid.html",
    "content": "lib.path.subpath.isValid. Whether a value is a valid subpath string. A subpath string points to a specific file or directory within an absolute base directory. It is a stricter form of a relative path that excludes .. components, since those could escape the base directory. The value is a string. The string is not empty. The string doesn't start with a /. The string doesn't contain any .. path components. Example. # Not a string subpath.isValid null => false # Empty string subpath.isValid \"\" => false # Absolute path subpath.isValid \"/foo\" => false # Contains a `..` path component subpath.isValid \"../foo\" => false # Valid subpath subpath.isValid \"foo/bar\" => true # Doesn't need to be normalised subpath.isValid \"./foo//bar/\" => true Type. subpath.isValid :: String -> Bool Arguments. [value] The value to check. Edit source.",
    "word_count": 133,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.path.subpath.isValid"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 69
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 119
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 125
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.path.subpath.isValid. Whether a value is a valid subpath string. A subpath string points to a specific file or directory within an absolute base directory. It is a stricter form of a relative path that excludes .. components, since those could escape the base directory. The value is a string. The string is not empty. The string doesn't start with a /. The string doesn't contain any .. path components. Example. # Not a string subpath.isValid null =&gt; false # Empty string subpath.isValid \"\" =&gt; false # Absolute path subpath.isValid \"/foo\" =&gt; false # Contains a `..` path component subpath.isValid \"../foo\" =&gt; false # Valid subpath subpath.isValid \"foo/bar\" =&gt; true # Doesn't need to be normalised subpath.isValid \"./foo//bar/\" =&gt; true Type. subpath.isValid :: String -&gt; Bool Arguments. [value] The value to check. Edit source.",
    "raw_url": "/f/lib/path/subpath/isValid.html",
    "excerpt": "lib.path.subpath.isValid. Whether a value is a valid subpath string. A subpath string points to a specific file or directory within an absolute base directory. It is a stricter form of",
    "sub_results": []
  },
  {
    "url": "/f/lib/path/append.html",
    "content": "lib.path.append. Append a subpath string to a path. Like path + (\"/\" + string) but safer, because it errors instead of returning potentially surprising results. More specifically, it checks that the first argument is a path value type, and that the second argument is a valid subpath string. Laws: Not influenced by subpath normalisation: append p s == append p (subpath.normalise s). Example. append /foo \"bar/baz\" => /foo/bar/baz # subpaths don't need to be normalised append /foo \"./bar//baz/./\" => /foo/bar/baz # can append to root directory append /. \"foo/bar\" => /foo/bar # first argument needs to be a path value type append \"/foo\" \"bar\" => <error> # second argument needs to be a valid subpath string append /foo /bar => <error> append /foo \"\" => <error> append /foo \"/bar\" => <error> append /foo \"../bar\" => <error> Type. append :: Path -> String -> Path Arguments. [path] The absolute path to append to. [subpath] The subpath string to append. Edit source.",
    "word_count": 160,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.path.append"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 62
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 136
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 144
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.path.append. Append a subpath string to a path. Like path + (\"/\" + string) but safer, because it errors instead of returning potentially surprising results. More specifically, it checks that the first argument is a path value type, and that the second argument is a valid subpath string. Laws: Not influenced by subpath normalisation: append p s == append p (subpath.normalise s). Example. append /foo \"bar/baz\" =&gt; /foo/bar/baz # subpaths don't need to be normalised append /foo \"./bar//baz/./\" =&gt; /foo/bar/baz # can append to root directory append /. \"foo/bar\" =&gt; /foo/bar # first argument needs to be a path value type append \"/foo\" \"bar\" =&gt; &lt;error&gt; # second argument needs to be a valid subpath string append /foo /bar =&gt; &lt;error&gt; append /foo \"\" =&gt; &lt;error&gt; append /foo \"/bar\" =&gt; &lt;error&gt; append /foo \"../bar\" =&gt; &lt;error&gt; Type. append :: Path -&gt; String -&gt; Path Arguments. [path] The absolute path to append to. [subpath] The subpath string to append. Edit source.",
    "raw_url": "/f/lib/path/append.html",
    "excerpt": "lib.path.append. Append a subpath string to a path. Like path + (\"/\" + string) but safer, because it errors instead of returning potentially surprising results. More specifically, it checks that",
    "sub_results": []
  },
  {
    "url": "/f/lib/filterOverrides.html",
    "content": "lib.filterOverrides. Given a list of config values, process the mkOverride properties, that is, return the values that have the highest (that is, numerically lowest) priority, and strip the mkOverride properties. For example, [ { file = \"/1\"; value = mkOverride 10 \"a\"; } { file = \"/2\"; value = mkOverride 20 \"b\"; } { file = \"/3\"; value = \"z\"; } { file = \"/4\"; value = mkOverride 10 \"d\"; } ] yields [ { file = \"/1\"; value = \"a\"; } { file = \"/4\"; value = \"d\"; } ] Note that \"z\" has the default priority 100. Arguments. [defs] Edit source. Noogle also knows. Aliases. lib.modules.filterOverrides.",
    "word_count": 108,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.filterOverrides"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 99
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.filterOverrides. Given a list of config values, process the mkOverride properties, that is, return the values that have the highest (that is, numerically lowest) priority, and strip the mkOverride properties. For example, [ { file = \"/1\"; value = mkOverride 10 \"a\"; } { file = \"/2\"; value = mkOverride 20 \"b\"; } { file = \"/3\"; value = \"z\"; } { file = \"/4\"; value = mkOverride 10 \"d\"; } ] yields [ { file = \"/1\"; value = \"a\"; } { file = \"/4\"; value = \"d\"; } ] Note that \"z\" has the default priority 100. Arguments. [defs] Edit source. Noogle also knows. Aliases. lib.modules.filterOverrides.",
    "raw_url": "/f/lib/filterOverrides.html",
    "excerpt": "lib.filterOverrides. Given a list of config values, process the mkOverride properties, that is, return the values that have the highest (that is, numerically lowest) priority, and strip the mkOverride properties.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrsNoOverride.html",
    "content": "lib.mergeAttrsNoOverride. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrsNoOverride.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrsNoOverride"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrsNoOverride. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrsNoOverride.",
    "raw_url": "/f/lib/mergeAttrsNoOverride.html",
    "excerpt": "lib.mergeAttrsNoOverride. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrsNoOverride.",
    "sub_results": []
  },
  {
    "url": "/f/lib/callPackagesWith.html",
    "content": "lib.callPackagesWith. Like callPackage, but for a function that returns an attribute set of derivations. The override function is added to the individual attributes. Type. callPackagesWith :: AttrSet -> ((AttrSet -> AttrSet) | Path) -> AttrSet -> AttrSet Arguments. [autoArgs] [fn] [args] Edit source. Noogle also knows. Aliases. lib.customisation.callPackagesWith.",
    "word_count": 48,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.callPackagesWith"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 37
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.callPackagesWith. Like callPackage, but for a function that returns an attribute set of derivations. The override function is added to the individual attributes. Type. callPackagesWith :: AttrSet -&gt; ((AttrSet -&gt; AttrSet) | Path) -&gt; AttrSet -&gt; AttrSet Arguments. [autoArgs] [fn] [args] Edit source. Noogle also knows. Aliases. lib.customisation.callPackagesWith.",
    "raw_url": "/f/lib/callPackagesWith.html",
    "excerpt": "lib.callPackagesWith. Like callPackage, but for a function that returns an attribute set of derivations. The override function is added to the individual attributes. Type. callPackagesWith :: AttrSet -&gt; ((AttrSet -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/functionArgs.html",
    "content": "lib.functionArgs. Extract the expected function arguments from a function. This works both with nix-native { a, b ? foo, ... }: style functions and functions with args set with 'setFunctionArgs'. It has the same return type and semantics as builtins.functionArgs. setFunctionArgs : (a → b) → Map String Bool. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.trivial.functionArgs.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.functionArgs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 49
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.functionArgs. Extract the expected function arguments from a function. This works both with nix-native { a, b ? foo, ... }: style functions and functions with args set with 'setFunctionArgs'. It has the same return type and semantics as builtins.functionArgs. setFunctionArgs : (a → b) → Map String Bool. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.trivial.functionArgs.",
    "raw_url": "/f/lib/functionArgs.html",
    "excerpt": "lib.functionArgs. Extract the expected function arguments from a function. This works both with nix-native { a, b ? foo, ... }: style functions and functions with args set with 'setFunctionArgs'.",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrValues.html",
    "content": "lib.attrValues Primop. Takes 1 arguments. set. Return the values of all attributes in the given set, sorted by attribute name. Example. attrValues {c = 3; a = 1; b = 2;} => [1 2 3] Type. attrValues :: AttrSet -> [Any] Edit source. Noogle also knows. Aliases. builtins.attrValues. lib.attrsets.attrValues.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrValues Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrValues Primop. Takes 1 arguments. set. Return the values of all attributes in the given set, sorted by attribute name. Example. attrValues {c = 3; a = 1; b = 2;} =&gt; [1 2 3] Type. attrValues :: AttrSet -&gt; [Any] Edit source. Noogle also knows. Aliases. builtins.attrValues. lib.attrsets.attrValues.",
    "raw_url": "/f/lib/attrValues.html",
    "excerpt": "lib.attrValues Primop. Takes 1 arguments. set. Return the values of all attributes in the given set, sorted by attribute name. Example. attrValues {c = 3; a = 1; b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/enableFeatureAs.html",
    "content": "lib.enableFeatureAs. Create an --{enable-=,disable-} string that can be passed to standard GNU Autoconf scripts. Example. enableFeatureAs true \"shared\" \"foo\" => \"--enable-shared=foo\" enableFeatureAs false \"shared\" (throw \"ignored\") => \"--disable-shared\" Arguments. [flag] [feature] [value] Edit source. Noogle also knows. Aliases. lib.strings.enableFeatureAs.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.enableFeatureAs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 28
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.enableFeatureAs. Create an --{enable-=,disable-} string that can be passed to standard GNU Autoconf scripts. Example. enableFeatureAs true \"shared\" \"foo\" =&gt; \"--enable-shared=foo\" enableFeatureAs false \"shared\" (throw \"ignored\") =&gt; \"--disable-shared\" Arguments. [flag] [feature] [value] Edit source. Noogle also knows. Aliases. lib.strings.enableFeatureAs.",
    "raw_url": "/f/lib/enableFeatureAs.html",
    "excerpt": "lib.enableFeatureAs. Create an --{enable-=,disable-} string that can be passed to standard GNU Autoconf scripts. Example. enableFeatureAs true \"shared\" \"foo\" =&gt; \"--enable-shared=foo\" enableFeatureAs false \"shared\" (throw \"ignored\") =&gt; \"--disable-shared\" Arguments. [flag]",
    "sub_results": []
  },
  {
    "url": "/f/lib/replaceStrings.html",
    "content": "lib.replaceStrings Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s. Example: builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\" evaluates to \"fabir\". Noogle also knows. Aliases. builtins.replaceStrings. lib.replaceChars. lib.strings.replaceChars. lib.strings.replaceStrings.",
    "word_count": 66,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.replaceStrings Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.replaceStrings Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s. Example: builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\" evaluates to \"fabir\". Noogle also knows. Aliases. builtins.replaceStrings. lib.replaceChars. lib.strings.replaceChars. lib.strings.replaceStrings.",
    "raw_url": "/f/lib/replaceStrings.html",
    "excerpt": "lib.replaceStrings Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy,",
    "sub_results": []
  },
  {
    "url": "/f/lib/overrideExisting.html",
    "content": "lib.overrideExisting. Override only the attributes that are already present in the old set useful for deep-overriding. Example. overrideExisting {} { a = 1; } => {} overrideExisting { b = 2; } { a = 1; } => { b = 2; } overrideExisting { a = 3; b = 2; } { a = 1; } => { a = 1; b = 2; } Type. overrideExisting :: AttrSet -> AttrSet -> AttrSet Arguments. [old] Original attribute set. [new] Attribute set with attributes to override in old. Edit source. Noogle also knows. Aliases. lib.attrsets.overrideExisting.",
    "word_count": 95,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.overrideExisting"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 66
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 74
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.overrideExisting. Override only the attributes that are already present in the old set useful for deep-overriding. Example. overrideExisting {} { a = 1; } =&gt; {} overrideExisting { b = 2; } { a = 1; } =&gt; { b = 2; } overrideExisting { a = 3; b = 2; } { a = 1; } =&gt; { a = 1; b = 2; } Type. overrideExisting :: AttrSet -&gt; AttrSet -&gt; AttrSet Arguments. [old] Original attribute set. [new] Attribute set with attributes to override in old. Edit source. Noogle also knows. Aliases. lib.attrsets.overrideExisting.",
    "raw_url": "/f/lib/overrideExisting.html",
    "excerpt": "lib.overrideExisting. Override only the attributes that are already present in the old set useful for deep-overriding. Example. overrideExisting {} { a = 1; } =&gt; {} overrideExisting { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/stringToCharacters.html",
    "content": "lib.stringToCharacters. Convert a string to a list of characters (i.e. singleton strings). This allows you to, e.g., map a function over each character. However, note that this will likely be horribly inefficient; Nix is not a general purpose programming language. Complex string manipulations should, if appropriate, be done in a derivation. Also note that Nix treats strings as a list of bytes and thus doesn't handle unicode. Example. stringToCharacters \"\" => [ ] stringToCharacters \"abc\" => [ \"a\" \"b\" \"c\" ] stringToCharacters \"🦄\" => [ \"�\" \"�\" \"�\" \"�\" ] Type. stringToCharacters :: string -> [string] Arguments. [s] Edit source. Noogle also knows. Aliases. lib.strings.stringToCharacters.",
    "word_count": 105,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.stringToCharacters"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 67
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 90
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 96
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.stringToCharacters. Convert a string to a list of characters (i.e. singleton strings). This allows you to, e.g., map a function over each character. However, note that this will likely be horribly inefficient; Nix is not a general purpose programming language. Complex string manipulations should, if appropriate, be done in a derivation. Also note that Nix treats strings as a list of bytes and thus doesn't handle unicode. Example. stringToCharacters \"\" =&gt; [ ] stringToCharacters \"abc\" =&gt; [ \"a\" \"b\" \"c\" ] stringToCharacters \"🦄\" =&gt; [ \"�\" \"�\" \"�\" \"�\" ] Type. stringToCharacters :: string -&gt; [string] Arguments. [s] Edit source. Noogle also knows. Aliases. lib.strings.stringToCharacters.",
    "raw_url": "/f/lib/stringToCharacters.html",
    "excerpt": "lib.stringToCharacters. Convert a string to a list of characters (i.e. singleton strings). This allows you to, e.g., map a function over each character. However, note that this will likely be",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeModules.html",
    "content": "lib.mergeModules. Merge a list of modules. This will recurse over the option declarations in all modules, combining them into a single set. At the same time, for each option declaration, it will merge the corresponding option definitions in all machines, returning them in the ‘value’ attribute of each option. This returns a set like { A recursive set of options along with their final values. matchedOptions = { foo = { _type = \"option\"; value = \"option value of foo\"; ... }; bar.baz = { _type = \"option\"; value = \"option value of bar.baz\"; ... }; ... }; A list of definitions that weren't matched by any option. unmatchedDefns = [ { file = \"file.nix\"; prefix = [ \"qux\" ]; value = \"qux\"; } ... ]; } Arguments. [prefix] [modules] Edit source. Noogle also knows. Aliases. lib.modules.mergeModules.",
    "word_count": 137,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeModules"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "a-recursive-set-of-options-along-with-their-final-values",
        "text": "A recursive set of options along with their final values",
        "location": 55
      },
      {
        "element": "h2",
        "id": "a-list-of-definitions-that-werent-matched-by-any-option",
        "text": "A list of definitions that weren't matched by any option",
        "location": 98
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 127
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeModules. Merge a list of modules. This will recurse over the option declarations in all modules, combining them into a single set. At the same time, for each option declaration, it will merge the corresponding option definitions in all machines, returning them in the ‘value’ attribute of each option. This returns a set like { A recursive set of options along with their final values. matchedOptions = { foo = { _type = \"option\"; value = \"option value of foo\"; ... }; bar.baz = { _type = \"option\"; value = \"option value of bar.baz\"; ... }; ... }; A list of definitions that weren't matched by any option. unmatchedDefns = [ { file = \"file.nix\"; prefix = [ \"qux\" ]; value = \"qux\"; } ... ]; } Arguments. [prefix] [modules] Edit source. Noogle also knows. Aliases. lib.modules.mergeModules.",
    "raw_url": "/f/lib/mergeModules.html",
    "excerpt": "lib.mergeModules. Merge a list of modules. This will recurse over the option declarations in all modules, combining them into a single set. At the same time, for each option declaration,",
    "sub_results": []
  },
  {
    "url": "/f/lib/isList.html",
    "content": "lib.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. builtins.isList. lib.lists.isList. lib.strings.isList.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isList Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. builtins.isList. lib.lists.isList. lib.strings.isList.",
    "raw_url": "/f/lib/isList.html",
    "excerpt": "lib.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. builtins.isList. lib.lists.isList. lib.strings.isList.",
    "sub_results": []
  },
  {
    "url": "/f/lib/doRename.html",
    "content": "lib.doRename. Edit source. Noogle also knows. Aliases. lib.modules.doRename.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.doRename"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.doRename. Edit source. Noogle also knows. Aliases. lib.modules.doRename.",
    "raw_url": "/f/lib/doRename.html",
    "excerpt": "lib.doRename. Edit source. Noogle also knows. Aliases. lib.modules.doRename.",
    "sub_results": []
  },
  {
    "url": "/f/lib/derivations/lazyDerivation.html",
    "content": "lib.derivations.lazyDerivation. Restrict a derivation to a predictable set of attribute names, so that the returned attrset is not strict in the actual derivation, saving a lot of computation when the derivation is non-trivial. This is useful in situations where a derivation might only be used for its passthru attributes, improving evaluation performance. The returned attribute set is lazy in derivation. Specifically, this means that the derivation will not be evaluated in at least the situations below. For illustration and/or testing, we define derivation such that its evaluation is very noticeable. let derivation = throw \"This won't be evaluated.\"; In the following expressions, derivation will not be evaluated: (lazyDerivation { inherit derivation; }).type attrNames (lazyDerivation { inherit derivation; }) (lazyDerivation { inherit derivation; } // { foo = true; }).foo (lazyDerivation { inherit derivation; meta.foo = true; }).meta In these expressions, derivation will be evaluated: \"${lazyDerivation { inherit derivation }}\" (lazyDerivation { inherit derivation }).outPath (lazyDerivation { inherit derivation }).meta And the following expressions are not valid, because the refer to implementation details and/or attributes that may not be present on some derivations: (lazyDerivation { inherit derivation }).buildInputs (lazyDerivation { inherit derivation }).passthru (lazyDerivation { inherit derivation }).pythonPath. Arguments. Edit source. Noogle also knows. Aliases. lib.lazyDerivation.",
    "word_count": 205,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.derivations.lazyDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 197
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.derivations.lazyDerivation. Restrict a derivation to a predictable set of attribute names, so that the returned attrset is not strict in the actual derivation, saving a lot of computation when the derivation is non-trivial. This is useful in situations where a derivation might only be used for its passthru attributes, improving evaluation performance. The returned attribute set is lazy in derivation. Specifically, this means that the derivation will not be evaluated in at least the situations below. For illustration and/or testing, we define derivation such that its evaluation is very noticeable. let derivation = throw \"This won't be evaluated.\"; In the following expressions, derivation will not be evaluated: (lazyDerivation { inherit derivation; }).type attrNames (lazyDerivation { inherit derivation; }) (lazyDerivation { inherit derivation; } // { foo = true; }).foo (lazyDerivation { inherit derivation; meta.foo = true; }).meta In these expressions, derivation will be evaluated: \"${lazyDerivation { inherit derivation }}\" (lazyDerivation { inherit derivation }).outPath (lazyDerivation { inherit derivation }).meta And the following expressions are not valid, because the refer to implementation details and/or attributes that may not be present on some derivations: (lazyDerivation { inherit derivation }).buildInputs (lazyDerivation { inherit derivation }).passthru (lazyDerivation { inherit derivation }).pythonPath. Arguments. Edit source. Noogle also knows. Aliases. lib.lazyDerivation.",
    "raw_url": "/f/lib/derivations/lazyDerivation.html",
    "excerpt": "lib.derivations.lazyDerivation. Restrict a derivation to a predictable set of attribute names, so that the returned attrset is not strict in the actual derivation, saving a lot of computation when the",
    "sub_results": []
  },
  {
    "url": "/f/lib/traceVal.html",
    "content": "lib.traceVal. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This function returns the given file set. In comparison, trace takes another argument to return. This variant is useful for tracing file sets passed as arguments to other functions. Example. toSource { root = ./.; fileset = traceVal (unions [ ./Makefile ./src ./tests/run.sh ]); } => trace: /home/user/src/myProject trace: - Makefile (regular) trace: - src (all files in directory) trace: - tests trace: - run.sh (regular) \"/nix/store/...-source\" Type. traceVal :: FileSet -> FileSet Arguments. [fileset] The file set to trace and return. This argument can also be a path, which gets implicitly coerced to a file set. Edit source. Noogle also knows. Aliases. lib.fileset.traceVal. lib.debug.traceVal.",
    "word_count": 134,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.traceVal"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 58
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 96
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 102
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.traceVal. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This function returns the given file set. In comparison, trace takes another argument to return. This variant is useful for tracing file sets passed as arguments to other functions. Example. toSource { root = ./.; fileset = traceVal (unions [ ./Makefile ./src ./tests/run.sh ]); } =&gt; trace: /home/user/src/myProject trace: - Makefile (regular) trace: - src (all files in directory) trace: - tests trace: - run.sh (regular) \"/nix/store/...-source\" Type. traceVal :: FileSet -&gt; FileSet Arguments. [fileset] The file set to trace and return. This argument can also be a path, which gets implicitly coerced to a file set. Edit source. Noogle also knows. Aliases. lib.fileset.traceVal. lib.debug.traceVal.",
    "raw_url": "/f/lib/traceVal.html",
    "excerpt": "lib.traceVal. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This",
    "sub_results": []
  },
  {
    "url": "/f/lib/ifEnable.html",
    "content": "lib.ifEnable. Edit source. Noogle also knows. Aliases. lib.misc.ifEnable.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.ifEnable"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.ifEnable. Edit source. Noogle also knows. Aliases. lib.misc.ifEnable.",
    "raw_url": "/f/lib/ifEnable.html",
    "excerpt": "lib.ifEnable. Edit source. Noogle also knows. Aliases. lib.misc.ifEnable.",
    "sub_results": []
  },
  {
    "url": "/f/lib/toDerivation.html",
    "content": "lib.toDerivation. Converts a store path to a fake derivation. Type. toDerivation :: Path -> Derivation Arguments. [path] A store path to convert to a derivation. Edit source. Noogle also knows. Aliases. lib.attrsets.toDerivation.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 15
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toDerivation. Converts a store path to a fake derivation. Type. toDerivation :: Path -&gt; Derivation Arguments. [path] A store path to convert to a derivation. Edit source. Noogle also knows. Aliases. lib.attrsets.toDerivation.",
    "raw_url": "/f/lib/toDerivation.html",
    "excerpt": "lib.toDerivation. Converts a store path to a fake derivation. Type. toDerivation :: Path -&gt; Derivation Arguments. [path] A store path to convert to a derivation. Edit source. Noogle also knows.",
    "sub_results": []
  },
  {
    "url": "/f/lib/importJSON.html",
    "content": "lib.importJSON. Reads a JSON file. Type. importJSON :: path -> any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.modules.importJSON. lib.trivial.importJSON.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.importJSON"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 5
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.importJSON. Reads a JSON file. Type. importJSON :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.modules.importJSON. lib.trivial.importJSON.",
    "raw_url": "/f/lib/importJSON.html",
    "excerpt": "lib.importJSON. Reads a JSON file. Type. importJSON :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.modules.importJSON. lib.trivial.importJSON.",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/toSource.html",
    "content": "lib.fileset.toSource. Add the local files contained in fileset to the store as a single store path rooted at root. The result is the store path as a string-like value, making it usable e.g. as the src of a derivation, or in string interpolation: stdenv.mkDerivation { src = lib.fileset.toSource { ... }; # ... } The name of the store path is always source. Example. # Import the current directory into the store # but only include files under ./src toSource { root = ./.; fileset = ./src; } => \"/nix/store/...-source\" # Import the current directory into the store # but only include ./Makefile and all files under ./src toSource { root = ./.; fileset = union ./Makefile ./src; } => \"/nix/store/...-source\" # Trying to include a file outside the root will fail toSource { root = ./.; fileset = unions [ ./Makefile ./src ../LICENSE ]; } => <error> # The root needs to point to a directory that contains all the files toSource { root = ../.; fileset = unions [ ./Makefile ./src ../LICENSE ]; } => \"/nix/store/...-source\" # The root has to be a local filesystem path toSource { root = \"/nix/store/...-source\"; fileset = ./.; } => <error> Type. toSource :: { root :: Path, fileset :: FileSet, } -> SourceLike Arguments. Edit source.",
    "word_count": 215,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.toSource"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 63
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 199
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 212
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.toSource. Add the local files contained in fileset to the store as a single store path rooted at root. The result is the store path as a string-like value, making it usable e.g. as the src of a derivation, or in string interpolation: stdenv.mkDerivation { src = lib.fileset.toSource { ... }; # ... } The name of the store path is always source. Example. # Import the current directory into the store # but only include files under ./src toSource { root = ./.; fileset = ./src; } =&gt; \"/nix/store/...-source\" # Import the current directory into the store # but only include ./Makefile and all files under ./src toSource { root = ./.; fileset = union ./Makefile ./src; } =&gt; \"/nix/store/...-source\" # Trying to include a file outside the root will fail toSource { root = ./.; fileset = unions [ ./Makefile ./src ../LICENSE ]; } =&gt; &lt;error&gt; # The root needs to point to a directory that contains all the files toSource { root = ../.; fileset = unions [ ./Makefile ./src ../LICENSE ]; } =&gt; \"/nix/store/...-source\" # The root has to be a local filesystem path toSource { root = \"/nix/store/...-source\"; fileset = ./.; } =&gt; &lt;error&gt; Type. toSource :: { root :: Path, fileset :: FileSet, } -&gt; SourceLike Arguments. Edit source.",
    "raw_url": "/f/lib/fileset/toSource.html",
    "excerpt": "lib.fileset.toSource. Add the local files contained in fileset to the store as a single store path rooted at root. The result is the store path as a string-like value, making",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/union.html",
    "content": "lib.fileset.union. The file set containing all files that are in either of two given file sets. This is the same as unions, but takes just two file sets instead of a list. See also Union (set theory). The given file sets are evaluated as lazily as possible, with the first argument being evaluated first if needed. Example. # Create a file set containing the file `Makefile` # and all files recursively in the `src` directory union ./Makefile ./src # Create a file set containing the file `Makefile` # and the LICENSE file from the parent directory union ./Makefile ../LICENSE Type. union :: FileSet -> FileSet -> FileSet Arguments. [fileset1] The first file set. This argument can also be a path, which gets implicitly coerced to a file set. [fileset2] The second file set. This argument can also be a path, which gets implicitly coerced to a file set. Edit source.",
    "word_count": 150,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.union"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 56
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 99
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 107
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.union. The file set containing all files that are in either of two given file sets. This is the same as unions, but takes just two file sets instead of a list. See also Union (set theory). The given file sets are evaluated as lazily as possible, with the first argument being evaluated first if needed. Example. # Create a file set containing the file `Makefile` # and all files recursively in the `src` directory union ./Makefile ./src # Create a file set containing the file `Makefile` # and the LICENSE file from the parent directory union ./Makefile ../LICENSE Type. union :: FileSet -&gt; FileSet -&gt; FileSet Arguments. [fileset1] The first file set. This argument can also be a path, which gets implicitly coerced to a file set. [fileset2] The second file set. This argument can also be a path, which gets implicitly coerced to a file set. Edit source.",
    "raw_url": "/f/lib/fileset/union.html",
    "excerpt": "lib.fileset.union. The file set containing all files that are in either of two given file sets. This is the same as unions, but takes just two file sets instead of",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/difference.html",
    "content": "lib.fileset.difference. The file set containing all files from the first file set that are not in the second file set. See also Difference (set theory). The given file sets are evaluated as lazily as possible, with the first argument being evaluated first if needed. Example. # Create a file set containing all files from the current directory, # except ones under ./tests difference ./. ./tests let # A set of Nix-related files nixFiles = unions [ ./default.nix ./nix ./tests/default.nix ]; in # Create a file set containing all files under ./tests, except ones in `nixFiles`, # meaning only without ./tests/default.nix difference ./tests nixFiles Type. union :: FileSet -> FileSet -> FileSet Arguments. [positive] The positive file set. The result can only contain files that are also in this file set. This argument can also be a path, which gets implicitly coerced to a file set. [negative] The negative file set. The result will never contain files that are also in this file set. This argument can also be a path, which gets implicitly coerced to a file set. Edit source.",
    "word_count": 180,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.difference"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 44
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 103
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 111
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.difference. The file set containing all files from the first file set that are not in the second file set. See also Difference (set theory). The given file sets are evaluated as lazily as possible, with the first argument being evaluated first if needed. Example. # Create a file set containing all files from the current directory, # except ones under ./tests difference ./. ./tests let # A set of Nix-related files nixFiles = unions [ ./default.nix ./nix ./tests/default.nix ]; in # Create a file set containing all files under ./tests, except ones in `nixFiles`, # meaning only without ./tests/default.nix difference ./tests nixFiles Type. union :: FileSet -&gt; FileSet -&gt; FileSet Arguments. [positive] The positive file set. The result can only contain files that are also in this file set. This argument can also be a path, which gets implicitly coerced to a file set. [negative] The negative file set. The result will never contain files that are also in this file set. This argument can also be a path, which gets implicitly coerced to a file set. Edit source.",
    "raw_url": "/f/lib/fileset/difference.html",
    "excerpt": "lib.fileset.difference. The file set containing all files from the first file set that are not in the second file set. See also Difference (set theory). The given file sets are",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/trace.html",
    "content": "lib.fileset.trace. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This function takes a final argument to return. In comparison, traceVal returns the given file set argument. This variant is useful for tracing file sets in the Nix repl. Example. trace (unions [ ./Makefile ./src ./tests/run.sh ]) null => trace: /home/user/src/myProject trace: - Makefile (regular) trace: - src (all files in directory) trace: - tests trace: - run.sh (regular) null Type. trace :: FileSet -> Any -> Any Arguments. [fileset] The file set to trace. This argument can also be a path, which gets implicitly coerced to a file set. Edit source. Noogle also knows. Aliases. lib.sources.trace.",
    "word_count": 126,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.trace"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 58
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 89
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 97
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.trace. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This function takes a final argument to return. In comparison, traceVal returns the given file set argument. This variant is useful for tracing file sets in the Nix repl. Example. trace (unions [ ./Makefile ./src ./tests/run.sh ]) null =&gt; trace: /home/user/src/myProject trace: - Makefile (regular) trace: - src (all files in directory) trace: - tests trace: - run.sh (regular) null Type. trace :: FileSet -&gt; Any -&gt; Any Arguments. [fileset] The file set to trace. This argument can also be a path, which gets implicitly coerced to a file set. Edit source. Noogle also knows. Aliases. lib.sources.trace.",
    "raw_url": "/f/lib/fileset/trace.html",
    "excerpt": "lib.fileset.trace. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/fromSource.html",
    "content": "lib.fileset.fromSource. Create a file set with the same files as a lib.sources-based value. This does not import any of the files into the store. This can be used to gradually migrate from lib.sources-based filtering to lib.fileset. A file set can be turned back into a source using toSource. :::{.note} File sets cannot represent empty directories. Turning the result of this function back into a source using toSource will therefore not preserve empty directories. ::: Example. # There's no cleanSource-like function for file sets yet, # but we can just convert cleanSource to a file set and use it that way toSource { root = ./.; fileset = fromSource (lib.sources.cleanSource ./.); } # Keeping a previous sourceByRegex (which could be migrated to `lib.fileset.unions`), # but removing a subdirectory using file set functions difference (fromSource (lib.sources.sourceByRegex ./. [ \"^README\\.md$\" # This regex includes everything in ./doc \"^doc(/.*)?$\" ]) ./doc/generated # Use cleanSource, but limit it to only include ./Makefile and files under ./src intersection (fromSource (lib.sources.cleanSource ./.)) (unions [ ./Makefile ./src ]); Type. fromSource :: SourceLike -> FileSet Arguments. [source] Edit source.",
    "word_count": 180,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.fromSource"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 74
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 170
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 176
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.fromSource. Create a file set with the same files as a lib.sources-based value. This does not import any of the files into the store. This can be used to gradually migrate from lib.sources-based filtering to lib.fileset. A file set can be turned back into a source using toSource. :::{.note} File sets cannot represent empty directories. Turning the result of this function back into a source using toSource will therefore not preserve empty directories. ::: Example. # There's no cleanSource-like function for file sets yet, # but we can just convert cleanSource to a file set and use it that way toSource { root = ./.; fileset = fromSource (lib.sources.cleanSource ./.); } # Keeping a previous sourceByRegex (which could be migrated to `lib.fileset.unions`), # but removing a subdirectory using file set functions difference (fromSource (lib.sources.sourceByRegex ./. [ \"^README\\.md$\" # This regex includes everything in ./doc \"^doc(/.*)?$\" ]) ./doc/generated # Use cleanSource, but limit it to only include ./Makefile and files under ./src intersection (fromSource (lib.sources.cleanSource ./.)) (unions [ ./Makefile ./src ]); Type. fromSource :: SourceLike -&gt; FileSet Arguments. [source] Edit source.",
    "raw_url": "/f/lib/fileset/fromSource.html",
    "excerpt": "lib.fileset.fromSource. Create a file set with the same files as a lib.sources-based value. This does not import any of the files into the store. This can be used to gradually",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/traceVal.html",
    "content": "lib.fileset.traceVal. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This function returns the given file set. In comparison, trace takes another argument to return. This variant is useful for tracing file sets passed as arguments to other functions. Example. toSource { root = ./.; fileset = traceVal (unions [ ./Makefile ./src ./tests/run.sh ]); } => trace: /home/user/src/myProject trace: - Makefile (regular) trace: - src (all files in directory) trace: - tests trace: - run.sh (regular) \"/nix/store/...-source\" Type. traceVal :: FileSet -> FileSet Arguments. [fileset] The file set to trace and return. This argument can also be a path, which gets implicitly coerced to a file set. Edit source. Noogle also knows. Aliases. lib.traceVal. lib.debug.traceVal.",
    "word_count": 134,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.traceVal"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 58
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 96
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 102
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.traceVal. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This function returns the given file set. In comparison, trace takes another argument to return. This variant is useful for tracing file sets passed as arguments to other functions. Example. toSource { root = ./.; fileset = traceVal (unions [ ./Makefile ./src ./tests/run.sh ]); } =&gt; trace: /home/user/src/myProject trace: - Makefile (regular) trace: - src (all files in directory) trace: - tests trace: - run.sh (regular) \"/nix/store/...-source\" Type. traceVal :: FileSet -&gt; FileSet Arguments. [fileset] The file set to trace and return. This argument can also be a path, which gets implicitly coerced to a file set. Edit source. Noogle also knows. Aliases. lib.traceVal. lib.debug.traceVal.",
    "raw_url": "/f/lib/fileset/traceVal.html",
    "excerpt": "lib.fileset.traceVal. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/intersection.html",
    "content": "lib.fileset.intersection. The file set containing all files that are in both of two given file sets. See also Intersection (set theory). The given file sets are evaluated as lazily as possible, with the first argument being evaluated first if needed. Example. # Limit the selected files to the ones in ./., so only ./src and ./Makefile intersection ./. (unions [ ../LICENSE ./src ./Makefile ]) Type. intersection :: FileSet -> FileSet -> FileSet Arguments. [fileset1] The first file set. This argument can also be a path, which gets implicitly coerced to a file set. [fileset2] The second file set. This argument can also be a path, which gets implicitly coerced to a file set. Edit source.",
    "word_count": 115,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.intersection"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 40
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 64
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 72
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.intersection. The file set containing all files that are in both of two given file sets. See also Intersection (set theory). The given file sets are evaluated as lazily as possible, with the first argument being evaluated first if needed. Example. # Limit the selected files to the ones in ./., so only ./src and ./Makefile intersection ./. (unions [ ../LICENSE ./src ./Makefile ]) Type. intersection :: FileSet -&gt; FileSet -&gt; FileSet Arguments. [fileset1] The first file set. This argument can also be a path, which gets implicitly coerced to a file set. [fileset2] The second file set. This argument can also be a path, which gets implicitly coerced to a file set. Edit source.",
    "raw_url": "/f/lib/fileset/intersection.html",
    "excerpt": "lib.fileset.intersection. The file set containing all files that are in both of two given file sets. See also Intersection (set theory). The given file sets are evaluated as lazily as",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/gitTracked.html",
    "content": "lib.fileset.gitTracked. Create a file set containing all Git-tracked files in a repository. This function behaves like gitTrackedWith { } - using the defaults. Example. # Include all files tracked by the Git repository in the current directory gitTracked ./. # Include only files tracked by the Git repository in the parent directory # that are also in the current directory intersection ./. (gitTracked ../.) Type. gitTracked :: Path -> FileSet Arguments. [path] The path to the working directory of a local Git repository. This directory must contain a .git file or subdirectory. Edit source.",
    "word_count": 94,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.gitTracked"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 64
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 70
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.gitTracked. Create a file set containing all Git-tracked files in a repository. This function behaves like gitTrackedWith { } - using the defaults. Example. # Include all files tracked by the Git repository in the current directory gitTracked ./. # Include only files tracked by the Git repository in the parent directory # that are also in the current directory intersection ./. (gitTracked ../.) Type. gitTracked :: Path -&gt; FileSet Arguments. [path] The path to the working directory of a local Git repository. This directory must contain a .git file or subdirectory. Edit source.",
    "raw_url": "/f/lib/fileset/gitTracked.html",
    "excerpt": "lib.fileset.gitTracked. Create a file set containing all Git-tracked files in a repository. This function behaves like gitTrackedWith { } - using the defaults. Example. # Include all files tracked by",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/gitTrackedWith.html",
    "content": "lib.fileset.gitTrackedWith. Create a file set containing all Git-tracked files in a repository. The first argument allows configuration with an attribute set, while the second argument is the path to the Git working tree. If you don't need the configuration, you can use gitTracked instead. This is equivalent to the result of unions on all files returned by git ls-files (which uses --cached by default). :::{.warning} Currently this function is based on builtins.fetchGit As such, this function causes all Git-tracked files to be unnecessarily added to the Nix store, without being re-usable by toSource. This may change in the future. ::: Example. # Include all files tracked by the Git repository in the current directory # and any submodules under it gitTracked { recurseSubmodules = true; } ./. Type. gitTrackedWith :: { recurseSubmodules :: Bool ? false } -> Path -> FileSet Arguments. [path] The path to the working directory of a local Git repository. This directory must contain a .git file or subdirectory. Edit source.",
    "word_count": 165,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.gitTrackedWith"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 100
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 127
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 141
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.gitTrackedWith. Create a file set containing all Git-tracked files in a repository. The first argument allows configuration with an attribute set, while the second argument is the path to the Git working tree. If you don't need the configuration, you can use gitTracked instead. This is equivalent to the result of unions on all files returned by git ls-files (which uses --cached by default). :::{.warning} Currently this function is based on builtins.fetchGit As such, this function causes all Git-tracked files to be unnecessarily added to the Nix store, without being re-usable by toSource. This may change in the future. ::: Example. # Include all files tracked by the Git repository in the current directory # and any submodules under it gitTracked { recurseSubmodules = true; } ./. Type. gitTrackedWith :: { recurseSubmodules :: Bool ? false } -&gt; Path -&gt; FileSet Arguments. [path] The path to the working directory of a local Git repository. This directory must contain a .git file or subdirectory. Edit source.",
    "raw_url": "/f/lib/fileset/gitTrackedWith.html",
    "excerpt": "lib.fileset.gitTrackedWith. Create a file set containing all Git-tracked files in a repository. The first argument allows configuration with an attribute set, while the second argument is the path to the",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/fileFilter.html",
    "content": "lib.fileset.fileFilter. Filter a file set to only contain files matching some predicate. Example. # Include all regular `default.nix` files in the current directory fileFilter (file: file.name == \"default.nix\") ./. # Include all non-Nix files from the current directory fileFilter (file: ! hasSuffix \".nix\" file.name) ./. # Include all files that start with a \".\" in the current directory fileFilter (file: hasPrefix \".\" file.name) ./. # Include all regular files (not symlinks or others) in the current directory fileFilter (file: file.type == \"regular\") ./. Type. fileFilter :: ({ name :: String, type :: String, ... } -> Bool) -> Path -> FileSet Arguments. [predicate] The predicate function to call on all files contained in given file set. A file is included in the resulting file set if this function returns true for it. This function is called with an attribute set containing these attributes: name (String): The name of the file. type (String, one of \"regular\", \"symlink\" or \"unknown\"): The type of the file. This matches result of calling builtins.readFileType on the file's path. Other attributes may be added in the future. [path] The path whose files to filter. Edit source.",
    "word_count": 190,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.fileFilter"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 83
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 101
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.fileFilter. Filter a file set to only contain files matching some predicate. Example. # Include all regular `default.nix` files in the current directory fileFilter (file: file.name == \"default.nix\") ./. # Include all non-Nix files from the current directory fileFilter (file: ! hasSuffix \".nix\" file.name) ./. # Include all files that start with a \".\" in the current directory fileFilter (file: hasPrefix \".\" file.name) ./. # Include all regular files (not symlinks or others) in the current directory fileFilter (file: file.type == \"regular\") ./. Type. fileFilter :: ({ name :: String, type :: String, ... } -&gt; Bool) -&gt; Path -&gt; FileSet Arguments. [predicate] The predicate function to call on all files contained in given file set. A file is included in the resulting file set if this function returns true for it. This function is called with an attribute set containing these attributes: name (String): The name of the file. type (String, one of \"regular\", \"symlink\" or \"unknown\"): The type of the file. This matches result of calling builtins.readFileType on the file's path. Other attributes may be added in the future. [path] The path whose files to filter. Edit source.",
    "raw_url": "/f/lib/fileset/fileFilter.html",
    "excerpt": "lib.fileset.fileFilter. Filter a file set to only contain files matching some predicate. Example. # Include all regular `default.nix` files in the current directory fileFilter (file: file.name == \"default.nix\") ./. #",
    "sub_results": []
  },
  {
    "url": "/f/lib/fileset/unions.html",
    "content": "lib.fileset.unions. The file set containing all files that are in any of the given file sets. This is the same as union, but takes a list of file sets instead of just two. See also Union (set theory). The given file sets are evaluated as lazily as possible, with earlier elements being evaluated first if needed. Example. # Create a file set containing selected files unions [ # Include the single file `Makefile` in the current directory # This errors if the file doesn't exist ./Makefile # Recursively include all files in the `src/code` directory # If this directory is empty this has no effect ./src/code # Include the files `run.sh` and `unit.c` from the `tests` directory ./tests/run.sh ./tests/unit.c # Include the `LICENSE` file from the parent directory ../LICENSE ] Type. unions :: [ FileSet ] -> FileSet Arguments. [filesets] A list of file sets. The elements can also be paths, which get implicitly coerced to file sets. Edit source.",
    "word_count": 160,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fileset.unions"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 56
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 130
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 138
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fileset.unions. The file set containing all files that are in any of the given file sets. This is the same as union, but takes a list of file sets instead of just two. See also Union (set theory). The given file sets are evaluated as lazily as possible, with earlier elements being evaluated first if needed. Example. # Create a file set containing selected files unions [ # Include the single file `Makefile` in the current directory # This errors if the file doesn't exist ./Makefile # Recursively include all files in the `src/code` directory # If this directory is empty this has no effect ./src/code # Include the files `run.sh` and `unit.c` from the `tests` directory ./tests/run.sh ./tests/unit.c # Include the `LICENSE` file from the parent directory ../LICENSE ] Type. unions :: [ FileSet ] -&gt; FileSet Arguments. [filesets] A list of file sets. The elements can also be paths, which get implicitly coerced to file sets. Edit source.",
    "raw_url": "/f/lib/fileset/unions.html",
    "excerpt": "lib.fileset.unions. The file set containing all files that are in any of the given file sets. This is the same as union, but takes a list of file sets instead",
    "sub_results": []
  },
  {
    "url": "/f/lib/pushDownProperties.html",
    "content": "lib.pushDownProperties. Given a config set, expand mkMerge properties, and push down the other properties into the children. The result is a list of config sets that do not have properties at top-level. For example, mkMerge [ { boot = set1; } (mkIf cond { boot = set2; services = set3; }) ] is transformed into [ { boot = set1; } { boot = mkIf cond set2; services = mkIf cond set3; } ]. This transform is the critical step that allows mkIf conditions to refer to the full configuration without creating an infinite recursion. Arguments. [cfg] Edit source. Noogle also knows. Aliases. lib.modules.pushDownProperties.",
    "word_count": 104,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.pushDownProperties"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 95
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.pushDownProperties. Given a config set, expand mkMerge properties, and push down the other properties into the children. The result is a list of config sets that do not have properties at top-level. For example, mkMerge [ { boot = set1; } (mkIf cond { boot = set2; services = set3; }) ] is transformed into [ { boot = set1; } { boot = mkIf cond set2; services = mkIf cond set3; } ]. This transform is the critical step that allows mkIf conditions to refer to the full configuration without creating an infinite recursion. Arguments. [cfg] Edit source. Noogle also knows. Aliases. lib.modules.pushDownProperties.",
    "raw_url": "/f/lib/pushDownProperties.html",
    "excerpt": "lib.pushDownProperties. Given a config set, expand mkMerge properties, and push down the other properties into the children. The result is a list of config sets that do not have properties",
    "sub_results": []
  },
  {
    "url": "/f/lib/partition.html",
    "content": "lib.partition Primop. Takes 2 arguments. pred, list. Splits the elements of a list in two lists, right and wrong, depending on the evaluation of a predicate. Example. partition (x: x > 2) [ 5 1 2 3 4 ] => { right = [ 5 3 4 ]; wrong = [ 1 2 ]; } Type. (a -> bool) -> [a] -> { right :: [a]; wrong :: [a]; } Edit source. Noogle also knows. Aliases. builtins.partition. lib.lists.partition.",
    "word_count": 78,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.partition Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.partition Primop. Takes 2 arguments. pred, list. Splits the elements of a list in two lists, right and wrong, depending on the evaluation of a predicate. Example. partition (x: x &gt; 2) [ 5 1 2 3 4 ] =&gt; { right = [ 5 3 4 ]; wrong = [ 1 2 ]; } Type. (a -&gt; bool) -&gt; [a] -&gt; { right :: [a]; wrong :: [a]; } Edit source. Noogle also knows. Aliases. builtins.partition. lib.lists.partition.",
    "raw_url": "/f/lib/partition.html",
    "excerpt": "lib.partition Primop. Takes 2 arguments. pred, list. Splits the elements of a list in two lists, right and wrong, depending on the evaluation of a predicate. Example. partition (x: x",
    "sub_results": []
  },
  {
    "url": "/f/lib/defaultMergeArg.html",
    "content": "lib.defaultMergeArg. Edit source. Noogle also knows. Aliases. lib.misc.defaultMergeArg.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.defaultMergeArg"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.defaultMergeArg. Edit source. Noogle also knows. Aliases. lib.misc.defaultMergeArg.",
    "raw_url": "/f/lib/defaultMergeArg.html",
    "excerpt": "lib.defaultMergeArg. Edit source. Noogle also knows. Aliases. lib.misc.defaultMergeArg.",
    "sub_results": []
  },
  {
    "url": "/f/lib/toShellVars.html",
    "content": "lib.toShellVars. Translate an attribute set into corresponding shell variable declarations using toShellVar. Example. let foo = \"value\"; bar = foo; in '' ${toShellVars { inherit foo bar; }} [[ \"$foo\" == \"$bar\" ]] '' Type. attrsOf (string | listOf string | attrsOf string) -> string Arguments. [vars] Edit source. Noogle also knows. Aliases. lib.strings.toShellVars.",
    "word_count": 54,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toShellVars"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 45
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toShellVars. Translate an attribute set into corresponding shell variable declarations using toShellVar. Example. let foo = \"value\"; bar = foo; in '' ${toShellVars { inherit foo bar; }} [[ \"$foo\" == \"$bar\" ]] '' Type. attrsOf (string | listOf string | attrsOf string) -&gt; string Arguments. [vars] Edit source. Noogle also knows. Aliases. lib.strings.toShellVars.",
    "raw_url": "/f/lib/toShellVars.html",
    "excerpt": "lib.toShellVars. Translate an attribute set into corresponding shell variable declarations using toShellVar. Example. let foo = \"value\"; bar = foo; in '' ${toShellVars { inherit foo bar; }} [[ \"$foo\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/range.html",
    "content": "lib.range. Return a list of integers from first up to and including last. Example. range 2 4 => [ 2 3 4 ] range 3 2 => [ ] Type. range :: int -> int -> [int] Arguments. [first] First integer in the range. [last] Last integer in the range. Edit source. Noogle also knows. Aliases. lib.lists.range.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.range"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 29
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 37
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.range. Return a list of integers from first up to and including last. Example. range 2 4 =&gt; [ 2 3 4 ] range 3 2 =&gt; [ ] Type. range :: int -&gt; int -&gt; [int] Arguments. [first] First integer in the range. [last] Last integer in the range. Edit source. Noogle also knows. Aliases. lib.lists.range.",
    "raw_url": "/f/lib/range.html",
    "excerpt": "lib.range. Return a list of integers from first up to and including last. Example. range 2 4 =&gt; [ 2 3 4 ] range 3 2 =&gt; [ ] Type.",
    "sub_results": []
  },
  {
    "url": "/f/lib/collect.html",
    "content": "lib.collect. Recursively collect sets that verify a given predicate named pred from the set attrs. The recursion is stopped when the predicate is verified. Example. collect isList { a = { b = [\"b\"]; }; c = [1]; } => [[\"b\"] [1]] collect (x: x ? outPath) { a = { outPath = \"a/\"; }; b = { outPath = \"b/\"; }; } => [{ outPath = \"a/\"; } { outPath = \"b/\"; }] Type. collect :: (AttrSet -> Bool) -> AttrSet -> [x] Arguments. [pred] Given an attribute's value, determine if recursion should stop. [attrs] The attribute set to recursively collect. Edit source. Noogle also knows. Aliases. lib.attrsets.collect.",
    "word_count": 109,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.collect"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 74
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 84
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.collect. Recursively collect sets that verify a given predicate named pred from the set attrs. The recursion is stopped when the predicate is verified. Example. collect isList { a = { b = [\"b\"]; }; c = [1]; } =&gt; [[\"b\"] [1]] collect (x: x ? outPath) { a = { outPath = \"a/\"; }; b = { outPath = \"b/\"; }; } =&gt; [{ outPath = \"a/\"; } { outPath = \"b/\"; }] Type. collect :: (AttrSet -&gt; Bool) -&gt; AttrSet -&gt; [x] Arguments. [pred] Given an attribute's value, determine if recursion should stop. [attrs] The attribute set to recursively collect. Edit source. Noogle also knows. Aliases. lib.attrsets.collect.",
    "raw_url": "/f/lib/collect.html",
    "excerpt": "lib.collect. Recursively collect sets that verify a given predicate named pred from the set attrs. The recursion is stopped when the predicate is verified. Example. collect isList { a =",
    "sub_results": []
  },
  {
    "url": "/f/lib/dontDistribute.html",
    "content": "lib.dontDistribute. Disable Hydra builds of given derivation. Arguments. [drv] Edit source. Noogle also knows. Aliases. lib.meta.dontDistribute. pkgs.haskell.lib.dontDistribute.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.dontDistribute"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 7
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.dontDistribute. Disable Hydra builds of given derivation. Arguments. [drv] Edit source. Noogle also knows. Aliases. lib.meta.dontDistribute. pkgs.haskell.lib.dontDistribute.",
    "raw_url": "/f/lib/dontDistribute.html",
    "excerpt": "lib.dontDistribute. Disable Hydra builds of given derivation. Arguments. [drv] Edit source. Noogle also knows. Aliases. lib.meta.dontDistribute. pkgs.haskell.lib.dontDistribute.",
    "sub_results": []
  },
  {
    "url": "/f/lib/pathIsDirectory.html",
    "content": "lib.pathIsDirectory. Whether a path exists and is a directory. Example. pathIsDirectory /. => true pathIsDirectory /this/does/not/exist => false pathIsDirectory /some/file.nix => false Type. pathIsDirectory :: Path -> Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.filesystem.pathIsDirectory. lib.sources.pathIsDirectory.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.pathIsDirectory"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 28
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.pathIsDirectory. Whether a path exists and is a directory. Example. pathIsDirectory /. =&gt; true pathIsDirectory /this/does/not/exist =&gt; false pathIsDirectory /some/file.nix =&gt; false Type. pathIsDirectory :: Path -&gt; Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.filesystem.pathIsDirectory. lib.sources.pathIsDirectory.",
    "raw_url": "/f/lib/pathIsDirectory.html",
    "excerpt": "lib.pathIsDirectory. Whether a path exists and is a directory. Example. pathIsDirectory /. =&gt; true pathIsDirectory /this/does/not/exist =&gt; false pathIsDirectory /some/file.nix =&gt; false Type. pathIsDirectory :: Path -&gt; Bool Arguments. [path]",
    "sub_results": []
  },
  {
    "url": "/f/lib/getAttrs.html",
    "content": "lib.getAttrs. Given a set of attribute names, return the set of the corresponding attributes from the given set. Example. getAttrs [ \"a\" \"b\" ] { a = 1; b = 2; c = 3; } => { a = 1; b = 2; } Type. getAttrs :: [String] -> AttrSet -> AttrSet Arguments. [names] A list of attribute names to get out of set. [attrs] The set to get the named attributes from. Edit source. Noogle also knows. Aliases. lib.attrsets.getAttrs.",
    "word_count": 80,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 44
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 52
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getAttrs. Given a set of attribute names, return the set of the corresponding attributes from the given set. Example. getAttrs [ \"a\" \"b\" ] { a = 1; b = 2; c = 3; } =&gt; { a = 1; b = 2; } Type. getAttrs :: [String] -&gt; AttrSet -&gt; AttrSet Arguments. [names] A list of attribute names to get out of set. [attrs] The set to get the named attributes from. Edit source. Noogle also knows. Aliases. lib.attrsets.getAttrs.",
    "raw_url": "/f/lib/getAttrs.html",
    "excerpt": "lib.getAttrs. Given a set of attribute names, return the set of the corresponding attributes from the given set. Example. getAttrs [ \"a\" \"b\" ] { a = 1; b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/customisation/extendDerivation.html",
    "content": "lib.customisation.extendDerivation. Add attributes to each output of a derivation without changing the derivation itself and check a given condition when evaluating. Type. extendDerivation :: Bool -> Any -> Derivation -> Derivation Arguments. [condition] [passthru] [drv] Edit source. Noogle also knows. Aliases. lib.extendDerivation.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.customisation.extendDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 31
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.customisation.extendDerivation. Add attributes to each output of a derivation without changing the derivation itself and check a given condition when evaluating. Type. extendDerivation :: Bool -&gt; Any -&gt; Derivation -&gt; Derivation Arguments. [condition] [passthru] [drv] Edit source. Noogle also knows. Aliases. lib.extendDerivation.",
    "raw_url": "/f/lib/customisation/extendDerivation.html",
    "excerpt": "lib.customisation.extendDerivation. Add attributes to each output of a derivation without changing the derivation itself and check a given condition when evaluating. Type. extendDerivation :: Bool -&gt; Any -&gt; Derivation -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/customisation/callPackageWith.html",
    "content": "lib.customisation.callPackageWith. Call the package function in the file fn with the required arguments automatically. The function is called with the arguments args, but any missing arguments are obtained from autoArgs. This function is intended to be partially parameterised, e.g., callPackage = callPackageWith pkgs; pkgs = { libfoo = callPackage ./foo.nix { }; libbar = callPackage ./bar.nix { }; }; If the libbar function expects an argument named libfoo, it is automatically passed as an argument. Overrides or missing arguments can be supplied in args, e.g. libbar = callPackage ./bar.nix { libfoo = null; enableX11 = true; }; Type. callPackageWith :: AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a Arguments. [autoArgs] [fn] [args] Edit source. Noogle also knows. Aliases. lib.callPackageWith.",
    "word_count": 122,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.customisation.callPackageWith"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 97
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 111
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.customisation.callPackageWith. Call the package function in the file fn with the required arguments automatically. The function is called with the arguments args, but any missing arguments are obtained from autoArgs. This function is intended to be partially parameterised, e.g., callPackage = callPackageWith pkgs; pkgs = { libfoo = callPackage ./foo.nix { }; libbar = callPackage ./bar.nix { }; }; If the libbar function expects an argument named libfoo, it is automatically passed as an argument. Overrides or missing arguments can be supplied in args, e.g. libbar = callPackage ./bar.nix { libfoo = null; enableX11 = true; }; Type. callPackageWith :: AttrSet -&gt; ((AttrSet -&gt; a) | Path) -&gt; AttrSet -&gt; a Arguments. [autoArgs] [fn] [args] Edit source. Noogle also knows. Aliases. lib.callPackageWith.",
    "raw_url": "/f/lib/customisation/callPackageWith.html",
    "excerpt": "lib.customisation.callPackageWith. Call the package function in the file fn with the required arguments automatically. The function is called with the arguments args, but any missing arguments are obtained from autoArgs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/customisation/makeScopeWithSplicing.html",
    "content": "lib.customisation.makeScopeWithSplicing. backward compatibility with old uncurried form; deprecated. Arguments. [splicePackages] [newScope] [otherSplices] [keep] [extra] [f] Edit source. Noogle also knows. Aliases. lib.makeScopeWithSplicing. pkgs.makeScopeWithSplicing.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.customisation.makeScopeWithSplicing"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.customisation.makeScopeWithSplicing. backward compatibility with old uncurried form; deprecated. Arguments. [splicePackages] [newScope] [otherSplices] [keep] [extra] [f] Edit source. Noogle also knows. Aliases. lib.makeScopeWithSplicing. pkgs.makeScopeWithSplicing.",
    "raw_url": "/f/lib/customisation/makeScopeWithSplicing.html",
    "excerpt": "lib.customisation.makeScopeWithSplicing. backward compatibility with old uncurried form; deprecated. Arguments. [splicePackages] [newScope] [otherSplices] [keep] [extra] [f] Edit source. Noogle also knows. Aliases. lib.makeScopeWithSplicing. pkgs.makeScopeWithSplicing.",
    "sub_results": []
  },
  {
    "url": "/f/lib/customisation/hydraJob.html",
    "content": "lib.customisation.hydraJob. Strip a derivation of all non-essential attributes, returning only those needed by hydra-eval-jobs. Also strictly evaluate the result to ensure that there are no thunks kept alive to prevent garbage collection. Type. hydraJob :: (Derivation | Null) -> (Derivation | Null) Arguments. [drv] Edit source. Noogle also knows. Aliases. lib.hydraJob.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.customisation.hydraJob"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.customisation.hydraJob. Strip a derivation of all non-essential attributes, returning only those needed by hydra-eval-jobs. Also strictly evaluate the result to ensure that there are no thunks kept alive to prevent garbage collection. Type. hydraJob :: (Derivation | Null) -&gt; (Derivation | Null) Arguments. [drv] Edit source. Noogle also knows. Aliases. lib.hydraJob.",
    "raw_url": "/f/lib/customisation/hydraJob.html",
    "excerpt": "lib.customisation.hydraJob. Strip a derivation of all non-essential attributes, returning only those needed by hydra-eval-jobs. Also strictly evaluate the result to ensure that there are no thunks kept alive to prevent",
    "sub_results": []
  },
  {
    "url": "/f/lib/customisation/callPackagesWith.html",
    "content": "lib.customisation.callPackagesWith. Like callPackage, but for a function that returns an attribute set of derivations. The override function is added to the individual attributes. Type. callPackagesWith :: AttrSet -> ((AttrSet -> AttrSet) | Path) -> AttrSet -> AttrSet Arguments. [autoArgs] [fn] [args] Edit source. Noogle also knows. Aliases. lib.callPackagesWith.",
    "word_count": 48,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.customisation.callPackagesWith"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 37
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.customisation.callPackagesWith. Like callPackage, but for a function that returns an attribute set of derivations. The override function is added to the individual attributes. Type. callPackagesWith :: AttrSet -&gt; ((AttrSet -&gt; AttrSet) | Path) -&gt; AttrSet -&gt; AttrSet Arguments. [autoArgs] [fn] [args] Edit source. Noogle also knows. Aliases. lib.callPackagesWith.",
    "raw_url": "/f/lib/customisation/callPackagesWith.html",
    "excerpt": "lib.customisation.callPackagesWith. Like callPackage, but for a function that returns an attribute set of derivations. The override function is added to the individual attributes. Type. callPackagesWith :: AttrSet -&gt; ((AttrSet -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/customisation/makeScopeWithSplicing'.html",
    "content": "lib.customisation.makeScopeWithSplicing' (Prime). Like makeScope, but aims to support cross compilation. It's still ugly, but hopefully it helps a little bit. Type. makeScopeWithSplicing' :: { splicePackages :: Splice -> AttrSet , newScope :: AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a } -> { otherSplices :: Splice, keep :: AttrSet -> AttrSet, extra :: AttrSet -> AttrSet } -> AttrSet Splice :: { pkgsBuildBuild :: AttrSet , pkgsBuildHost :: AttrSet , pkgsBuildTarget :: AttrSet , pkgsHostHost :: AttrSet , pkgsHostTarget :: AttrSet , pkgsTargetTarget :: AttrSet } Arguments. Edit source. Noogle also knows. Aliases. lib.makeScopeWithSplicing' pkgs.makeScopeWithSplicing'",
    "word_count": 98,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.customisation.makeScopeWithSplicing' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 89
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.customisation.makeScopeWithSplicing' (Prime). Like makeScope, but aims to support cross compilation. It's still ugly, but hopefully it helps a little bit. Type. makeScopeWithSplicing' :: { splicePackages :: Splice -&gt; AttrSet , newScope :: AttrSet -&gt; ((AttrSet -&gt; a) | Path) -&gt; AttrSet -&gt; a } -&gt; { otherSplices :: Splice, keep :: AttrSet -&gt; AttrSet, extra :: AttrSet -&gt; AttrSet } -&gt; AttrSet Splice :: { pkgsBuildBuild :: AttrSet , pkgsBuildHost :: AttrSet , pkgsBuildTarget :: AttrSet , pkgsHostHost :: AttrSet , pkgsHostTarget :: AttrSet , pkgsTargetTarget :: AttrSet } Arguments. Edit source. Noogle also knows. Aliases. lib.makeScopeWithSplicing' pkgs.makeScopeWithSplicing'",
    "raw_url": "/f/lib/customisation/makeScopeWithSplicing'.html",
    "excerpt": "lib.customisation.makeScopeWithSplicing' (Prime). Like makeScope, but aims to support cross compilation. It's still ugly, but hopefully it helps a little bit. Type. makeScopeWithSplicing' :: { splicePackages :: Splice -&gt; AttrSet ,",
    "sub_results": []
  },
  {
    "url": "/f/lib/customisation/overrideDerivation.html",
    "content": "lib.customisation.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -> ( Derivation -> AttrSet ) -> Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. pkgs.dockerTools.overrideDerivation. lib.overrideDerivation. pkgs.pythonPackages.overrideDerivation. pkgs.stdenv.overrideDerivation. pkgs.writers.overrideDerivation.",
    "word_count": 208,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.customisation.overrideDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 157
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 182
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 194
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.customisation.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -&gt; ( Derivation -&gt; AttrSet ) -&gt; Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. pkgs.dockerTools.overrideDerivation. lib.overrideDerivation. pkgs.pythonPackages.overrideDerivation. pkgs.stdenv.overrideDerivation. pkgs.writers.overrideDerivation.",
    "raw_url": "/f/lib/customisation/overrideDerivation.html",
    "excerpt": "lib.customisation.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original",
    "sub_results": []
  },
  {
    "url": "/f/lib/customisation/makeOverridable.html",
    "content": "lib.customisation.makeOverridable. makeOverridable takes a function from attribute set to attribute set and injects override attribute which can be used to override arguments of the function. Please refer to documentation on <pkg>.overrideDerivation to learn about overrideDerivation and caveats related to its use. Example. nix-repl> x = {a, b}: { result = a + b; } nix-repl> y = lib.makeOverridable x { a = 1; b = 2; } nix-repl> y { override = «lambda»; overrideDerivation = «lambda»; result = 3; } nix-repl> y.override { a = 10; } { override = «lambda»; overrideDerivation = «lambda»; result = 12; } Type. makeOverridable :: (AttrSet -> a) -> AttrSet -> a Arguments. [f] Edit source. Noogle also knows. Aliases. lib.makeOverridable. pkgs.makeOverridable.",
    "word_count": 118,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.customisation.makeOverridable"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 41
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 98
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 108
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.customisation.makeOverridable. makeOverridable takes a function from attribute set to attribute set and injects override attribute which can be used to override arguments of the function. Please refer to documentation on &lt;pkg&gt;.overrideDerivation to learn about overrideDerivation and caveats related to its use. Example. nix-repl&gt; x = {a, b}: { result = a + b; } nix-repl&gt; y = lib.makeOverridable x { a = 1; b = 2; } nix-repl&gt; y { override = «lambda»; overrideDerivation = «lambda»; result = 3; } nix-repl&gt; y.override { a = 10; } { override = «lambda»; overrideDerivation = «lambda»; result = 12; } Type. makeOverridable :: (AttrSet -&gt; a) -&gt; AttrSet -&gt; a Arguments. [f] Edit source. Noogle also knows. Aliases. lib.makeOverridable. pkgs.makeOverridable.",
    "raw_url": "/f/lib/customisation/makeOverridable.html",
    "excerpt": "lib.customisation.makeOverridable. makeOverridable takes a function from attribute set to attribute set and injects override attribute which can be used to override arguments of the function. Please refer to documentation on",
    "sub_results": []
  },
  {
    "url": "/f/lib/customisation/makeScope.html",
    "content": "lib.customisation.makeScope. Make a set of packages with a common scope. All packages called with the provided callPackage will be evaluated with the same arguments. Any package in the set may depend on any other. The overrideScope' function allows subsequent modification of the package set in a consistent way, i.e. all packages in the set will be called with the overridden packages. The package sets may be hierarchical: the packages in the set are called with the scope provided by newScope and the set provides a newScope attribute which can form the parent scope for later package sets. Type. makeScope :: (AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a) -> (AttrSet -> AttrSet) -> AttrSet Arguments. [newScope] [f] Edit source. Noogle also knows. Aliases. lib.makeScope.",
    "word_count": 127,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.customisation.makeScope"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 97
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 117
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.customisation.makeScope. Make a set of packages with a common scope. All packages called with the provided callPackage will be evaluated with the same arguments. Any package in the set may depend on any other. The overrideScope' function allows subsequent modification of the package set in a consistent way, i.e. all packages in the set will be called with the overridden packages. The package sets may be hierarchical: the packages in the set are called with the scope provided by newScope and the set provides a newScope attribute which can form the parent scope for later package sets. Type. makeScope :: (AttrSet -&gt; ((AttrSet -&gt; a) | Path) -&gt; AttrSet -&gt; a) -&gt; (AttrSet -&gt; AttrSet) -&gt; AttrSet Arguments. [newScope] [f] Edit source. Noogle also knows. Aliases. lib.makeScope.",
    "raw_url": "/f/lib/customisation/makeScope.html",
    "excerpt": "lib.customisation.makeScope. Make a set of packages with a common scope. All packages called with the provided callPackage will be evaluated with the same arguments. Any package in the set may",
    "sub_results": []
  },
  {
    "url": "/f/lib/warn.html",
    "content": "lib.warn. Print a warning before returning the second argument. This function behaves like builtins.trace, but requires a string message and formats it as a warning, including the warning: prefix. To get a call stack trace and abort evaluation, set the environment variable NIX_ABORT_ON_WARN=true and set the Nix options --option pure-eval false --show-trace. Type. string -> a -> a Edit source. Noogle also knows. Aliases. lib.trivial.warn.",
    "word_count": 65,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.warn"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 52
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.warn. Print a warning before returning the second argument. This function behaves like builtins.trace, but requires a string message and formats it as a warning, including the warning: prefix. To get a call stack trace and abort evaluation, set the environment variable NIX_ABORT_ON_WARN=true and set the Nix options --option pure-eval false --show-trace. Type. string -&gt; a -&gt; a Edit source. Noogle also knows. Aliases. lib.trivial.warn.",
    "raw_url": "/f/lib/warn.html",
    "excerpt": "lib.warn. Print a warning before returning the second argument. This function behaves like builtins.trace, but requires a string message and formats it as a warning, including the warning: prefix. To",
    "sub_results": []
  },
  {
    "url": "/f/lib/composeManyExtensions.html",
    "content": "lib.composeManyExtensions. Compose several extending functions of the type expected by 'extends' into one where changes made in preceding functions are made available to subsequent ones. composeManyExtensions : [packageSet -> packageSet -> packageSet] -> packageSet -> packageSet -> packageSet ^final ^prev ^overrides ^final ^prev ^overrides Edit source. Noogle also knows. Aliases. lib.fixedPoints.composeManyExtensions.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.composeManyExtensions"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.composeManyExtensions. Compose several extending functions of the type expected by 'extends' into one where changes made in preceding functions are made available to subsequent ones. composeManyExtensions : [packageSet -&gt; packageSet -&gt; packageSet] -&gt; packageSet -&gt; packageSet -&gt; packageSet ^final ^prev ^overrides ^final ^prev ^overrides Edit source. Noogle also knows. Aliases. lib.fixedPoints.composeManyExtensions.",
    "raw_url": "/f/lib/composeManyExtensions.html",
    "excerpt": "lib.composeManyExtensions. Compose several extending functions of the type expected by 'extends' into one where changes made in preceding functions are made available to subsequent ones. composeManyExtensions : [packageSet -&gt; packageSet",
    "sub_results": []
  },
  {
    "url": "/f/lib/foldArgs.html",
    "content": "lib.foldArgs. Edit source. Noogle also knows. Aliases. lib.misc.foldArgs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.foldArgs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.foldArgs. Edit source. Noogle also knows. Aliases. lib.misc.foldArgs.",
    "raw_url": "/f/lib/foldArgs.html",
    "excerpt": "lib.foldArgs. Edit source. Noogle also knows. Aliases. lib.misc.foldArgs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/asserts/assertMsg.html",
    "content": "lib.asserts.assertMsg. Throw if pred is false, else return pred. Intended to be used to augment asserts with helpful error messages. Example. assertMsg false \"nope\" stderr> error: nope assert assertMsg (\"foo\" == \"bar\") \"foo is not bar, silly\"; \"\" stderr> error: foo is not bar, silly Type. assertMsg :: Bool -> String -> Bool Arguments. [pred] Predicate that needs to succeed, otherwise msg is thrown. [msg] Message to throw in case pred fails. Edit source. Noogle also knows. Aliases. lib.assertMsg.",
    "word_count": 79,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.asserts.assertMsg"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 45
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 53
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.asserts.assertMsg. Throw if pred is false, else return pred. Intended to be used to augment asserts with helpful error messages. Example. assertMsg false \"nope\" stderr&gt; error: nope assert assertMsg (\"foo\" == \"bar\") \"foo is not bar, silly\"; \"\" stderr&gt; error: foo is not bar, silly Type. assertMsg :: Bool -&gt; String -&gt; Bool Arguments. [pred] Predicate that needs to succeed, otherwise msg is thrown. [msg] Message to throw in case pred fails. Edit source. Noogle also knows. Aliases. lib.assertMsg.",
    "raw_url": "/f/lib/asserts/assertMsg.html",
    "excerpt": "lib.asserts.assertMsg. Throw if pred is false, else return pred. Intended to be used to augment asserts with helpful error messages. Example. assertMsg false \"nope\" stderr&gt; error: nope assert assertMsg (\"foo\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/asserts/assertOneOf.html",
    "content": "lib.asserts.assertOneOf. Specialized assertMsg for checking if val is one of the elements of the list xs. Useful for checking enums. Example. let sslLibrary = \"libressl\"; in assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"bearssl\" ] stderr> error: sslLibrary must be one of [ stderr> \"openssl\" stderr> \"bearssl\" stderr> ], but is: \"libressl\" Type. assertOneOf :: String -> ComparableVal -> List ComparableVal -> Bool Arguments. [name] The name of the variable the user entered val into, for inclusion in the error message. [val] The value of what the user provided, to be compared against the values in xs. [xs] The list of valid values. Edit source. Noogle also knows. Aliases. lib.assertOneOf.",
    "word_count": 108,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.asserts.assertOneOf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 50
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 61
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.asserts.assertOneOf. Specialized assertMsg for checking if val is one of the elements of the list xs. Useful for checking enums. Example. let sslLibrary = \"libressl\"; in assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"bearssl\" ] stderr&gt; error: sslLibrary must be one of [ stderr&gt; \"openssl\" stderr&gt; \"bearssl\" stderr&gt; ], but is: \"libressl\" Type. assertOneOf :: String -&gt; ComparableVal -&gt; List ComparableVal -&gt; Bool Arguments. [name] The name of the variable the user entered val into, for inclusion in the error message. [val] The value of what the user provided, to be compared against the values in xs. [xs] The list of valid values. Edit source. Noogle also knows. Aliases. lib.assertOneOf.",
    "raw_url": "/f/lib/asserts/assertOneOf.html",
    "excerpt": "lib.asserts.assertOneOf. Specialized assertMsg for checking if val is one of the elements of the list xs. Useful for checking enums. Example. let sslLibrary = \"libressl\"; in assertOneOf \"sslLibrary\" sslLibrary [",
    "sub_results": []
  },
  {
    "url": "/f/lib/asserts/assertEachOneOf.html",
    "content": "lib.asserts.assertEachOneOf. Specialized assertMsg for checking if every one of vals is one of the elements of the list xs. Useful for checking lists of supported attributes. Example. let sslLibraries = [ \"libressl\" \"bearssl\" ]; in assertEachOneOf \"sslLibraries\" sslLibraries [ \"openssl\" \"bearssl\" ] stderr> error: each element in sslLibraries must be one of [ stderr> \"openssl\" stderr> \"bearssl\" stderr> ], but is: [ stderr> \"libressl\" stderr> \"bearssl\" stderr> ] Type. assertEachOneOf :: String -> List ComparableVal -> List ComparableVal -> Bool Arguments. [name] The name of the variable the user entered val into, for inclusion in the error message. [vals] The list of values of what the user provided, to be compared against the values in xs. [xs] The list of valid values. Edit source.",
    "word_count": 124,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.asserts.assertEachOneOf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 68
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 80
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.asserts.assertEachOneOf. Specialized assertMsg for checking if every one of vals is one of the elements of the list xs. Useful for checking lists of supported attributes. Example. let sslLibraries = [ \"libressl\" \"bearssl\" ]; in assertEachOneOf \"sslLibraries\" sslLibraries [ \"openssl\" \"bearssl\" ] stderr&gt; error: each element in sslLibraries must be one of [ stderr&gt; \"openssl\" stderr&gt; \"bearssl\" stderr&gt; ], but is: [ stderr&gt; \"libressl\" stderr&gt; \"bearssl\" stderr&gt; ] Type. assertEachOneOf :: String -&gt; List ComparableVal -&gt; List ComparableVal -&gt; Bool Arguments. [name] The name of the variable the user entered val into, for inclusion in the error message. [vals] The list of values of what the user provided, to be compared against the values in xs. [xs] The list of valid values. Edit source.",
    "raw_url": "/f/lib/asserts/assertEachOneOf.html",
    "excerpt": "lib.asserts.assertEachOneOf. Specialized assertMsg for checking if every one of vals is one of the elements of the list xs. Useful for checking lists of supported attributes. Example. let sslLibraries =",
    "sub_results": []
  },
  {
    "url": "/f/lib/genericClosure.html",
    "content": "lib.genericClosure Primop. Takes 1 arguments. attrset. Takes an attrset with the following attributes: startSet [ Item ] A list of start items. Each item must be an attrset containing a key. The key must be comparable. operator Item -> [ Item ] A function. returns a list of attrsets. GenericClosure starts with the startSet and recursively applying the operator function to each item. The attrsets in the startSet and the attrsets produced by operator must contain a value named key which is comparable. The result is produced by calling operator for each item with a value for key that has not been called yet including newly produced items. The function terminates when no new items are produced. The resulting list of attrsets contains only attrsets with a unique key. For example, builtins.genericClosure { startSet = [ {key = 5;} ]; operator = item: [{ key = if (item.key / 2 ) * 2 == item.key then item.key / 2 else 3 * item.key + 1; }]; } evaluates to. [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ] Noogle also knows. Aliases. builtins.genericClosure. lib.trivial.genericClosure.",
    "word_count": 207,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.genericClosure Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.genericClosure Primop. Takes 1 arguments. attrset. Takes an attrset with the following attributes: startSet [ Item ] A list of start items. Each item must be an attrset containing a key. The key must be comparable. operator Item -&gt; [ Item ] A function. returns a list of attrsets. GenericClosure starts with the startSet and recursively applying the operator function to each item. The attrsets in the startSet and the attrsets produced by operator must contain a value named key which is comparable. The result is produced by calling operator for each item with a value for key that has not been called yet including newly produced items. The function terminates when no new items are produced. The resulting list of attrsets contains only attrsets with a unique key. For example, builtins.genericClosure { startSet = [ {key = 5;} ]; operator = item: [{ key = if (item.key / 2 ) * 2 == item.key then item.key / 2 else 3 * item.key + 1; }]; } evaluates to. [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ] Noogle also knows. Aliases. builtins.genericClosure. lib.trivial.genericClosure.",
    "raw_url": "/f/lib/genericClosure.html",
    "excerpt": "lib.genericClosure Primop. Takes 1 arguments. attrset. Takes an attrset with the following attributes: startSet [ Item ] A list of start items. Each item must be an attrset containing a",
    "sub_results": []
  },
  {
    "url": "/f/lib/isValidPosixName.html",
    "content": "lib.isValidPosixName. Test whether the given name is a valid POSIX shell variable name. Example. isValidPosixName \"foo_bar000\" => true isValidPosixName \"0-bad.jpg\" => false Type. string -> bool Arguments. [name] Edit source. Noogle also knows. Aliases. lib.strings.isValidPosixName.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isValidPosixName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isValidPosixName. Test whether the given name is a valid POSIX shell variable name. Example. isValidPosixName \"foo_bar000\" =&gt; true isValidPosixName \"0-bad.jpg\" =&gt; false Type. string -&gt; bool Arguments. [name] Edit source. Noogle also knows. Aliases. lib.strings.isValidPosixName.",
    "raw_url": "/f/lib/isValidPosixName.html",
    "excerpt": "lib.isValidPosixName. Test whether the given name is a valid POSIX shell variable name. Example. isValidPosixName \"foo_bar000\" =&gt; true isValidPosixName \"0-bad.jpg\" =&gt; false Type. string -&gt; bool Arguments. [name] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lazyDerivation.html",
    "content": "lib.lazyDerivation. Restrict a derivation to a predictable set of attribute names, so that the returned attrset is not strict in the actual derivation, saving a lot of computation when the derivation is non-trivial. This is useful in situations where a derivation might only be used for its passthru attributes, improving evaluation performance. The returned attribute set is lazy in derivation. Specifically, this means that the derivation will not be evaluated in at least the situations below. For illustration and/or testing, we define derivation such that its evaluation is very noticeable. let derivation = throw \"This won't be evaluated.\"; In the following expressions, derivation will not be evaluated: (lazyDerivation { inherit derivation; }).type attrNames (lazyDerivation { inherit derivation; }) (lazyDerivation { inherit derivation; } // { foo = true; }).foo (lazyDerivation { inherit derivation; meta.foo = true; }).meta In these expressions, derivation will be evaluated: \"${lazyDerivation { inherit derivation }}\" (lazyDerivation { inherit derivation }).outPath (lazyDerivation { inherit derivation }).meta And the following expressions are not valid, because the refer to implementation details and/or attributes that may not be present on some derivations: (lazyDerivation { inherit derivation }).buildInputs (lazyDerivation { inherit derivation }).passthru (lazyDerivation { inherit derivation }).pythonPath. Arguments. Edit source. Noogle also knows. Aliases. lib.derivations.lazyDerivation.",
    "word_count": 205,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lazyDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 197
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lazyDerivation. Restrict a derivation to a predictable set of attribute names, so that the returned attrset is not strict in the actual derivation, saving a lot of computation when the derivation is non-trivial. This is useful in situations where a derivation might only be used for its passthru attributes, improving evaluation performance. The returned attribute set is lazy in derivation. Specifically, this means that the derivation will not be evaluated in at least the situations below. For illustration and/or testing, we define derivation such that its evaluation is very noticeable. let derivation = throw \"This won't be evaluated.\"; In the following expressions, derivation will not be evaluated: (lazyDerivation { inherit derivation; }).type attrNames (lazyDerivation { inherit derivation; }) (lazyDerivation { inherit derivation; } // { foo = true; }).foo (lazyDerivation { inherit derivation; meta.foo = true; }).meta In these expressions, derivation will be evaluated: \"${lazyDerivation { inherit derivation }}\" (lazyDerivation { inherit derivation }).outPath (lazyDerivation { inherit derivation }).meta And the following expressions are not valid, because the refer to implementation details and/or attributes that may not be present on some derivations: (lazyDerivation { inherit derivation }).buildInputs (lazyDerivation { inherit derivation }).passthru (lazyDerivation { inherit derivation }).pythonPath. Arguments. Edit source. Noogle also knows. Aliases. lib.derivations.lazyDerivation.",
    "raw_url": "/f/lib/lazyDerivation.html",
    "excerpt": "lib.lazyDerivation. Restrict a derivation to a predictable set of attribute names, so that the returned attrset is not strict in the actual derivation, saving a lot of computation when the",
    "sub_results": []
  },
  {
    "url": "/f/lib/cleanSourceFilter.html",
    "content": "lib.cleanSourceFilter. A basic filter for cleanSourceWith that removes directories of version control system, backup files (*~) and some generated files. Arguments. [name] [type] Edit source. Noogle also knows. Aliases. lib.sources.cleanSourceFilter.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.cleanSourceFilter"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.cleanSourceFilter. A basic filter for cleanSourceWith that removes directories of version control system, backup files (*~) and some generated files. Arguments. [name] [type] Edit source. Noogle also knows. Aliases. lib.sources.cleanSourceFilter.",
    "raw_url": "/f/lib/cleanSourceFilter.html",
    "excerpt": "lib.cleanSourceFilter. A basic filter for cleanSourceWith that removes directories of version control system, backup files (*~) and some generated files. Arguments. [name] [type] Edit source. Noogle also knows. Aliases. lib.sources.cleanSourceFilter.",
    "sub_results": []
  },
  {
    "url": "/f/lib/noDepEntry.html",
    "content": "lib.noDepEntry. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.noDepEntry.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.noDepEntry"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.noDepEntry. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.noDepEntry.",
    "raw_url": "/f/lib/noDepEntry.html",
    "excerpt": "lib.noDepEntry. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.noDepEntry.",
    "sub_results": []
  },
  {
    "url": "/f/lib/getOutput.html",
    "content": "lib.getOutput. Get a package output. If no output is found, fallback to .out and then to the default. Example. getOutput \"dev\" pkgs.openssl => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getOutput :: String -> Derivation -> String Arguments. [output] [pkg] Edit source. Noogle also knows. Aliases. lib.attrsets.getOutput.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getOutput"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 24
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getOutput. Get a package output. If no output is found, fallback to .out and then to the default. Example. getOutput \"dev\" pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getOutput :: String -&gt; Derivation -&gt; String Arguments. [output] [pkg] Edit source. Noogle also knows. Aliases. lib.attrsets.getOutput.",
    "raw_url": "/f/lib/getOutput.html",
    "excerpt": "lib.getOutput. Get a package output. If no output is found, fallback to .out and then to the default. Example. getOutput \"dev\" pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getOutput :: String -&gt; Derivation",
    "sub_results": []
  },
  {
    "url": "/f/lib/bitNot.html",
    "content": "lib.bitNot. bitwise “not” Edit source. Noogle also knows. Aliases. lib.trivial.bitNot.",
    "word_count": 10,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.bitNot"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.bitNot. bitwise “not” Edit source. Noogle also knows. Aliases. lib.trivial.bitNot.",
    "raw_url": "/f/lib/bitNot.html",
    "excerpt": "lib.bitNot. bitwise “not” Edit source. Noogle also knows. Aliases. lib.trivial.bitNot.",
    "sub_results": []
  },
  {
    "url": "/f/lib/traceIf.html",
    "content": "lib.traceIf. Conditionally trace the supplied message, based on a predicate. Example. traceIf true \"hello\" 3 trace: hello => 3 Type. traceIf :: bool -> string -> a -> a Arguments. [pred] Predicate to check. [msg] Message that should be traced. [x] Value to return. Edit source. Noogle also knows. Aliases. lib.debug.traceIf.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.traceIf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.traceIf. Conditionally trace the supplied message, based on a predicate. Example. traceIf true \"hello\" 3 trace: hello =&gt; 3 Type. traceIf :: bool -&gt; string -&gt; a -&gt; a Arguments. [pred] Predicate to check. [msg] Message that should be traced. [x] Value to return. Edit source. Noogle also knows. Aliases. lib.debug.traceIf.",
    "raw_url": "/f/lib/traceIf.html",
    "excerpt": "lib.traceIf. Conditionally trace the supplied message, based on a predicate. Example. traceIf true \"hello\" 3 trace: hello =&gt; 3 Type. traceIf :: bool -&gt; string -&gt; a -&gt; a Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkOptionType.html",
    "content": "lib.mkOptionType. Edit source. Noogle also knows. Aliases. lib.types.mkOptionType.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkOptionType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkOptionType. Edit source. Noogle also knows. Aliases. lib.types.mkOptionType.",
    "raw_url": "/f/lib/mkOptionType.html",
    "excerpt": "lib.mkOptionType. Edit source. Noogle also knows. Aliases. lib.types.mkOptionType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/isBool.html",
    "content": "lib.isBool Primop. Takes 1 arguments. e. Return true if e evaluates to a bool, and false otherwise. Noogle also knows. Aliases. builtins.isBool. lib.trivial.isBool.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isBool Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isBool Primop. Takes 1 arguments. e. Return true if e evaluates to a bool, and false otherwise. Noogle also knows. Aliases. builtins.isBool. lib.trivial.isBool.",
    "raw_url": "/f/lib/isBool.html",
    "excerpt": "lib.isBool Primop. Takes 1 arguments. e. Return true if e evaluates to a bool, and false otherwise. Noogle also knows. Aliases. builtins.isBool. lib.trivial.isBool.",
    "sub_results": []
  },
  {
    "url": "/f/lib/toUpper.html",
    "content": "lib.toUpper. Converts an ASCII string to upper-case. Example. toUpper \"home\" => \"HOME\" Type. toUpper :: string -> string Edit source. Noogle also knows. Aliases. lib.strings.toUpper.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toUpper"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 7
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toUpper. Converts an ASCII string to upper-case. Example. toUpper \"home\" =&gt; \"HOME\" Type. toUpper :: string -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.toUpper.",
    "raw_url": "/f/lib/toUpper.html",
    "excerpt": "lib.toUpper. Converts an ASCII string to upper-case. Example. toUpper \"home\" =&gt; \"HOME\" Type. toUpper :: string -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.toUpper.",
    "sub_results": []
  },
  {
    "url": "/f/lib/filesystem/listFilesRecursive.html",
    "content": "lib.filesystem.listFilesRecursive. Given a directory, return a flattened list of all files within it recursively. Type. Path -> [ Path ] Arguments. [dir] The path to recursively list. Edit source.",
    "word_count": 29,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.filesystem.listFilesRecursive"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.filesystem.listFilesRecursive. Given a directory, return a flattened list of all files within it recursively. Type. Path -&gt; [ Path ] Arguments. [dir] The path to recursively list. Edit source.",
    "raw_url": "/f/lib/filesystem/listFilesRecursive.html",
    "excerpt": "lib.filesystem.listFilesRecursive. Given a directory, return a flattened list of all files within it recursively. Type. Path -&gt; [ Path ] Arguments. [dir] The path to recursively list. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/filesystem/locateDominatingFile.html",
    "content": "lib.filesystem.locateDominatingFile. Find the first directory containing a file matching 'pattern' upward from a given 'file'. Returns 'null' if no directories contain a file matching 'pattern'. Type. RegExp -> Path -> Nullable { path : Path; matches : [ MatchResults ]; } Arguments. [pattern] The pattern to search for. [file] The file to start searching upward from. Edit source.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.filesystem.locateDominatingFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.filesystem.locateDominatingFile. Find the first directory containing a file matching 'pattern' upward from a given 'file'. Returns 'null' if no directories contain a file matching 'pattern'. Type. RegExp -&gt; Path -&gt; Nullable { path : Path; matches : [ MatchResults ]; } Arguments. [pattern] The pattern to search for. [file] The file to start searching upward from. Edit source.",
    "raw_url": "/f/lib/filesystem/locateDominatingFile.html",
    "excerpt": "lib.filesystem.locateDominatingFile. Find the first directory containing a file matching 'pattern' upward from a given 'file'. Returns 'null' if no directories contain a file matching 'pattern'. Type. RegExp -&gt; Path -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/filesystem/haskellPathsInDir.html",
    "content": "lib.filesystem.haskellPathsInDir. A map of all haskell packages defined in the given path, identified by having a cabal file with the same name as the directory itself. Type. Path -> Map String Path Arguments. [root] The directory within to search. Edit source.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.filesystem.haskellPathsInDir"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 26
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.filesystem.haskellPathsInDir. A map of all haskell packages defined in the given path, identified by having a cabal file with the same name as the directory itself. Type. Path -&gt; Map String Path Arguments. [root] The directory within to search. Edit source.",
    "raw_url": "/f/lib/filesystem/haskellPathsInDir.html",
    "excerpt": "lib.filesystem.haskellPathsInDir. A map of all haskell packages defined in the given path, identified by having a cabal file with the same name as the directory itself. Type. Path -&gt; Map",
    "sub_results": []
  },
  {
    "url": "/f/lib/filesystem/pathIsDirectory.html",
    "content": "lib.filesystem.pathIsDirectory. Whether a path exists and is a directory. Example. pathIsDirectory /. => true pathIsDirectory /this/does/not/exist => false pathIsDirectory /some/file.nix => false Type. pathIsDirectory :: Path -> Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.pathIsDirectory. lib.sources.pathIsDirectory.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.filesystem.pathIsDirectory"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 28
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.filesystem.pathIsDirectory. Whether a path exists and is a directory. Example. pathIsDirectory /. =&gt; true pathIsDirectory /this/does/not/exist =&gt; false pathIsDirectory /some/file.nix =&gt; false Type. pathIsDirectory :: Path -&gt; Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.pathIsDirectory. lib.sources.pathIsDirectory.",
    "raw_url": "/f/lib/filesystem/pathIsDirectory.html",
    "excerpt": "lib.filesystem.pathIsDirectory. Whether a path exists and is a directory. Example. pathIsDirectory /. =&gt; true pathIsDirectory /this/does/not/exist =&gt; false pathIsDirectory /some/file.nix =&gt; false Type. pathIsDirectory :: Path -&gt; Bool Arguments. [path]",
    "sub_results": []
  },
  {
    "url": "/f/lib/filesystem/pathType.html",
    "content": "lib.filesystem.pathType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else. Example. pathType /. => \"directory\" pathType /some/file.nix => \"regular\" Type. pathType :: Path -> String Edit source. Noogle also knows. Aliases. builtins.readFileType. lib.pathType. lib.sources.pathType.",
    "word_count": 65,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.filesystem.pathType Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 41
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.filesystem.pathType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else. Example. pathType /. =&gt; \"directory\" pathType /some/file.nix =&gt; \"regular\" Type. pathType :: Path -&gt; String Edit source. Noogle also knows. Aliases. builtins.readFileType. lib.pathType. lib.sources.pathType.",
    "raw_url": "/f/lib/filesystem/pathType.html",
    "excerpt": "lib.filesystem.pathType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a",
    "sub_results": []
  },
  {
    "url": "/f/lib/filesystem/pathIsRegularFile.html",
    "content": "lib.filesystem.pathIsRegularFile. Whether a path exists and is a regular file, meaning not a symlink or any other special file type. Example. pathIsRegularFile /. => false pathIsRegularFile /this/does/not/exist => false pathIsRegularFile /some/file.nix => true Type. pathIsRegularFile :: Path -> Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.pathIsRegularFile. lib.sources.pathIsRegularFile.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.filesystem.pathIsRegularFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 33
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.filesystem.pathIsRegularFile. Whether a path exists and is a regular file, meaning not a symlink or any other special file type. Example. pathIsRegularFile /. =&gt; false pathIsRegularFile /this/does/not/exist =&gt; false pathIsRegularFile /some/file.nix =&gt; true Type. pathIsRegularFile :: Path -&gt; Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.pathIsRegularFile. lib.sources.pathIsRegularFile.",
    "raw_url": "/f/lib/filesystem/pathIsRegularFile.html",
    "excerpt": "lib.filesystem.pathIsRegularFile. Whether a path exists and is a regular file, meaning not a symlink or any other special file type. Example. pathIsRegularFile /. =&gt; false pathIsRegularFile /this/does/not/exist =&gt; false pathIsRegularFile",
    "sub_results": []
  },
  {
    "url": "/f/lib/cmakeFeature.html",
    "content": "lib.cmakeFeature. Create a -D:STRING= string that can be passed to typical CMake invocations. This is the most typical usage, so it deserves a special case. Example. cmakeFeature \"MODULES\" \"badblock\" => \"-DMODULES:STRING=badblock\" Type. cmakeFeature :: string -> string -> string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [feature] [value] Edit source. Noogle also knows. Aliases. lib.strings.cmakeFeature.",
    "word_count": 67,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.cmakeFeature"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 25
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 57
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.cmakeFeature. Create a -D:STRING= string that can be passed to typical CMake invocations. This is the most typical usage, so it deserves a special case. Example. cmakeFeature \"MODULES\" \"badblock\" =&gt; \"-DMODULES:STRING=badblock\" Type. cmakeFeature :: string -&gt; string -&gt; string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [feature] [value] Edit source. Noogle also knows. Aliases. lib.strings.cmakeFeature.",
    "raw_url": "/f/lib/cmakeFeature.html",
    "excerpt": "lib.cmakeFeature. Create a -D:STRING= string that can be passed to typical CMake invocations. This is the most typical usage, so it deserves a special case. Example. cmakeFeature \"MODULES\" \"badblock\" =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/pathHasContext.html",
    "content": "lib.pathHasContext Primop. Takes 1 arguments. s. Return true if string s has a non-empty context. The context can be obtained with getContext. Noogle also knows. Aliases. builtins.hasContext. lib.sources.pathHasContext.",
    "word_count": 28,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.pathHasContext Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.pathHasContext Primop. Takes 1 arguments. s. Return true if string s has a non-empty context. The context can be obtained with getContext. Noogle also knows. Aliases. builtins.hasContext. lib.sources.pathHasContext.",
    "raw_url": "/f/lib/pathHasContext.html",
    "excerpt": "lib.pathHasContext Primop. Takes 1 arguments. s. Return true if string s has a non-empty context. The context can be obtained with getContext. Noogle also knows. Aliases. builtins.hasContext. lib.sources.pathHasContext.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mesonEnable.html",
    "content": "lib.mesonEnable. Create a -D={enabled,disabled} string that can be passed to typical Meson invocations. Example. mesonEnable \"docs\" true => \"-Ddocs=enabled\" mesonEnable \"savage\" false => \"-Dsavage=disabled\" Type. mesonEnable :: string -> bool -> string @param feature The feature to be enabled or disabled @param flag The controlling flag Arguments. [feature] [flag] Edit source. Noogle also knows. Aliases. lib.strings.mesonEnable.",
    "word_count": 56,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mesonEnable"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 24
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 46
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mesonEnable. Create a -D={enabled,disabled} string that can be passed to typical Meson invocations. Example. mesonEnable \"docs\" true =&gt; \"-Ddocs=enabled\" mesonEnable \"savage\" false =&gt; \"-Dsavage=disabled\" Type. mesonEnable :: string -&gt; bool -&gt; string @param feature The feature to be enabled or disabled @param flag The controlling flag Arguments. [feature] [flag] Edit source. Noogle also knows. Aliases. lib.strings.mesonEnable.",
    "raw_url": "/f/lib/mesonEnable.html",
    "excerpt": "lib.mesonEnable. Create a -D={enabled,disabled} string that can be passed to typical Meson invocations. Example. mesonEnable \"docs\" true =&gt; \"-Ddocs=enabled\" mesonEnable \"savage\" false =&gt; \"-Dsavage=disabled\" Type. mesonEnable :: string -&gt; bool",
    "sub_results": []
  },
  {
    "url": "/f/lib/foldAttrs.html",
    "content": "lib.foldAttrs. Apply fold functions to values grouped by key. Example. foldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }] => { a = [ 2 3 ]; } Type. foldAttrs :: (Any -> Any -> Any) -> Any -> [AttrSets] -> Any Arguments. [op] A function, given a value and a collector combines the two. [nul] The starting value. [list_of_attrs] A list of attribute sets to fold together by key. Edit source. Noogle also knows. Aliases. lib.attrsets.foldAttrs.",
    "word_count": 85,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.foldAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 36
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.foldAttrs. Apply fold functions to values grouped by key. Example. foldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }] =&gt; { a = [ 2 3 ]; } Type. foldAttrs :: (Any -&gt; Any -&gt; Any) -&gt; Any -&gt; [AttrSets] -&gt; Any Arguments. [op] A function, given a value and a collector combines the two. [nul] The starting value. [list_of_attrs] A list of attribute sets to fold together by key. Edit source. Noogle also knows. Aliases. lib.attrsets.foldAttrs.",
    "raw_url": "/f/lib/foldAttrs.html",
    "excerpt": "lib.foldAttrs. Apply fold functions to values grouped by key. Example. foldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }] =&gt; { a",
    "sub_results": []
  },
  {
    "url": "/f/lib/recurseIntoAttrs.html",
    "content": "lib.recurseIntoAttrs. Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc. This function only affects a single attribute set; it does not apply itself recursively for nested attribute sets. Example. { pkgs ? import <nixpkgs> {} }: { myTools = pkgs.lib.recurseIntoAttrs { inherit (pkgs) hello figlet; }; } Type. recurseIntoAttrs :: AttrSet -> AttrSet Arguments. [attrs] An attribute set to scan for derivations. Edit source. Noogle also knows. Aliases. lib.attrsets.recurseIntoAttrs. pkgs.recurseIntoAttrs.",
    "word_count": 81,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.recurseIntoAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 39
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 58
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 64
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.recurseIntoAttrs. Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc. This function only affects a single attribute set; it does not apply itself recursively for nested attribute sets. Example. { pkgs ? import &lt;nixpkgs&gt; {} }: { myTools = pkgs.lib.recurseIntoAttrs { inherit (pkgs) hello figlet; }; } Type. recurseIntoAttrs :: AttrSet -&gt; AttrSet Arguments. [attrs] An attribute set to scan for derivations. Edit source. Noogle also knows. Aliases. lib.attrsets.recurseIntoAttrs. pkgs.recurseIntoAttrs.",
    "raw_url": "/f/lib/recurseIntoAttrs.html",
    "excerpt": "lib.recurseIntoAttrs. Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc. This function only affects a single attribute set; it",
    "sub_results": []
  },
  {
    "url": "/f/lib/pathType.html",
    "content": "lib.pathType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else. Example. pathType /. => \"directory\" pathType /some/file.nix => \"regular\" Type. pathType :: Path -> String Edit source. Noogle also knows. Aliases. builtins.readFileType. lib.filesystem.pathType. lib.sources.pathType.",
    "word_count": 65,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.pathType Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 41
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.pathType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else. Example. pathType /. =&gt; \"directory\" pathType /some/file.nix =&gt; \"regular\" Type. pathType :: Path -&gt; String Edit source. Noogle also knows. Aliases. builtins.readFileType. lib.filesystem.pathType. lib.sources.pathType.",
    "raw_url": "/f/lib/pathType.html",
    "excerpt": "lib.pathType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a",
    "sub_results": []
  },
  {
    "url": "/f/lib/flip.html",
    "content": "lib.flip. Flip the order of the arguments of a binary function. Example. flip concat [1] [2] => [ 2 1 ] Type. flip :: (a -> b -> c) -> (b -> a -> c) Arguments. [f] [a] [b] Edit source. Noogle also knows. Aliases. lib.trivial.flip.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.flip"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.flip. Flip the order of the arguments of a binary function. Example. flip concat [1] [2] =&gt; [ 2 1 ] Type. flip :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) Arguments. [f] [a] [b] Edit source. Noogle also knows. Aliases. lib.trivial.flip.",
    "raw_url": "/f/lib/flip.html",
    "excerpt": "lib.flip. Flip the order of the arguments of a binary function. Example. flip concat [1] [2] =&gt; [ 2 1 ] Type. flip :: (a -&gt; b -&gt; c) -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/or.html",
    "content": "lib.or. boolean “or” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.or.",
    "word_count": 13,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.or"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 3
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.or. boolean “or” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.or.",
    "raw_url": "/f/lib/or.html",
    "excerpt": "lib.or. boolean “or” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.or.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/elaborate.html",
    "content": "lib.systems.elaborate. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.elaborate"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.elaborate. Edit source.",
    "raw_url": "/f/lib/systems/elaborate.html",
    "excerpt": "lib.systems.elaborate. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/equals.html",
    "content": "lib.systems.equals. Elaborated systems contain functions, which means that they don't satisfy == for a lack of reflexivity. They might appear to satisfy == reflexivity when the same exact value is compared to itself, because object identity is used as an \"optimization\"; compare the value with a reconstruction of itself, e.g. with f == a: f a, or perhaps calling elaborate twice, and one will see reflexivity fail as described. Hence a custom equality test. Note that this does not canonicalize the systems, so you'll want to make sure both arguments have been elaborate-d. Edit source.",
    "word_count": 95,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.equals"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.equals. Elaborated systems contain functions, which means that they don't satisfy == for a lack of reflexivity. They might appear to satisfy == reflexivity when the same exact value is compared to itself, because object identity is used as an \"optimization\"; compare the value with a reconstruction of itself, e.g. with f == a: f a, or perhaps calling elaborate twice, and one will see reflexivity fail as described. Hence a custom equality test. Note that this does not canonicalize the systems, so you'll want to make sure both arguments have been elaborate-d. Edit source.",
    "raw_url": "/f/lib/systems/equals.html",
    "excerpt": "lib.systems.equals. Elaborated systems contain functions, which means that they don't satisfy == for a lack of reflexivity. They might appear to satisfy == reflexivity when the same exact value is",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isRiscV32.html",
    "content": "lib.systems.inspect.predicates.isRiscV32.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isRiscV32"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isRiscV32.",
    "raw_url": "/f/lib/systems/inspect/predicates/isRiscV32.html",
    "excerpt": "lib.systems.inspect.predicates.isRiscV32.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isFreeBSD.html",
    "content": "lib.systems.inspect.predicates.isFreeBSD.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isFreeBSD"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isFreeBSD.",
    "raw_url": "/f/lib/systems/inspect/predicates/isFreeBSD.html",
    "excerpt": "lib.systems.inspect.predicates.isFreeBSD.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isS390.html",
    "content": "lib.systems.inspect.predicates.isS390.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isS390"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isS390.",
    "raw_url": "/f/lib/systems/inspect/predicates/isS390.html",
    "excerpt": "lib.systems.inspect.predicates.isS390.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isAvr.html",
    "content": "lib.systems.inspect.predicates.isAvr.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isAvr"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isAvr.",
    "raw_url": "/f/lib/systems/inspect/predicates/isAvr.html",
    "excerpt": "lib.systems.inspect.predicates.isAvr.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isRiscV64.html",
    "content": "lib.systems.inspect.predicates.isRiscV64.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isRiscV64"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isRiscV64.",
    "raw_url": "/f/lib/systems/inspect/predicates/isRiscV64.html",
    "excerpt": "lib.systems.inspect.predicates.isRiscV64.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isSunOS.html",
    "content": "lib.systems.inspect.predicates.isSunOS.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isSunOS"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isSunOS.",
    "raw_url": "/f/lib/systems/inspect/predicates/isSunOS.html",
    "excerpt": "lib.systems.inspect.predicates.isSunOS.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMinGW.html",
    "content": "lib.systems.inspect.predicates.isMinGW.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMinGW"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMinGW.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMinGW.html",
    "excerpt": "lib.systems.inspect.predicates.isMinGW.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isOr1k.html",
    "content": "lib.systems.inspect.predicates.isOr1k.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isOr1k"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isOr1k.",
    "raw_url": "/f/lib/systems/inspect/predicates/isOr1k.html",
    "excerpt": "lib.systems.inspect.predicates.isOr1k.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/is32bit.html",
    "content": "lib.systems.inspect.predicates.is32bit.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.is32bit"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.is32bit.",
    "raw_url": "/f/lib/systems/inspect/predicates/is32bit.html",
    "excerpt": "lib.systems.inspect.predicates.is32bit.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isBigEndian.html",
    "content": "lib.systems.inspect.predicates.isBigEndian.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isBigEndian"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isBigEndian.",
    "raw_url": "/f/lib/systems/inspect/predicates/isBigEndian.html",
    "excerpt": "lib.systems.inspect.predicates.isBigEndian.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isAlpha.html",
    "content": "lib.systems.inspect.predicates.isAlpha.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isAlpha"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isAlpha.",
    "raw_url": "/f/lib/systems/inspect/predicates/isAlpha.html",
    "excerpt": "lib.systems.inspect.predicates.isAlpha.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMusl.html",
    "content": "lib.systems.inspect.predicates.isMusl. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMusl"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMusl. Edit source.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMusl.html",
    "excerpt": "lib.systems.inspect.predicates.isMusl. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isNone.html",
    "content": "lib.systems.inspect.predicates.isNone.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isNone"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isNone.",
    "raw_url": "/f/lib/systems/inspect/predicates/isNone.html",
    "excerpt": "lib.systems.inspect.predicates.isNone.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isAndroid.html",
    "content": "lib.systems.inspect.predicates.isAndroid. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isAndroid"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isAndroid. Edit source.",
    "raw_url": "/f/lib/systems/inspect/predicates/isAndroid.html",
    "excerpt": "lib.systems.inspect.predicates.isAndroid. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isLinux.html",
    "content": "lib.systems.inspect.predicates.isLinux.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isLinux"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isLinux.",
    "raw_url": "/f/lib/systems/inspect/predicates/isLinux.html",
    "excerpt": "lib.systems.inspect.predicates.isLinux.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isAarch.html",
    "content": "lib.systems.inspect.predicates.isAarch.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isAarch"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isAarch.",
    "raw_url": "/f/lib/systems/inspect/predicates/isAarch.html",
    "excerpt": "lib.systems.inspect.predicates.isAarch.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isx86.html",
    "content": "lib.systems.inspect.predicates.isx86.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isx86"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isx86.",
    "raw_url": "/f/lib/systems/inspect/predicates/isx86.html",
    "excerpt": "lib.systems.inspect.predicates.isx86.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMicroBlaze.html",
    "content": "lib.systems.inspect.predicates.isMicroBlaze.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMicroBlaze"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMicroBlaze.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMicroBlaze.html",
    "excerpt": "lib.systems.inspect.predicates.isMicroBlaze.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMips.html",
    "content": "lib.systems.inspect.predicates.isMips.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMips"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMips.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMips.html",
    "excerpt": "lib.systems.inspect.predicates.isMips.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMips32.html",
    "content": "lib.systems.inspect.predicates.isMips32.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMips32"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMips32.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMips32.html",
    "excerpt": "lib.systems.inspect.predicates.isMips32.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isRedox.html",
    "content": "lib.systems.inspect.predicates.isRedox.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isRedox"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isRedox.",
    "raw_url": "/f/lib/systems/inspect/predicates/isRedox.html",
    "excerpt": "lib.systems.inspect.predicates.isRedox.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isILP32.html",
    "content": "lib.systems.inspect.predicates.isILP32. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isILP32"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isILP32. Edit source.",
    "raw_url": "/f/lib/systems/inspect/predicates/isILP32.html",
    "excerpt": "lib.systems.inspect.predicates.isILP32. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isGnu.html",
    "content": "lib.systems.inspect.predicates.isGnu. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isGnu"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isGnu. Edit source.",
    "raw_url": "/f/lib/systems/inspect/predicates/isGnu.html",
    "excerpt": "lib.systems.inspect.predicates.isGnu. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isAbiElfv2.html",
    "content": "lib.systems.inspect.predicates.isAbiElfv2. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isAbiElfv2"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isAbiElfv2. Edit source.",
    "raw_url": "/f/lib/systems/inspect/predicates/isAbiElfv2.html",
    "excerpt": "lib.systems.inspect.predicates.isAbiElfv2. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isNetBSD.html",
    "content": "lib.systems.inspect.predicates.isNetBSD.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isNetBSD"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isNetBSD.",
    "raw_url": "/f/lib/systems/inspect/predicates/isNetBSD.html",
    "excerpt": "lib.systems.inspect.predicates.isNetBSD.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isPower64.html",
    "content": "lib.systems.inspect.predicates.isPower64.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isPower64"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isPower64.",
    "raw_url": "/f/lib/systems/inspect/predicates/isPower64.html",
    "excerpt": "lib.systems.inspect.predicates.isPower64.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isAarch64.html",
    "content": "lib.systems.inspect.predicates.isAarch64.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isAarch64"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isAarch64.",
    "raw_url": "/f/lib/systems/inspect/predicates/isAarch64.html",
    "excerpt": "lib.systems.inspect.predicates.isAarch64.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isx86_32.html",
    "content": "lib.systems.inspect.predicates.isx86_32.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isx86_32"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isx86_32.",
    "raw_url": "/f/lib/systems/inspect/predicates/isx86_32.html",
    "excerpt": "lib.systems.inspect.predicates.isx86_32.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isBSD.html",
    "content": "lib.systems.inspect.predicates.isBSD.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isBSD"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isBSD.",
    "raw_url": "/f/lib/systems/inspect/predicates/isBSD.html",
    "excerpt": "lib.systems.inspect.predicates.isBSD.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isGenode.html",
    "content": "lib.systems.inspect.predicates.isGenode.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isGenode"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isGenode.",
    "raw_url": "/f/lib/systems/inspect/predicates/isGenode.html",
    "excerpt": "lib.systems.inspect.predicates.isGenode.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isM68k.html",
    "content": "lib.systems.inspect.predicates.isM68k.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isM68k"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isM68k.",
    "raw_url": "/f/lib/systems/inspect/predicates/isM68k.html",
    "excerpt": "lib.systems.inspect.predicates.isM68k.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isGhcjs.html",
    "content": "lib.systems.inspect.predicates.isGhcjs.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isGhcjs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isGhcjs.",
    "raw_url": "/f/lib/systems/inspect/predicates/isGhcjs.html",
    "excerpt": "lib.systems.inspect.predicates.isGhcjs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMacOS.html",
    "content": "lib.systems.inspect.predicates.isMacOS.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMacOS"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMacOS.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMacOS.html",
    "excerpt": "lib.systems.inspect.predicates.isMacOS.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isSparc.html",
    "content": "lib.systems.inspect.predicates.isSparc.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isSparc"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isSparc.",
    "raw_url": "/f/lib/systems/inspect/predicates/isSparc.html",
    "excerpt": "lib.systems.inspect.predicates.isSparc.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMips64n32.html",
    "content": "lib.systems.inspect.predicates.isMips64n32.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMips64n32"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMips64n32.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMips64n32.html",
    "excerpt": "lib.systems.inspect.predicates.isMips64n32.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isLittleEndian.html",
    "content": "lib.systems.inspect.predicates.isLittleEndian.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isLittleEndian"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isLittleEndian.",
    "raw_url": "/f/lib/systems/inspect/predicates/isLittleEndian.html",
    "excerpt": "lib.systems.inspect.predicates.isLittleEndian.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isEfi.html",
    "content": "lib.systems.inspect.predicates.isEfi. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isEfi"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isEfi. Edit source.",
    "raw_url": "/f/lib/systems/inspect/predicates/isEfi.html",
    "excerpt": "lib.systems.inspect.predicates.isEfi. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isRx.html",
    "content": "lib.systems.inspect.predicates.isRx.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isRx"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isRx.",
    "raw_url": "/f/lib/systems/inspect/predicates/isRx.html",
    "excerpt": "lib.systems.inspect.predicates.isRx.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isArmv7.html",
    "content": "lib.systems.inspect.predicates.isArmv7. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isArmv7"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isArmv7. Edit source.",
    "raw_url": "/f/lib/systems/inspect/predicates/isArmv7.html",
    "excerpt": "lib.systems.inspect.predicates.isArmv7. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isiOS.html",
    "content": "lib.systems.inspect.predicates.isiOS.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isiOS"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isiOS.",
    "raw_url": "/f/lib/systems/inspect/predicates/isiOS.html",
    "excerpt": "lib.systems.inspect.predicates.isiOS.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isDarwin.html",
    "content": "lib.systems.inspect.predicates.isDarwin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isDarwin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isDarwin.",
    "raw_url": "/f/lib/systems/inspect/predicates/isDarwin.html",
    "excerpt": "lib.systems.inspect.predicates.isDarwin.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMips64n64.html",
    "content": "lib.systems.inspect.predicates.isMips64n64.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMips64n64"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMips64n64.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMips64n64.html",
    "excerpt": "lib.systems.inspect.predicates.isMips64n64.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isS390x.html",
    "content": "lib.systems.inspect.predicates.isS390x.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isS390x"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isS390x.",
    "raw_url": "/f/lib/systems/inspect/predicates/isS390x.html",
    "excerpt": "lib.systems.inspect.predicates.isS390x.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isLoongArch64.html",
    "content": "lib.systems.inspect.predicates.isLoongArch64.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isLoongArch64"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isLoongArch64.",
    "raw_url": "/f/lib/systems/inspect/predicates/isLoongArch64.html",
    "excerpt": "lib.systems.inspect.predicates.isLoongArch64.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/is64bit.html",
    "content": "lib.systems.inspect.predicates.is64bit.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.is64bit"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.is64bit.",
    "raw_url": "/f/lib/systems/inspect/predicates/is64bit.html",
    "excerpt": "lib.systems.inspect.predicates.is64bit.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isAarch32.html",
    "content": "lib.systems.inspect.predicates.isAarch32.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isAarch32"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isAarch32.",
    "raw_url": "/f/lib/systems/inspect/predicates/isAarch32.html",
    "excerpt": "lib.systems.inspect.predicates.isAarch32.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isPower.html",
    "content": "lib.systems.inspect.predicates.isPower.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isPower"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isPower.",
    "raw_url": "/f/lib/systems/inspect/predicates/isPower.html",
    "excerpt": "lib.systems.inspect.predicates.isPower.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isx86_64.html",
    "content": "lib.systems.inspect.predicates.isx86_64.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isx86_64"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isx86_64.",
    "raw_url": "/f/lib/systems/inspect/predicates/isx86_64.html",
    "excerpt": "lib.systems.inspect.predicates.isx86_64.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isWasi.html",
    "content": "lib.systems.inspect.predicates.isWasi.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isWasi"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isWasi.",
    "raw_url": "/f/lib/systems/inspect/predicates/isWasi.html",
    "excerpt": "lib.systems.inspect.predicates.isWasi.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isOpenBSD.html",
    "content": "lib.systems.inspect.predicates.isOpenBSD.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isOpenBSD"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isOpenBSD.",
    "raw_url": "/f/lib/systems/inspect/predicates/isOpenBSD.html",
    "excerpt": "lib.systems.inspect.predicates.isOpenBSD.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isUnix.html",
    "content": "lib.systems.inspect.predicates.isUnix. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isUnix"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isUnix. Edit source.",
    "raw_url": "/f/lib/systems/inspect/predicates/isUnix.html",
    "excerpt": "lib.systems.inspect.predicates.isUnix. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isCygwin.html",
    "content": "lib.systems.inspect.predicates.isCygwin.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isCygwin"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isCygwin.",
    "raw_url": "/f/lib/systems/inspect/predicates/isCygwin.html",
    "excerpt": "lib.systems.inspect.predicates.isCygwin.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMmix.html",
    "content": "lib.systems.inspect.predicates.isMmix.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMmix"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMmix.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMmix.html",
    "excerpt": "lib.systems.inspect.predicates.isMmix.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isWindows.html",
    "content": "lib.systems.inspect.predicates.isWindows.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isWindows"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isWindows.",
    "raw_url": "/f/lib/systems/inspect/predicates/isWindows.html",
    "excerpt": "lib.systems.inspect.predicates.isWindows.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isi686.html",
    "content": "lib.systems.inspect.predicates.isi686.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isi686"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isi686.",
    "raw_url": "/f/lib/systems/inspect/predicates/isi686.html",
    "excerpt": "lib.systems.inspect.predicates.isi686.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isRiscV.html",
    "content": "lib.systems.inspect.predicates.isRiscV.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isRiscV"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isRiscV.",
    "raw_url": "/f/lib/systems/inspect/predicates/isRiscV.html",
    "excerpt": "lib.systems.inspect.predicates.isRiscV.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMsp430.html",
    "content": "lib.systems.inspect.predicates.isMsp430.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMsp430"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMsp430.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMsp430.html",
    "excerpt": "lib.systems.inspect.predicates.isMsp430.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isVc4.html",
    "content": "lib.systems.inspect.predicates.isVc4.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isVc4"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isVc4.",
    "raw_url": "/f/lib/systems/inspect/predicates/isVc4.html",
    "excerpt": "lib.systems.inspect.predicates.isVc4.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isWasm.html",
    "content": "lib.systems.inspect.predicates.isWasm.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isWasm"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isWasm.",
    "raw_url": "/f/lib/systems/inspect/predicates/isWasm.html",
    "excerpt": "lib.systems.inspect.predicates.isWasm.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isMips64.html",
    "content": "lib.systems.inspect.predicates.isMips64.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isMips64"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isMips64.",
    "raw_url": "/f/lib/systems/inspect/predicates/isMips64.html",
    "excerpt": "lib.systems.inspect.predicates.isMips64.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isUClibc.html",
    "content": "lib.systems.inspect.predicates.isUClibc. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isUClibc"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isUClibc. Edit source.",
    "raw_url": "/f/lib/systems/inspect/predicates/isUClibc.html",
    "excerpt": "lib.systems.inspect.predicates.isUClibc. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/predicates/isJavaScript.html",
    "content": "lib.systems.inspect.predicates.isJavaScript.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.predicates.isJavaScript"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.predicates.isJavaScript.",
    "raw_url": "/f/lib/systems/inspect/predicates/isJavaScript.html",
    "excerpt": "lib.systems.inspect.predicates.isJavaScript.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/patternLogicalAnd.html",
    "content": "lib.systems.inspect.patternLogicalAnd. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.patternLogicalAnd"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.patternLogicalAnd. Edit source.",
    "raw_url": "/f/lib/systems/inspect/patternLogicalAnd.html",
    "excerpt": "lib.systems.inspect.patternLogicalAnd. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/inspect/matchAnyAttrs.html",
    "content": "lib.systems.inspect.matchAnyAttrs. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.inspect.matchAnyAttrs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.inspect.matchAnyAttrs. Edit source.",
    "raw_url": "/f/lib/systems/inspect/matchAnyAttrs.html",
    "excerpt": "lib.systems.inspect.matchAnyAttrs. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/parse/doubleFromSystem.html",
    "content": "lib.systems.parse.doubleFromSystem. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.parse.doubleFromSystem"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.parse.doubleFromSystem. Edit source.",
    "raw_url": "/f/lib/systems/parse/doubleFromSystem.html",
    "excerpt": "lib.systems.parse.doubleFromSystem. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/parse/isSystem.html",
    "content": "lib.systems.parse.isSystem.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.parse.isSystem"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.parse.isSystem.",
    "raw_url": "/f/lib/systems/parse/isSystem.html",
    "excerpt": "lib.systems.parse.isSystem.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/parse/mkSystem.html",
    "content": "lib.systems.parse.mkSystem. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.parse.mkSystem"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.parse.mkSystem. Edit source.",
    "raw_url": "/f/lib/systems/parse/mkSystem.html",
    "excerpt": "lib.systems.parse.mkSystem. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/parse/kernelName.html",
    "content": "lib.systems.parse.kernelName. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.parse.kernelName"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.parse.kernelName. Edit source.",
    "raw_url": "/f/lib/systems/parse/kernelName.html",
    "excerpt": "lib.systems.parse.kernelName. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/parse/tripleFromSystem.html",
    "content": "lib.systems.parse.tripleFromSystem. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.parse.tripleFromSystem"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.parse.tripleFromSystem. Edit source.",
    "raw_url": "/f/lib/systems/parse/tripleFromSystem.html",
    "excerpt": "lib.systems.parse.tripleFromSystem. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/parse/isCompatible.html",
    "content": "lib.systems.parse.isCompatible. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.parse.isCompatible"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.parse.isCompatible. Edit source.",
    "raw_url": "/f/lib/systems/parse/isCompatible.html",
    "excerpt": "lib.systems.parse.isCompatible. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/parse/mkSystemFromSkeleton.html",
    "content": "lib.systems.parse.mkSystemFromSkeleton. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.parse.mkSystemFromSkeleton"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.parse.mkSystemFromSkeleton. Edit source.",
    "raw_url": "/f/lib/systems/parse/mkSystemFromSkeleton.html",
    "excerpt": "lib.systems.parse.mkSystemFromSkeleton. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/parse/mkSkeletonFromList.html",
    "content": "lib.systems.parse.mkSkeletonFromList. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.parse.mkSkeletonFromList"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.parse.mkSkeletonFromList. Edit source.",
    "raw_url": "/f/lib/systems/parse/mkSkeletonFromList.html",
    "excerpt": "lib.systems.parse.mkSkeletonFromList. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/parse/mkSystemFromString.html",
    "content": "lib.systems.parse.mkSystemFromString. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.parse.mkSystemFromString"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.parse.mkSystemFromString. Edit source.",
    "raw_url": "/f/lib/systems/parse/mkSystemFromString.html",
    "excerpt": "lib.systems.parse.mkSystemFromString. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/parse/gnuNetBSDDefaultExecFormat.html",
    "content": "lib.systems.parse.gnuNetBSDDefaultExecFormat. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.parse.gnuNetBSDDefaultExecFormat"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.parse.gnuNetBSDDefaultExecFormat. Edit source.",
    "raw_url": "/f/lib/systems/parse/gnuNetBSDDefaultExecFormat.html",
    "excerpt": "lib.systems.parse.gnuNetBSDDefaultExecFormat. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/platforms/select.html",
    "content": "lib.systems.platforms.select. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.platforms.select"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.platforms.select. Edit source.",
    "raw_url": "/f/lib/systems/platforms/select.html",
    "excerpt": "lib.systems.platforms.select. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/fma4Support.html",
    "content": "lib.systems.architectures.predicates.fma4Support.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.fma4Support"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.fma4Support.",
    "raw_url": "/f/lib/systems/architectures/predicates/fma4Support.html",
    "excerpt": "lib.systems.architectures.predicates.fma4Support.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/sse4_1Support.html",
    "content": "lib.systems.architectures.predicates.sse4_1Support.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.sse4_1Support"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.sse4_1Support.",
    "raw_url": "/f/lib/systems/architectures/predicates/sse4_1Support.html",
    "excerpt": "lib.systems.architectures.predicates.sse4_1Support.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/avx512Support.html",
    "content": "lib.systems.architectures.predicates.avx512Support.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.avx512Support"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.avx512Support.",
    "raw_url": "/f/lib/systems/architectures/predicates/avx512Support.html",
    "excerpt": "lib.systems.architectures.predicates.avx512Support.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/ssse3Support.html",
    "content": "lib.systems.architectures.predicates.ssse3Support.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.ssse3Support"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.ssse3Support.",
    "raw_url": "/f/lib/systems/architectures/predicates/ssse3Support.html",
    "excerpt": "lib.systems.architectures.predicates.ssse3Support.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/avxSupport.html",
    "content": "lib.systems.architectures.predicates.avxSupport.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.avxSupport"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.avxSupport.",
    "raw_url": "/f/lib/systems/architectures/predicates/avxSupport.html",
    "excerpt": "lib.systems.architectures.predicates.avxSupport.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/aesSupport.html",
    "content": "lib.systems.architectures.predicates.aesSupport.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.aesSupport"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.aesSupport.",
    "raw_url": "/f/lib/systems/architectures/predicates/aesSupport.html",
    "excerpt": "lib.systems.architectures.predicates.aesSupport.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/avx2Support.html",
    "content": "lib.systems.architectures.predicates.avx2Support.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.avx2Support"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.avx2Support.",
    "raw_url": "/f/lib/systems/architectures/predicates/avx2Support.html",
    "excerpt": "lib.systems.architectures.predicates.avx2Support.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/fmaSupport.html",
    "content": "lib.systems.architectures.predicates.fmaSupport.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.fmaSupport"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.fmaSupport.",
    "raw_url": "/f/lib/systems/architectures/predicates/fmaSupport.html",
    "excerpt": "lib.systems.architectures.predicates.fmaSupport.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/sse4_aSupport.html",
    "content": "lib.systems.architectures.predicates.sse4_aSupport.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.sse4_aSupport"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.sse4_aSupport.",
    "raw_url": "/f/lib/systems/architectures/predicates/sse4_aSupport.html",
    "excerpt": "lib.systems.architectures.predicates.sse4_aSupport.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/sse4_2Support.html",
    "content": "lib.systems.architectures.predicates.sse4_2Support.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.sse4_2Support"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.sse4_2Support.",
    "raw_url": "/f/lib/systems/architectures/predicates/sse4_2Support.html",
    "excerpt": "lib.systems.architectures.predicates.sse4_2Support.",
    "sub_results": []
  },
  {
    "url": "/f/lib/systems/architectures/predicates/sse3Support.html",
    "content": "lib.systems.architectures.predicates.sse3Support.",
    "word_count": 1,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.systems.architectures.predicates.sse3Support"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.systems.architectures.predicates.sse3Support.",
    "raw_url": "/f/lib/systems/architectures/predicates/sse3Support.html",
    "excerpt": "lib.systems.architectures.predicates.sse3Support.",
    "sub_results": []
  },
  {
    "url": "/f/lib/withFeature.html",
    "content": "lib.withFeature. Create an --{with,without}- string that can be passed to standard GNU Autoconf scripts. Example. withFeature true \"shared\" => \"--with-shared\" withFeature false \"shared\" => \"--without-shared\" Arguments. [flag] [feature] Edit source. Noogle also knows. Aliases. lib.strings.withFeature.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.withFeature"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.withFeature. Create an --{with,without}- string that can be passed to standard GNU Autoconf scripts. Example. withFeature true \"shared\" =&gt; \"--with-shared\" withFeature false \"shared\" =&gt; \"--without-shared\" Arguments. [flag] [feature] Edit source. Noogle also knows. Aliases. lib.strings.withFeature.",
    "raw_url": "/f/lib/withFeature.html",
    "excerpt": "lib.withFeature. Create an --{with,without}- string that can be passed to standard GNU Autoconf scripts. Example. withFeature true \"shared\" =&gt; \"--with-shared\" withFeature false \"shared\" =&gt; \"--without-shared\" Arguments. [flag] [feature] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/getVersion.html",
    "content": "lib.getVersion. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the version part from that argument. Example. getVersion \"youtube-dl-2016.01.01\" => \"2016.01.01\" getVersion pkgs.youtube-dl => \"2016.01.01\" Arguments. [x] Edit source. Noogle also knows. Aliases. lib.strings.getVersion.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getVersion"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getVersion. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the version part from that argument. Example. getVersion \"youtube-dl-2016.01.01\" =&gt; \"2016.01.01\" getVersion pkgs.youtube-dl =&gt; \"2016.01.01\" Arguments. [x] Edit source. Noogle also knows. Aliases. lib.strings.getVersion.",
    "raw_url": "/f/lib/getVersion.html",
    "excerpt": "lib.getVersion. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the version part from that argument. Example. getVersion \"youtube-dl-2016.01.01\" =&gt; \"2016.01.01\" getVersion pkgs.youtube-dl",
    "sub_results": []
  },
  {
    "url": "/f/lib/dischargeProperties.html",
    "content": "lib.dischargeProperties. Given a config value, expand mkMerge properties, and discharge any mkIf conditions. That is, this is the place where mkIf conditions are actually evaluated. The result is a list of config values. For example, ‘mkIf false x’ yields ‘[]’, ‘mkIf true x’ yields ‘[x]’, and mkMerge [ 1 (mkIf true 2) (mkIf true (mkIf false 3)) ] yields ‘[ 1 2 ]’. Arguments. [def] Edit source. Noogle also knows. Aliases. lib.modules.dischargeProperties.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.dischargeProperties"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 63
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.dischargeProperties. Given a config value, expand mkMerge properties, and discharge any mkIf conditions. That is, this is the place where mkIf conditions are actually evaluated. The result is a list of config values. For example, ‘mkIf false x’ yields ‘[]’, ‘mkIf true x’ yields ‘[x]’, and mkMerge [ 1 (mkIf true 2) (mkIf true (mkIf false 3)) ] yields ‘[ 1 2 ]’. Arguments. [def] Edit source. Noogle also knows. Aliases. lib.modules.dischargeProperties.",
    "raw_url": "/f/lib/dischargeProperties.html",
    "excerpt": "lib.dischargeProperties. Given a config value, expand mkMerge properties, and discharge any mkIf conditions. That is, this is the place where mkIf conditions are actually evaluated. The result is a list",
    "sub_results": []
  },
  {
    "url": "/f/lib/crossLists.html",
    "content": "lib.crossLists. Return the image of the cross product of some lists by a function. Example. crossLists (x:y: \"${toString x}${toString y}\") [[1 2] [3 4]] => [ \"13\" \"14\" \"23\" \"24\" ] Edit source. Noogle also knows. Aliases. lib.lists.crossLists.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.crossLists"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.crossLists. Return the image of the cross product of some lists by a function. Example. crossLists (x:y: \"${toString x}${toString y}\") [[1 2] [3 4]] =&gt; [ \"13\" \"14\" \"23\" \"24\" ] Edit source. Noogle also knows. Aliases. lib.lists.crossLists.",
    "raw_url": "/f/lib/crossLists.html",
    "excerpt": "lib.crossLists. Return the image of the cross product of some lists by a function. Example. crossLists (x:y: \"${toString x}${toString y}\") [[1 2] [3 4]] =&gt; [ \"13\" \"14\" \"23\" \"24\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkAssert.html",
    "content": "lib.mkAssert. Edit source. Noogle also knows. Aliases. lib.modules.mkAssert.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkAssert"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkAssert. Edit source. Noogle also knows. Aliases. lib.modules.mkAssert.",
    "raw_url": "/f/lib/mkAssert.html",
    "excerpt": "lib.mkAssert. Edit source. Noogle also knows. Aliases. lib.modules.mkAssert.",
    "sub_results": []
  },
  {
    "url": "/f/lib/foldlAttrs.html",
    "content": "lib.foldlAttrs. Like lib.lists.foldl' but for attribute sets. Iterates over every name-value pair in the given attribute set. The result of the callback function is often called acc for accumulator. It is passed between callbacks from left to right and the final acc is the return value of foldlAttrs. Attention: There is a completely different function lib.foldAttrs which has nothing to do with this function, despite the similar name. Example. foldlAttrs (acc: name: value: { sum = acc.sum + value; names = acc.names ++ [name]; }) { sum = 0; names = []; } { foo = 1; bar = 10; } -> { sum = 11; names = [\"bar\" \"foo\"]; } foldlAttrs (throw \"function not needed\") 123 {}; -> 123 foldlAttrs (acc: _: _: acc) 3 { z = throw \"value not needed\"; a = throw \"value not needed\"; }; -> 3 The accumulator doesn't have to be an attrset. It can be as simple as a number or string. foldlAttrs (acc: _: v: acc * 10 + v) 1 { z = 1; a = 2; }; -> 121 Type. foldlAttrs :: ( a -> String -> b -> a ) -> a -> { ... :: b } -> a Arguments. [f] [init] [set] Edit source. Noogle also knows. Aliases. lib.attrsets.foldlAttrs.",
    "word_count": 213,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.foldlAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 68
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 180
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 202
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.foldlAttrs. Like lib.lists.foldl' but for attribute sets. Iterates over every name-value pair in the given attribute set. The result of the callback function is often called acc for accumulator. It is passed between callbacks from left to right and the final acc is the return value of foldlAttrs. Attention: There is a completely different function lib.foldAttrs which has nothing to do with this function, despite the similar name. Example. foldlAttrs (acc: name: value: { sum = acc.sum + value; names = acc.names ++ [name]; }) { sum = 0; names = []; } { foo = 1; bar = 10; } -&gt; { sum = 11; names = [\"bar\" \"foo\"]; } foldlAttrs (throw \"function not needed\") 123 {}; -&gt; 123 foldlAttrs (acc: _: _: acc) 3 { z = throw \"value not needed\"; a = throw \"value not needed\"; }; -&gt; 3 The accumulator doesn't have to be an attrset. It can be as simple as a number or string. foldlAttrs (acc: _: v: acc * 10 + v) 1 { z = 1; a = 2; }; -&gt; 121 Type. foldlAttrs :: ( a -&gt; String -&gt; b -&gt; a ) -&gt; a -&gt; { ... :: b } -&gt; a Arguments. [f] [init] [set] Edit source. Noogle also knows. Aliases. lib.attrsets.foldlAttrs.",
    "raw_url": "/f/lib/foldlAttrs.html",
    "excerpt": "lib.foldlAttrs. Like lib.lists.foldl' but for attribute sets. Iterates over every name-value pair in the given attribute set. The result of the callback function is often called acc for accumulator. It",
    "sub_results": []
  },
  {
    "url": "/f/lib/splitByAndCompare.html",
    "content": "lib.splitByAndCompare. Split type into two subtypes by predicate p, take all elements of the first subtype to be less than all the elements of the second subtype, compare elements of a single subtype with yes and no respectively. Example. let cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in cmp \"a\" \"z\" => -1 cmp \"fooa\" \"fooz\" => -1 cmp \"f\" \"a\" => 1 cmp \"fooa\" \"a\" => -1 # while compare \"fooa\" \"a\" => 1 Type. (a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int) Arguments. [p] Predicate. [yes] Comparison function if predicate holds for both values. [no] Comparison function if predicate holds for neither value. [a] First value to compare. [b] Second value to compare. Edit source. Noogle also knows. Aliases. lib.trivial.splitByAndCompare.",
    "word_count": 135,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.splitByAndCompare"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 38
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 75
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 97
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.splitByAndCompare. Split type into two subtypes by predicate p, take all elements of the first subtype to be less than all the elements of the second subtype, compare elements of a single subtype with yes and no respectively. Example. let cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in cmp \"a\" \"z\" =&gt; -1 cmp \"fooa\" \"fooz\" =&gt; -1 cmp \"f\" \"a\" =&gt; 1 cmp \"fooa\" \"a\" =&gt; -1 # while compare \"fooa\" \"a\" =&gt; 1 Type. (a -&gt; bool) -&gt; (a -&gt; a -&gt; int) -&gt; (a -&gt; a -&gt; int) -&gt; (a -&gt; a -&gt; int) Arguments. [p] Predicate. [yes] Comparison function if predicate holds for both values. [no] Comparison function if predicate holds for neither value. [a] First value to compare. [b] Second value to compare. Edit source. Noogle also knows. Aliases. lib.trivial.splitByAndCompare.",
    "raw_url": "/f/lib/splitByAndCompare.html",
    "excerpt": "lib.splitByAndCompare. Split type into two subtypes by predicate p, take all elements of the first subtype to be less than all the elements of the second subtype, compare elements of",
    "sub_results": []
  },
  {
    "url": "/f/lib/matchAttrs.html",
    "content": "lib.matchAttrs. Returns true if the pattern is contained in the set. False otherwise. Example. matchAttrs { cpu = {}; } { cpu = { bits = 64; }; } => true Type. matchAttrs :: AttrSet -> AttrSet -> Bool Arguments. [pattern] Attribute set structure to match. [attrs] Attribute set to find patterns in. Edit source. Noogle also knows. Aliases. lib.attrsets.matchAttrs.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.matchAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.matchAttrs. Returns true if the pattern is contained in the set. False otherwise. Example. matchAttrs { cpu = {}; } { cpu = { bits = 64; }; } =&gt; true Type. matchAttrs :: AttrSet -&gt; AttrSet -&gt; Bool Arguments. [pattern] Attribute set structure to match. [attrs] Attribute set to find patterns in. Edit source. Noogle also knows. Aliases. lib.attrsets.matchAttrs.",
    "raw_url": "/f/lib/matchAttrs.html",
    "excerpt": "lib.matchAttrs. Returns true if the pattern is contained in the set. False otherwise. Example. matchAttrs { cpu = {}; } { cpu = { bits = 64; }; } =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/literalMD.html",
    "content": "lib.literalMD. For use in the defaultText and example option attributes. Causes the given MD text to be inserted verbatim in the documentation, for when a literalExpression would be too hard to read. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.options.literalMD.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.literalMD"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.literalMD. For use in the defaultText and example option attributes. Causes the given MD text to be inserted verbatim in the documentation, for when a literalExpression would be too hard to read. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.options.literalMD.",
    "raw_url": "/f/lib/literalMD.html",
    "excerpt": "lib.literalMD. For use in the defaultText and example option attributes. Causes the given MD text to be inserted verbatim in the documentation, for when a literalExpression would be too hard",
    "sub_results": []
  },
  {
    "url": "/f/lib/sortProperties.html",
    "content": "lib.sortProperties. Sort a list of properties. The sort priority of a property is defaultOrderPriority by default, but can be overridden by wrapping the property using mkOrder. Arguments. [defs] Edit source. Noogle also knows. Aliases. lib.modules.sortProperties.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sortProperties"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sortProperties. Sort a list of properties. The sort priority of a property is defaultOrderPriority by default, but can be overridden by wrapping the property using mkOrder. Arguments. [defs] Edit source. Noogle also knows. Aliases. lib.modules.sortProperties.",
    "raw_url": "/f/lib/sortProperties.html",
    "excerpt": "lib.sortProperties. Sort a list of properties. The sort priority of a property is defaultOrderPriority by default, but can be overridden by wrapping the property using mkOrder. Arguments. [defs] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkOrder.html",
    "content": "lib.mkOrder. Edit source. Noogle also knows. Aliases. lib.modules.mkOrder.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkOrder"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkOrder. Edit source. Noogle also knows. Aliases. lib.modules.mkOrder.",
    "raw_url": "/f/lib/mkOrder.html",
    "excerpt": "lib.mkOrder. Edit source. Noogle also knows. Aliases. lib.modules.mkOrder.",
    "sub_results": []
  },
  {
    "url": "/f/lib/hiPrio.html",
    "content": "lib.hiPrio. Increase the nix-env priority of the package, i.e., this version/variant of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.meta.hiPrio. pkgs.hiPrio.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.hiPrio"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.hiPrio. Increase the nix-env priority of the package, i.e., this version/variant of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.meta.hiPrio. pkgs.hiPrio.",
    "raw_url": "/f/lib/hiPrio.html",
    "excerpt": "lib.hiPrio. Increase the nix-env priority of the package, i.e., this version/variant of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.meta.hiPrio. pkgs.hiPrio.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkAliasOptionModuleMD.html",
    "content": "lib.mkAliasOptionModuleMD. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.modules.mkAliasOptionModuleMD.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkAliasOptionModuleMD"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkAliasOptionModuleMD. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.modules.mkAliasOptionModuleMD.",
    "raw_url": "/f/lib/mkAliasOptionModuleMD.html",
    "excerpt": "lib.mkAliasOptionModuleMD. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.modules.mkAliasOptionModuleMD.",
    "sub_results": []
  },
  {
    "url": "/f/lib/versionOlder.html",
    "content": "lib.versionOlder. Return true if string v1 denotes a version older than v2. Example. versionOlder \"1.1\" \"1.2\" => true versionOlder \"1.1\" \"1.1\" => false Arguments. [v1] [v2] Edit source. Noogle also knows. Aliases. lib.strings.versionOlder.",
    "word_count": 33,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.versionOlder"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 23
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.versionOlder. Return true if string v1 denotes a version older than v2. Example. versionOlder \"1.1\" \"1.2\" =&gt; true versionOlder \"1.1\" \"1.1\" =&gt; false Arguments. [v1] [v2] Edit source. Noogle also knows. Aliases. lib.strings.versionOlder.",
    "raw_url": "/f/lib/versionOlder.html",
    "excerpt": "lib.versionOlder. Return true if string v1 denotes a version older than v2. Example. versionOlder \"1.1\" \"1.2\" =&gt; true versionOlder \"1.1\" \"1.1\" =&gt; false Arguments. [v1] [v2] Edit source. Noogle also",
    "sub_results": []
  },
  {
    "url": "/f/lib/mapAttrsFlatten.html",
    "content": "lib.mapAttrsFlatten. Edit source. Noogle also knows. Aliases. lib.misc.mapAttrsFlatten.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mapAttrsFlatten"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mapAttrsFlatten. Edit source. Noogle also knows. Aliases. lib.misc.mapAttrsFlatten.",
    "raw_url": "/f/lib/mapAttrsFlatten.html",
    "excerpt": "lib.mapAttrsFlatten. Edit source. Noogle also knows. Aliases. lib.misc.mapAttrsFlatten.",
    "sub_results": []
  },
  {
    "url": "/f/lib/withFeatureAs.html",
    "content": "lib.withFeatureAs. Create an --{with-=,without-} string that can be passed to standard GNU Autoconf scripts. Example. withFeatureAs true \"shared\" \"foo\" => \"--with-shared=foo\" withFeatureAs false \"shared\" (throw \"ignored\") => \"--without-shared\" Arguments. [flag] [feature] [value] Edit source. Noogle also knows. Aliases. lib.strings.withFeatureAs.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.withFeatureAs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 28
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.withFeatureAs. Create an --{with-=,without-} string that can be passed to standard GNU Autoconf scripts. Example. withFeatureAs true \"shared\" \"foo\" =&gt; \"--with-shared=foo\" withFeatureAs false \"shared\" (throw \"ignored\") =&gt; \"--without-shared\" Arguments. [flag] [feature] [value] Edit source. Noogle also knows. Aliases. lib.strings.withFeatureAs.",
    "raw_url": "/f/lib/withFeatureAs.html",
    "excerpt": "lib.withFeatureAs. Create an --{with-=,without-} string that can be passed to standard GNU Autoconf scripts. Example. withFeatureAs true \"shared\" \"foo\" =&gt; \"--with-shared=foo\" withFeatureAs false \"shared\" (throw \"ignored\") =&gt; \"--without-shared\" Arguments. [flag]",
    "sub_results": []
  },
  {
    "url": "/f/lib/setDefaultModuleLocation.html",
    "content": "lib.setDefaultModuleLocation. Wrap a module with a default location for reporting errors. Arguments. [file] [m] Edit source. Noogle also knows. Aliases. lib.modules.setDefaultModuleLocation.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.setDefaultModuleLocation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.setDefaultModuleLocation. Wrap a module with a default location for reporting errors. Arguments. [file] [m] Edit source. Noogle also knows. Aliases. lib.modules.setDefaultModuleLocation.",
    "raw_url": "/f/lib/setDefaultModuleLocation.html",
    "excerpt": "lib.setDefaultModuleLocation. Wrap a module with a default location for reporting errors. Arguments. [file] [m] Edit source. Noogle also knows. Aliases. lib.modules.setDefaultModuleLocation.",
    "sub_results": []
  },
  {
    "url": "/f/lib/sort.html",
    "content": "lib.sort Primop. Takes 2 arguments. comparator, list. Sort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the second argument. The returned list is sorted in an increasing order. The implementation does a quick-sort. Example. sort (a: b: a < b) [ 5 3 7 ] => [ 3 5 7 ] Edit source. Noogle also knows. Aliases. builtins.sort. lib.lists.sort.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sort Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 46
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sort Primop. Takes 2 arguments. comparator, list. Sort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the second argument. The returned list is sorted in an increasing order. The implementation does a quick-sort. Example. sort (a: b: a &lt; b) [ 5 3 7 ] =&gt; [ 3 5 7 ] Edit source. Noogle also knows. Aliases. builtins.sort. lib.lists.sort.",
    "raw_url": "/f/lib/sort.html",
    "excerpt": "lib.sort Primop. Takes 2 arguments. comparator, list. Sort a list based on a comparator function which compares two elements and returns true if the first argument is strictly below the",
    "sub_results": []
  },
  {
    "url": "/f/lib/filterAttrsRecursive.html",
    "content": "lib.filterAttrsRecursive. Filter an attribute set recursively by removing all attributes for which the given predicate return false. Example. filterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; } => { foo = {}; } Type. filterAttrsRecursive :: (String -> Any -> Bool) -> AttrSet -> AttrSet Arguments. [pred] Predicate taking an attribute name and an attribute value, which returns true to include the attribute, or false to exclude the attribute. [set] The attribute set to filter. Edit source. Noogle also knows. Aliases. lib.attrsets.filterAttrsRecursive.",
    "word_count": 88,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.filterAttrsRecursive"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 39
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 51
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.filterAttrsRecursive. Filter an attribute set recursively by removing all attributes for which the given predicate return false. Example. filterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; } =&gt; { foo = {}; } Type. filterAttrsRecursive :: (String -&gt; Any -&gt; Bool) -&gt; AttrSet -&gt; AttrSet Arguments. [pred] Predicate taking an attribute name and an attribute value, which returns true to include the attribute, or false to exclude the attribute. [set] The attribute set to filter. Edit source. Noogle also knows. Aliases. lib.attrsets.filterAttrsRecursive.",
    "raw_url": "/f/lib/filterAttrsRecursive.html",
    "excerpt": "lib.filterAttrsRecursive. Filter an attribute set recursively by removing all attributes for which the given predicate return false. Example. filterAttrsRecursive (n: v: v != null) { foo = { bar =",
    "sub_results": []
  },
  {
    "url": "/f/lib/length.html",
    "content": "lib.length Primop. Takes 1 arguments. e. Return the length of the list e. Noogle also knows. Aliases. builtins.length. lib.lists.length.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.length Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.length Primop. Takes 1 arguments. e. Return the length of the list e. Noogle also knows. Aliases. builtins.length. lib.lists.length.",
    "raw_url": "/f/lib/length.html",
    "excerpt": "lib.length Primop. Takes 1 arguments. e. Return the length of the list e. Noogle also knows. Aliases. builtins.length. lib.lists.length.",
    "sub_results": []
  },
  {
    "url": "/f/lib/textClosureList.html",
    "content": "lib.textClosureList. !!! The interface of this function is kind of messed up, since it's way too overloaded and almost but not quite computes a topological sort of the depstrings. Arguments. [predefined] [arg] Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.textClosureList.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.textClosureList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.textClosureList. !!! The interface of this function is kind of messed up, since it's way too overloaded and almost but not quite computes a topological sort of the depstrings. Arguments. [predefined] [arg] Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.textClosureList.",
    "raw_url": "/f/lib/textClosureList.html",
    "excerpt": "lib.textClosureList. !!! The interface of this function is kind of messed up, since it's way too overloaded and almost but not quite computes a topological sort of the depstrings. Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/traceFnSeqN.html",
    "content": "lib.traceFnSeqN. Trace the input and output of a function f named name, both down to depth. This is useful for adding around a function call, to see the before/after of values as they are transformed. Example. traceFnSeqN 2 \"id\" (x: x) { a.b.c = 3; } trace: { fn = \"id\"; from = { a.b = {…}; }; to = { a.b = {…}; }; } => { a.b.c = 3; } Arguments. [depth] [name] [f] [v] Edit source. Noogle also knows. Aliases. lib.debug.traceFnSeqN.",
    "word_count": 84,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.traceFnSeqN"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 35
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 72
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.traceFnSeqN. Trace the input and output of a function f named name, both down to depth. This is useful for adding around a function call, to see the before/after of values as they are transformed. Example. traceFnSeqN 2 \"id\" (x: x) { a.b.c = 3; } trace: { fn = \"id\"; from = { a.b = {…}; }; to = { a.b = {…}; }; } =&gt; { a.b.c = 3; } Arguments. [depth] [name] [f] [v] Edit source. Noogle also knows. Aliases. lib.debug.traceFnSeqN.",
    "raw_url": "/f/lib/traceFnSeqN.html",
    "excerpt": "lib.traceFnSeqN. Trace the input and output of a function f named name, both down to depth. This is useful for adding around a function call, to see the before/after of",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixupOptionType.html",
    "content": "lib.fixupOptionType. Edit source. Noogle also knows. Aliases. lib.modules.fixupOptionType.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixupOptionType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixupOptionType. Edit source. Noogle also knows. Aliases. lib.modules.fixupOptionType.",
    "raw_url": "/f/lib/fixupOptionType.html",
    "excerpt": "lib.fixupOptionType. Edit source. Noogle also knows. Aliases. lib.modules.fixupOptionType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/substring.html",
    "content": "lib.substring Primop. Takes 3 arguments. start, len, s. Return the substring of s from character position start (zero-based) up to but not including start + len. If start is greater than the length of the string, an empty string is returned, and if start + len lies beyond the end of the string, only the substring up to the end of the string is returned. start must be non-negative. For example, builtins.substring 0 3 \"nixos\" evaluates to \"nix\". Noogle also knows. Aliases. builtins.substring. lib.strings.substring.",
    "word_count": 84,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.substring Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.substring Primop. Takes 3 arguments. start, len, s. Return the substring of s from character position start (zero-based) up to but not including start + len. If start is greater than the length of the string, an empty string is returned, and if start + len lies beyond the end of the string, only the substring up to the end of the string is returned. start must be non-negative. For example, builtins.substring 0 3 \"nixos\" evaluates to \"nix\". Noogle also knows. Aliases. builtins.substring. lib.strings.substring.",
    "raw_url": "/f/lib/substring.html",
    "excerpt": "lib.substring Primop. Takes 3 arguments. start, len, s. Return the substring of s from character position start (zero-based) up to but not including start + len. If start is greater",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixedPoints/converge.html",
    "content": "lib.fixedPoints.converge. Return the fixpoint that f converges to when called iteratively, starting with the input x. nix-repl> converge (x: x / 2) 16 0 Type. (a -> a) -> a -> a Arguments. [f] [x] Edit source. Noogle also knows. Aliases. lib.converge.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixedPoints.converge"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 24
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixedPoints.converge. Return the fixpoint that f converges to when called iteratively, starting with the input x. nix-repl&gt; converge (x: x / 2) 16 0 Type. (a -&gt; a) -&gt; a -&gt; a Arguments. [f] [x] Edit source. Noogle also knows. Aliases. lib.converge.",
    "raw_url": "/f/lib/fixedPoints/converge.html",
    "excerpt": "lib.fixedPoints.converge. Return the fixpoint that f converges to when called iteratively, starting with the input x. nix-repl&gt; converge (x: x / 2) 16 0 Type. (a -&gt; a) -&gt; a",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixedPoints/fix'.html",
    "content": "lib.fixedPoints.fix' (Prime). A variant of fix that records the original recursive attribute set in the result, in an attribute named __unfix__. This is useful in combination with the extends function to implement deep overriding. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.fix'",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixedPoints.fix' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 34
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixedPoints.fix' (Prime). A variant of fix that records the original recursive attribute set in the result, in an attribute named __unfix__. This is useful in combination with the extends function to implement deep overriding. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.fix'",
    "raw_url": "/f/lib/fixedPoints/fix'.html",
    "excerpt": "lib.fixedPoints.fix' (Prime). A variant of fix that records the original recursive attribute set in the result, in an attribute named __unfix__. This is useful in combination with the extends function",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixedPoints/makeExtensible.html",
    "content": "lib.fixedPoints.makeExtensible. Create an overridable, recursive attribute set. For example: nix-repl> obj = makeExtensible (self: { }) nix-repl> obj { __unfix__ = «lambda»; extend = «lambda»; } nix-repl> obj = obj.extend (self: super: { foo = \"foo\"; }) nix-repl> obj { __unfix__ = «lambda»; extend = «lambda»; foo = \"foo\"; } nix-repl> obj = obj.extend (self: super: { foo = super.foo + \" + \"; bar = \"bar\"; foobar = self.foo + self.bar; }) nix-repl> obj { __unfix__ = «lambda»; bar = \"bar\"; extend = «lambda»; foo = \"foo + \"; foobar = \"foo + bar\"; } Edit source. Noogle also knows. Aliases. lib.makeExtensible.",
    "word_count": 103,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixedPoints.makeExtensible"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixedPoints.makeExtensible. Create an overridable, recursive attribute set. For example: nix-repl&gt; obj = makeExtensible (self: { }) nix-repl&gt; obj { __unfix__ = «lambda»; extend = «lambda»; } nix-repl&gt; obj = obj.extend (self: super: { foo = \"foo\"; }) nix-repl&gt; obj { __unfix__ = «lambda»; extend = «lambda»; foo = \"foo\"; } nix-repl&gt; obj = obj.extend (self: super: { foo = super.foo + \" + \"; bar = \"bar\"; foobar = self.foo + self.bar; }) nix-repl&gt; obj { __unfix__ = «lambda»; bar = \"bar\"; extend = «lambda»; foo = \"foo + \"; foobar = \"foo + bar\"; } Edit source. Noogle also knows. Aliases. lib.makeExtensible.",
    "raw_url": "/f/lib/fixedPoints/makeExtensible.html",
    "excerpt": "lib.fixedPoints.makeExtensible. Create an overridable, recursive attribute set. For example: nix-repl&gt; obj = makeExtensible (self: { }) nix-repl&gt; obj { __unfix__ = «lambda»; extend = «lambda»; } nix-repl&gt; obj = obj.extend",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixedPoints/makeExtensibleWithCustomName.html",
    "content": "lib.fixedPoints.makeExtensibleWithCustomName. Same as makeExtensible but the name of the extending attribute is customized. Arguments. [extenderName] [rattrs] Edit source. Noogle also knows. Aliases. lib.makeExtensibleWithCustomName.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixedPoints.makeExtensibleWithCustomName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 13
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixedPoints.makeExtensibleWithCustomName. Same as makeExtensible but the name of the extending attribute is customized. Arguments. [extenderName] [rattrs] Edit source. Noogle also knows. Aliases. lib.makeExtensibleWithCustomName.",
    "raw_url": "/f/lib/fixedPoints/makeExtensibleWithCustomName.html",
    "excerpt": "lib.fixedPoints.makeExtensibleWithCustomName. Same as makeExtensible but the name of the extending attribute is customized. Arguments. [extenderName] [rattrs] Edit source. Noogle also knows. Aliases. lib.makeExtensibleWithCustomName.",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixedPoints/composeManyExtensions.html",
    "content": "lib.fixedPoints.composeManyExtensions. Compose several extending functions of the type expected by 'extends' into one where changes made in preceding functions are made available to subsequent ones. composeManyExtensions : [packageSet -> packageSet -> packageSet] -> packageSet -> packageSet -> packageSet ^final ^prev ^overrides ^final ^prev ^overrides Edit source. Noogle also knows. Aliases. lib.composeManyExtensions.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixedPoints.composeManyExtensions"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixedPoints.composeManyExtensions. Compose several extending functions of the type expected by 'extends' into one where changes made in preceding functions are made available to subsequent ones. composeManyExtensions : [packageSet -&gt; packageSet -&gt; packageSet] -&gt; packageSet -&gt; packageSet -&gt; packageSet ^final ^prev ^overrides ^final ^prev ^overrides Edit source. Noogle also knows. Aliases. lib.composeManyExtensions.",
    "raw_url": "/f/lib/fixedPoints/composeManyExtensions.html",
    "excerpt": "lib.fixedPoints.composeManyExtensions. Compose several extending functions of the type expected by 'extends' into one where changes made in preceding functions are made available to subsequent ones. composeManyExtensions : [packageSet -&gt; packageSet",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixedPoints/composeExtensions.html",
    "content": "lib.fixedPoints.composeExtensions. Compose two extending functions of the type expected by 'extends' into one where changes made in the first are available in the 'super' of the second. Arguments. [f] [g] [final] [prev] Edit source. Noogle also knows. Aliases. lib.composeExtensions.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixedPoints.composeExtensions"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixedPoints.composeExtensions. Compose two extending functions of the type expected by 'extends' into one where changes made in the first are available in the 'super' of the second. Arguments. [f] [g] [final] [prev] Edit source. Noogle also knows. Aliases. lib.composeExtensions.",
    "raw_url": "/f/lib/fixedPoints/composeExtensions.html",
    "excerpt": "lib.fixedPoints.composeExtensions. Compose two extending functions of the type expected by 'extends' into one where changes made in the first are available in the 'super' of the second. Arguments. [f] [g]",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixedPoints/fix.html",
    "content": "lib.fixedPoints.fix. fix f computes the fixed point of the given function f. In other words, the return value is x in x = f x. f must be a lazy function. This means that x must be a value that can be partially evaluated, such as an attribute set, a list, or a function. This way, f can use one part of x to compute another part. Relation to syntactic recursion This section explains fix by refactoring from syntactic recursion to a call of fix instead. For context, Nix lets you define attributes in terms of other attributes syntactically using the rec { } syntax. nix-repl> rec { foo = \"foo\"; bar = \"bar\"; foobar = foo + bar; } { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } This is convenient when constructing a value to pass to a function for example, but an equivalent effect can be achieved with the let binding syntax: nix-repl> let self = { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }; in self { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } But in general you can get more reuse out of let bindings by refactoring them to a function. nix-repl> f = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } This is where fix comes in, it contains the syntactic recursion that's not in f anymore. nix-repl> fix = f: let self = f self; in self; By applying fix we get the final result. nix-repl> fix f { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } Such a refactored f using fix is not useful by itself. See extends for an example use case. There self is also often called final. Example. fix (self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }) => { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } fix (self: [ 1 2 (elemAt self 0 + elemAt self 1) ]) => [ 1 2 3 ] Type. fix :: (a -> a) -> a Arguments. [f] Edit source. Noogle also knows. Aliases. lib.fix.",
    "word_count": 360,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixedPoints.fix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 296
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 343
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 351
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixedPoints.fix. fix f computes the fixed point of the given function f. In other words, the return value is x in x = f x. f must be a lazy function. This means that x must be a value that can be partially evaluated, such as an attribute set, a list, or a function. This way, f can use one part of x to compute another part. Relation to syntactic recursion This section explains fix by refactoring from syntactic recursion to a call of fix instead. For context, Nix lets you define attributes in terms of other attributes syntactically using the rec { } syntax. nix-repl&gt; rec { foo = \"foo\"; bar = \"bar\"; foobar = foo + bar; } { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } This is convenient when constructing a value to pass to a function for example, but an equivalent effect can be achieved with the let binding syntax: nix-repl&gt; let self = { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }; in self { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } But in general you can get more reuse out of let bindings by refactoring them to a function. nix-repl&gt; f = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } This is where fix comes in, it contains the syntactic recursion that's not in f anymore. nix-repl&gt; fix = f: let self = f self; in self; By applying fix we get the final result. nix-repl&gt; fix f { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } Such a refactored f using fix is not useful by itself. See extends for an example use case. There self is also often called final. Example. fix (self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }) =&gt; { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } fix (self: [ 1 2 (elemAt self 0 + elemAt self 1) ]) =&gt; [ 1 2 3 ] Type. fix :: (a -&gt; a) -&gt; a Arguments. [f] Edit source. Noogle also knows. Aliases. lib.fix.",
    "raw_url": "/f/lib/fixedPoints/fix.html",
    "excerpt": "lib.fixedPoints.fix. fix f computes the fixed point of the given function f. In other words, the return value is x in x = f x. f must be a lazy",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixedPoints/extends.html",
    "content": "lib.fixedPoints.extends. Modify the contents of an explicitly recursive attribute set in a way that honors self-references. This is accomplished with a function. g = self: super: { foo = super.foo + \" + \"; } that has access to the unmodified input (super) as well as the final non-recursive representation of the attribute set (self). extends differs from the native // operator insofar as that it's applied before references to self are resolved: nix-repl> fix (extends g f) { bar = \"bar\"; foo = \"foo + \"; foobar = \"foo + bar\"; } The name of the function is inspired by object-oriented inheritance, i.e. think of it as an infix operator g extends f that mimics the syntax from Java. It may seem counter-intuitive to have the \"base class\" as the second argument, but it's nice this way if several uses of extends are cascaded. To get a better understanding how extends turns a function with a fix point (the package set we start with) into a new function with a different fix point (the desired packages set) lets just see, how extends g f unfolds with g and f defined above: extends g f = self: let super = f self; in super // g self super; = self: let super = { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }; in super // g self super = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } // g self { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } // { foo = \"foo\" + \" + \"; } = self: { foo = \"foo + \"; bar = \"bar\"; foobar = self.foo + self.bar; } Arguments. [f] [rattrs] [self] Edit source. Noogle also knows. Aliases. lib.extends.",
    "word_count": 316,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixedPoints.extends"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 305
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixedPoints.extends. Modify the contents of an explicitly recursive attribute set in a way that honors self-references. This is accomplished with a function. g = self: super: { foo = super.foo + \" + \"; } that has access to the unmodified input (super) as well as the final non-recursive representation of the attribute set (self). extends differs from the native // operator insofar as that it's applied before references to self are resolved: nix-repl&gt; fix (extends g f) { bar = \"bar\"; foo = \"foo + \"; foobar = \"foo + bar\"; } The name of the function is inspired by object-oriented inheritance, i.e. think of it as an infix operator g extends f that mimics the syntax from Java. It may seem counter-intuitive to have the \"base class\" as the second argument, but it's nice this way if several uses of extends are cascaded. To get a better understanding how extends turns a function with a fix point (the package set we start with) into a new function with a different fix point (the desired packages set) lets just see, how extends g f unfolds with g and f defined above: extends g f = self: let super = f self; in super // g self super; = self: let super = { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }; in super // g self super = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } // g self { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } // { foo = \"foo\" + \" + \"; } = self: { foo = \"foo + \"; bar = \"bar\"; foobar = self.foo + self.bar; } Arguments. [f] [rattrs] [self] Edit source. Noogle also knows. Aliases. lib.extends.",
    "raw_url": "/f/lib/fixedPoints/extends.html",
    "excerpt": "lib.fixedPoints.extends. Modify the contents of an explicitly recursive attribute set in a way that honors self-references. This is accomplished with a function. g = self: super: { foo = super.foo",
    "sub_results": []
  },
  {
    "url": "/f/lib/findFirst.html",
    "content": "lib.findFirst. Find the first element in the list matching the specified predicate or return default if no such element exists. Example. findFirst (x: x > 3) 7 [ 1 6 4 ] => 6 findFirst (x: x > 9) 7 [ 1 6 4 ] => 7 Type. findFirst :: (a -> bool) -> a -> [a] -> a Arguments. [pred] Predicate. [default] Default value to return. [list] Input list. Edit source. Noogle also knows. Aliases. lib.lists.findFirst.",
    "word_count": 77,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.findFirst"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 59
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.findFirst. Find the first element in the list matching the specified predicate or return default if no such element exists. Example. findFirst (x: x &gt; 3) 7 [ 1 6 4 ] =&gt; 6 findFirst (x: x &gt; 9) 7 [ 1 6 4 ] =&gt; 7 Type. findFirst :: (a -&gt; bool) -&gt; a -&gt; [a] -&gt; a Arguments. [pred] Predicate. [default] Default value to return. [list] Input list. Edit source. Noogle also knows. Aliases. lib.lists.findFirst.",
    "raw_url": "/f/lib/findFirst.html",
    "excerpt": "lib.findFirst. Find the first element in the list matching the specified predicate or return default if no such element exists. Example. findFirst (x: x &gt; 3) 7 [ 1 6",
    "sub_results": []
  },
  {
    "url": "/f/lib/enableFeature.html",
    "content": "lib.enableFeature. Create an --{enable,disable}- string that can be passed to standard GNU Autoconf scripts. Example. enableFeature true \"shared\" => \"--enable-shared\" enableFeature false \"shared\" => \"--disable-shared\" Arguments. [flag] [feature] Edit source. Noogle also knows. Aliases. lib.strings.enableFeature.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.enableFeature"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.enableFeature. Create an --{enable,disable}- string that can be passed to standard GNU Autoconf scripts. Example. enableFeature true \"shared\" =&gt; \"--enable-shared\" enableFeature false \"shared\" =&gt; \"--disable-shared\" Arguments. [flag] [feature] Edit source. Noogle also knows. Aliases. lib.strings.enableFeature.",
    "raw_url": "/f/lib/enableFeature.html",
    "excerpt": "lib.enableFeature. Create an --{enable,disable}- string that can be passed to standard GNU Autoconf scripts. Example. enableFeature true \"shared\" =&gt; \"--enable-shared\" enableFeature false \"shared\" =&gt; \"--disable-shared\" Arguments. [flag] [feature] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/escape.html",
    "content": "lib.strings.escape. Escape occurrence of the elements of list in string by prefixing it with a backslash. Example. escape [\"(\" \")\"] \"(foo)\" => \"\\\\(foo\\\\)\" Type. escape :: [string] -> string -> string Arguments. [list] Edit source. Noogle also knows. Aliases. lib.escape.",
    "word_count": 40,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.escape"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 31
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.escape. Escape occurrence of the elements of list in string by prefixing it with a backslash. Example. escape [\"(\" \")\"] \"(foo)\" =&gt; \"\\\\(foo\\\\)\" Type. escape :: [string] -&gt; string -&gt; string Arguments. [list] Edit source. Noogle also knows. Aliases. lib.escape.",
    "raw_url": "/f/lib/strings/escape.html",
    "excerpt": "lib.strings.escape. Escape occurrence of the elements of list in string by prefixing it with a backslash. Example. escape [\"(\" \")\"] \"(foo)\" =&gt; \"\\\\(foo\\\\)\" Type. escape :: [string] -&gt; string -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/genList.html",
    "content": "lib.strings.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x * x) 5 returns the list [ 0 1 4 9 16 ]. Noogle also knows. Aliases. builtins.genList. lib.genList. lib.lists.genList.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.genList Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x * x) 5 returns the list [ 0 1 4 9 16 ]. Noogle also knows. Aliases. builtins.genList. lib.genList. lib.lists.genList.",
    "raw_url": "/f/lib/strings/genList.html",
    "excerpt": "lib.strings.genList Primop. Takes 2 arguments. generator, length. Generate list of size length, with each element i equal to the value returned by generator i. For example, builtins.genList (x: x *",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/escapeNixIdentifier.html",
    "content": "lib.strings.escapeNixIdentifier. Quotes a string if it can't be used as an identifier directly. Example. escapeNixIdentifier \"hello\" => \"hello\" escapeNixIdentifier \"0abc\" => \"\\\"0abc\\\"\" Type. string -> string Arguments. [s] Edit source.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.escapeNixIdentifier"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.escapeNixIdentifier. Quotes a string if it can't be used as an identifier directly. Example. escapeNixIdentifier \"hello\" =&gt; \"hello\" escapeNixIdentifier \"0abc\" =&gt; \"\\\"0abc\\\"\" Type. string -&gt; string Arguments. [s] Edit source.",
    "raw_url": "/f/lib/strings/escapeNixIdentifier.html",
    "excerpt": "lib.strings.escapeNixIdentifier. Quotes a string if it can't be used as an identifier directly. Example. escapeNixIdentifier \"hello\" =&gt; \"hello\" escapeNixIdentifier \"0abc\" =&gt; \"\\\"0abc\\\"\" Type. string -&gt; string Arguments. [s] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/toJSON.html",
    "content": "lib.strings.toJSON Primop. Takes 1 arguments. e. Return a string containing a JSON representation of e. Strings, integers, floats, booleans, nulls and lists are mapped to their JSON equivalents. Sets (except derivations) are represented as objects. Derivations are translated to a JSON string containing the derivation’s output path. Paths are copied to the store and represented as a JSON string of the resulting store path. Noogle also knows. Aliases. builtins.toJSON.",
    "word_count": 69,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.toJSON Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.toJSON Primop. Takes 1 arguments. e. Return a string containing a JSON representation of e. Strings, integers, floats, booleans, nulls and lists are mapped to their JSON equivalents. Sets (except derivations) are represented as objects. Derivations are translated to a JSON string containing the derivation’s output path. Paths are copied to the store and represented as a JSON string of the resulting store path. Noogle also knows. Aliases. builtins.toJSON.",
    "raw_url": "/f/lib/strings/toJSON.html",
    "excerpt": "lib.strings.toJSON Primop. Takes 1 arguments. e. Return a string containing a JSON representation of e. Strings, integers, floats, booleans, nulls and lists are mapped to their JSON equivalents. Sets (except",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/replicate.html",
    "content": "lib.strings.replicate. Replicate a string n times, and concatenate the parts into a new string. Example. replicate 3 \"v\" => \"vvv\" replicate 5 \"hello\" => \"hellohellohellohellohello\" Type. replicate :: int -> string -> string Arguments. [n] [s] Edit source. Noogle also knows. Aliases. lib.replicate. lib.lists.replicate.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.replicate"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 33
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.replicate. Replicate a string n times, and concatenate the parts into a new string. Example. replicate 3 \"v\" =&gt; \"vvv\" replicate 5 \"hello\" =&gt; \"hellohellohellohellohello\" Type. replicate :: int -&gt; string -&gt; string Arguments. [n] [s] Edit source. Noogle also knows. Aliases. lib.replicate. lib.lists.replicate.",
    "raw_url": "/f/lib/strings/replicate.html",
    "excerpt": "lib.strings.replicate. Replicate a string n times, and concatenate the parts into a new string. Example. replicate 3 \"v\" =&gt; \"vvv\" replicate 5 \"hello\" =&gt; \"hellohellohellohellohello\" Type. replicate :: int -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/nameFromURL.html",
    "content": "lib.strings.nameFromURL. Extract name with version from URL. Ask for separator which is supposed to start extension. Example. nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"-\" => \"nix\" nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"_\" => \"nix-1.7-x86\" Arguments. [url] [sep] Edit source. Noogle also knows. Aliases. lib.nameFromURL.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.nameFromURL"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.nameFromURL. Extract name with version from URL. Ask for separator which is supposed to start extension. Example. nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"-\" =&gt; \"nix\" nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"_\" =&gt; \"nix-1.7-x86\" Arguments. [url] [sep] Edit source. Noogle also knows. Aliases. lib.nameFromURL.",
    "raw_url": "/f/lib/strings/nameFromURL.html",
    "excerpt": "lib.strings.nameFromURL. Extract name with version from URL. Ask for separator which is supposed to start extension. Example. nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"-\" =&gt; \"nix\" nameFromURL \"https://nixos.org/releases/nix/nix-1.7/nix-1.7-x86_64-linux.tar.bz2\" \"_\" =&gt; \"nix-1.7-x86\" Arguments. [url] [sep]",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/makeLibraryPath.html",
    "content": "lib.strings.makeLibraryPath. Construct a library search path (such as RPATH) containing the libraries for a set of packages. Example. makeLibraryPath [ \"/usr\" \"/usr/local\" ] => \"/usr/lib:/usr/local/lib\" pkgs = import <nixpkgs> { } makeLibraryPath [ pkgs.openssl pkgs.zlib ] => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r/lib:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/lib\" Edit source. Noogle also knows. Aliases. lib.makeLibraryPath.",
    "word_count": 45,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.makeLibraryPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.makeLibraryPath. Construct a library search path (such as RPATH) containing the libraries for a set of packages. Example. makeLibraryPath [ \"/usr\" \"/usr/local\" ] =&gt; \"/usr/lib:/usr/local/lib\" pkgs = import &lt;nixpkgs&gt; { } makeLibraryPath [ pkgs.openssl pkgs.zlib ] =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r/lib:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/lib\" Edit source. Noogle also knows. Aliases. lib.makeLibraryPath.",
    "raw_url": "/f/lib/strings/makeLibraryPath.html",
    "excerpt": "lib.strings.makeLibraryPath. Construct a library search path (such as RPATH) containing the libraries for a set of packages. Example. makeLibraryPath [ \"/usr\" \"/usr/local\" ] =&gt; \"/usr/lib:/usr/local/lib\" pkgs = import &lt;nixpkgs&gt; {",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/escapeURL.html",
    "content": "lib.strings.escapeURL. Escape the string so it can be safely placed inside a URL query. Example. escapeURL \"foo/bar baz\" => \"foo%2Fbar%20baz\" Type. escapeURL :: string -> string Edit source. Noogle also knows. Aliases. lib.escapeURL.",
    "word_count": 33,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.escapeURL"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.escapeURL. Escape the string so it can be safely placed inside a URL query. Example. escapeURL \"foo/bar baz\" =&gt; \"foo%2Fbar%20baz\" Type. escapeURL :: string -&gt; string Edit source. Noogle also knows. Aliases. lib.escapeURL.",
    "raw_url": "/f/lib/strings/escapeURL.html",
    "excerpt": "lib.strings.escapeURL. Escape the string so it can be safely placed inside a URL query. Example. escapeURL \"foo/bar baz\" =&gt; \"foo%2Fbar%20baz\" Type. escapeURL :: string -&gt; string Edit source. Noogle also",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/cmakeOptionType.html",
    "content": "lib.strings.cmakeOptionType. Create a \"-D:=\" string that can be passed to typical CMake invocations. Example. cmakeOptionType \"string\" \"ENGINE\" \"sdl2\" => \"-DENGINE:STRING=sdl2\" Type. cmakeOptionType :: string -> string -> string -> string @param feature The feature to be set @param type The type of the feature to be set, as described in https://cmake.org/cmake/help/latest/command/set.html the possible values (case insensitive) are: BOOL FILEPATH PATH STRING INTERNAL @param value The desired value Arguments. [type] [feature] [value] Edit source. Noogle also knows. Aliases. lib.cmakeOptionType.",
    "word_count": 78,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.cmakeOptionType"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 67
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.cmakeOptionType. Create a \"-D:=\" string that can be passed to typical CMake invocations. Example. cmakeOptionType \"string\" \"ENGINE\" \"sdl2\" =&gt; \"-DENGINE:STRING=sdl2\" Type. cmakeOptionType :: string -&gt; string -&gt; string -&gt; string @param feature The feature to be set @param type The type of the feature to be set, as described in https://cmake.org/cmake/help/latest/command/set.html the possible values (case insensitive) are: BOOL FILEPATH PATH STRING INTERNAL @param value The desired value Arguments. [type] [feature] [value] Edit source. Noogle also knows. Aliases. lib.cmakeOptionType.",
    "raw_url": "/f/lib/strings/cmakeOptionType.html",
    "excerpt": "lib.strings.cmakeOptionType. Create a \"-D:=\" string that can be passed to typical CMake invocations. Example. cmakeOptionType \"string\" \"ENGINE\" \"sdl2\" =&gt; \"-DENGINE:STRING=sdl2\" Type. cmakeOptionType :: string -&gt; string -&gt; string -&gt; string",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/split.html",
    "content": "lib.strings.split Primop. Takes 2 arguments. regex, str. Returns a list composed of non matched strings interleaved with the lists of the extended POSIX regular expression regex matches of str. Each item in the lists of matched sequences is a regex group. builtins.split \"(a)b\" \"abc\" Evaluates to [ \"\" [ \"a\" ] \"c\" ]. builtins.split \"([ac])\" \"abc\" Evaluates to [ \"\" [ \"a\" ] \"b\" [ \"c\" ] \"\" ]. builtins.split \"(a)|(c)\" \"abc\" Evaluates to [ \"\" [ \"a\" null ] \"b\" [ null \"c\" ] \"\" ]. builtins.split \"([[:upper:]]+)\" \" FOO \" Evaluates to [ \" \" [ \"FOO\" ] \" \" ]. Noogle also knows. Aliases. builtins.split.",
    "word_count": 108,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.split Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.split Primop. Takes 2 arguments. regex, str. Returns a list composed of non matched strings interleaved with the lists of the extended POSIX regular expression regex matches of str. Each item in the lists of matched sequences is a regex group. builtins.split \"(a)b\" \"abc\" Evaluates to [ \"\" [ \"a\" ] \"c\" ]. builtins.split \"([ac])\" \"abc\" Evaluates to [ \"\" [ \"a\" ] \"b\" [ \"c\" ] \"\" ]. builtins.split \"(a)|(c)\" \"abc\" Evaluates to [ \"\" [ \"a\" null ] \"b\" [ null \"c\" ] \"\" ]. builtins.split \"([[:upper:]]+)\" \" FOO \" Evaluates to [ \" \" [ \"FOO\" ] \" \" ]. Noogle also knows. Aliases. builtins.split.",
    "raw_url": "/f/lib/strings/split.html",
    "excerpt": "lib.strings.split Primop. Takes 2 arguments. regex, str. Returns a list composed of non matched strings interleaved with the lists of the extended POSIX regular expression regex matches of str. Each",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/getName.html",
    "content": "lib.strings.getName. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the name part from that argument. Example. getName \"youtube-dl-2016.01.01\" => \"youtube-dl\" getName pkgs.youtube-dl => \"youtube-dl\" Arguments. [x] Edit source. Noogle also knows. Aliases. lib.getName.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.getName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.getName. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the name part from that argument. Example. getName \"youtube-dl-2016.01.01\" =&gt; \"youtube-dl\" getName pkgs.youtube-dl =&gt; \"youtube-dl\" Arguments. [x] Edit source. Noogle also knows. Aliases. lib.getName.",
    "raw_url": "/f/lib/strings/getName.html",
    "excerpt": "lib.strings.getName. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the name part from that argument. Example. getName \"youtube-dl-2016.01.01\" =&gt; \"youtube-dl\" getName pkgs.youtube-dl",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/commonPrefixLength.html",
    "content": "lib.strings.commonPrefixLength. Returns the length of the prefix common to both strings. Arguments. [a] [b] Edit source.",
    "word_count": 16,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.commonPrefixLength"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.commonPrefixLength. Returns the length of the prefix common to both strings. Arguments. [a] [b] Edit source.",
    "raw_url": "/f/lib/strings/commonPrefixLength.html",
    "excerpt": "lib.strings.commonPrefixLength. Returns the length of the prefix common to both strings. Arguments. [a] [b] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/intersperse.html",
    "content": "lib.strings.intersperse. Place an element between each element of a list. Example. intersperse \"/\" [\"usr\" \"local\" \"bin\"] => [\"usr\" \"/\" \"local\" \"/\" \"bin\"]. Type. intersperse :: a -> [a] -> [a] Arguments. [separator] Separator to add between elements. [list] Input list. Edit source. Noogle also knows. Aliases. lib.intersperse.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.intersperse"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 30
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.intersperse. Place an element between each element of a list. Example. intersperse \"/\" [\"usr\" \"local\" \"bin\"] =&gt; [\"usr\" \"/\" \"local\" \"/\" \"bin\"]. Type. intersperse :: a -&gt; [a] -&gt; [a] Arguments. [separator] Separator to add between elements. [list] Input list. Edit source. Noogle also knows. Aliases. lib.intersperse.",
    "raw_url": "/f/lib/strings/intersperse.html",
    "excerpt": "lib.strings.intersperse. Place an element between each element of a list. Example. intersperse \"/\" [\"usr\" \"local\" \"bin\"] =&gt; [\"usr\" \"/\" \"local\" \"/\" \"bin\"]. Type. intersperse :: a -&gt; [a] -&gt; [a]",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/concatLines.html",
    "content": "lib.strings.concatLines. Concatenate a list of strings, adding a newline at the end of each one. Defined as concatMapStrings (s: s + \"\\n\"). Example. concatLines [ \"foo\" \"bar\" ] => \"foo\\nbar\\n\" Type. concatLines :: [string] -> string Edit source. Noogle also knows. Aliases. lib.concatLines.",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.concatLines"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 22
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 30
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.concatLines. Concatenate a list of strings, adding a newline at the end of each one. Defined as concatMapStrings (s: s + \"\\n\"). Example. concatLines [ \"foo\" \"bar\" ] =&gt; \"foo\\nbar\\n\" Type. concatLines :: [string] -&gt; string Edit source. Noogle also knows. Aliases. lib.concatLines.",
    "raw_url": "/f/lib/strings/concatLines.html",
    "excerpt": "lib.strings.concatLines. Concatenate a list of strings, adding a newline at the end of each one. Defined as concatMapStrings (s: s + \"\\n\"). Example. concatLines [ \"foo\" \"bar\" ] =&gt; \"foo\\nbar\\n\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/makeSearchPathOutput.html",
    "content": "lib.strings.makeSearchPathOutput. Construct a Unix-style search path by appending the given subDir to the specified output of each of the packages. If no output by the given name is found, fallback to .out and then to the default. Example. makeSearchPathOutput \"dev\" \"bin\" [ pkgs.openssl pkgs.zlib ] => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev/bin:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/bin\" Type. string -> string -> [package] -> string Arguments. [output] Package output to use. [subDir] Directory name to append. [pkgs] List of packages. Edit source. Noogle also knows. Aliases. lib.makeSearchPathOutput.",
    "word_count": 77,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.makeSearchPathOutput"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 37
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.makeSearchPathOutput. Construct a Unix-style search path by appending the given subDir to the specified output of each of the packages. If no output by the given name is found, fallback to .out and then to the default. Example. makeSearchPathOutput \"dev\" \"bin\" [ pkgs.openssl pkgs.zlib ] =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev/bin:/nix/store/wwh7mhwh269sfjkm6k5665b5kgp7jrk2-zlib-1.2.8/bin\" Type. string -&gt; string -&gt; [package] -&gt; string Arguments. [output] Package output to use. [subDir] Directory name to append. [pkgs] List of packages. Edit source. Noogle also knows. Aliases. lib.makeSearchPathOutput.",
    "raw_url": "/f/lib/strings/makeSearchPathOutput.html",
    "excerpt": "lib.strings.makeSearchPathOutput. Construct a Unix-style search path by appending the given subDir to the specified output of each of the packages. If no output by the given name is found, fallback",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/isStringLike.html",
    "content": "lib.strings.isStringLike. Check whether a value can be coerced to a string. The value must be a string, path, or attribute set. String-like values can be used without explicit conversion in string interpolations and in most functions that expect a string. Arguments. [x] Edit source. Noogle also knows. Aliases. lib.isStringLike.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.isStringLike"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.isStringLike. Check whether a value can be coerced to a string. The value must be a string, path, or attribute set. String-like values can be used without explicit conversion in string interpolations and in most functions that expect a string. Arguments. [x] Edit source. Noogle also knows. Aliases. lib.isStringLike.",
    "raw_url": "/f/lib/strings/isStringLike.html",
    "excerpt": "lib.strings.isStringLike. Check whether a value can be coerced to a string. The value must be a string, path, or attribute set. String-like values can be used without explicit conversion in",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/mesonOption.html",
    "content": "lib.strings.mesonOption. Create a -D= string that can be passed to typical Meson invocations. Example. mesonOption \"engine\" \"opengl\" => \"-Dengine=opengl\" Type. mesonOption :: string -> string -> string @param feature The feature to be set @param value The desired value Arguments. [feature] [value] Edit source. Noogle also knows. Aliases. lib.mesonOption.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.mesonOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.mesonOption. Create a -D= string that can be passed to typical Meson invocations. Example. mesonOption \"engine\" \"opengl\" =&gt; \"-Dengine=opengl\" Type. mesonOption :: string -&gt; string -&gt; string @param feature The feature to be set @param value The desired value Arguments. [feature] [value] Edit source. Noogle also knows. Aliases. lib.mesonOption.",
    "raw_url": "/f/lib/strings/mesonOption.html",
    "excerpt": "lib.strings.mesonOption. Create a -D= string that can be passed to typical Meson invocations. Example. mesonOption \"engine\" \"opengl\" =&gt; \"-Dengine=opengl\" Type. mesonOption :: string -&gt; string -&gt; string @param feature The",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/fromJSON.html",
    "content": "lib.strings.fromJSON Primop. Takes 1 arguments. e. Convert a JSON string to a Nix value. For example, builtins.fromJSON ''{\"x\": [1, 2, 3], \"y\": null}'' returns the value { x = [ 1 2 3 ]; y = null; }. Noogle also knows. Aliases. builtins.fromJSON.",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.fromJSON Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.fromJSON Primop. Takes 1 arguments. e. Convert a JSON string to a Nix value. For example, builtins.fromJSON ''{\"x\": [1, 2, 3], \"y\": null}'' returns the value { x = [ 1 2 3 ]; y = null; }. Noogle also knows. Aliases. builtins.fromJSON.",
    "raw_url": "/f/lib/strings/fromJSON.html",
    "excerpt": "lib.strings.fromJSON Primop. Takes 1 arguments. e. Convert a JSON string to a Nix value. For example, builtins.fromJSON ''{\"x\": [1, 2, 3], \"y\": null}'' returns the value { x = [",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/unsafeDiscardStringContext.html",
    "content": "lib.strings.unsafeDiscardStringContext Primop. Takes 1 arguments.",
    "word_count": 5,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.unsafeDiscardStringContext Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.unsafeDiscardStringContext Primop. Takes 1 arguments.",
    "raw_url": "/f/lib/strings/unsafeDiscardStringContext.html",
    "excerpt": "lib.strings.unsafeDiscardStringContext Primop. Takes 1 arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/concatMapStringsSep.html",
    "content": "lib.strings.concatMapStringsSep. Maps a function over a list of strings and then concatenates the result with the specified separator interspersed between elements. Example. concatMapStringsSep \"-\" (x: toUpper x) [\"foo\" \"bar\" \"baz\"] => \"FOO-BAR-BAZ\" Type. concatMapStringsSep :: string -> (a -> string) -> [a] -> string Arguments. [sep] Separator to add between elements. [f] Function to map over the list. [list] List of input strings. Edit source. Noogle also knows. Aliases. lib.concatMapStringsSep.",
    "word_count": 70,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.concatMapStringsSep"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 21
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 44
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.concatMapStringsSep. Maps a function over a list of strings and then concatenates the result with the specified separator interspersed between elements. Example. concatMapStringsSep \"-\" (x: toUpper x) [\"foo\" \"bar\" \"baz\"] =&gt; \"FOO-BAR-BAZ\" Type. concatMapStringsSep :: string -&gt; (a -&gt; string) -&gt; [a] -&gt; string Arguments. [sep] Separator to add between elements. [f] Function to map over the list. [list] List of input strings. Edit source. Noogle also knows. Aliases. lib.concatMapStringsSep.",
    "raw_url": "/f/lib/strings/concatMapStringsSep.html",
    "excerpt": "lib.strings.concatMapStringsSep. Maps a function over a list of strings and then concatenates the result with the specified separator interspersed between elements. Example. concatMapStringsSep \"-\" (x: toUpper x) [\"foo\" \"bar\" \"baz\"]",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/fixedWidthString.html",
    "content": "lib.strings.fixedWidthString. Create a fixed width string with additional prefix to match required width. This function will fail if the input string is longer than the requested length. Example. fixedWidthString 5 \"0\" (toString 15) => \"00015\" Type. fixedWidthString :: int -> string -> string -> string Arguments. [width] [filler] [str] Edit source. Noogle also knows. Aliases. lib.fixedWidthString.",
    "word_count": 56,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.fixedWidthString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 27
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 35
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 45
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.fixedWidthString. Create a fixed width string with additional prefix to match required width. This function will fail if the input string is longer than the requested length. Example. fixedWidthString 5 \"0\" (toString 15) =&gt; \"00015\" Type. fixedWidthString :: int -&gt; string -&gt; string -&gt; string Arguments. [width] [filler] [str] Edit source. Noogle also knows. Aliases. lib.fixedWidthString.",
    "raw_url": "/f/lib/strings/fixedWidthString.html",
    "excerpt": "lib.strings.fixedWidthString. Create a fixed width string with additional prefix to match required width. This function will fail if the input string is longer than the requested length. Example. fixedWidthString 5",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/hasSuffix.html",
    "content": "lib.strings.hasSuffix. Determine whether a string has given suffix. Example. hasSuffix \"foo\" \"foobar\" => false hasSuffix \"foo\" \"barfoo\" => true Type. hasSuffix :: string -> string -> bool Arguments. [suffix] Suffix to check for. [content] Input string. Edit source. Noogle also knows. Aliases. lib.hasSuffix.",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.hasSuffix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 8
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.hasSuffix. Determine whether a string has given suffix. Example. hasSuffix \"foo\" \"foobar\" =&gt; false hasSuffix \"foo\" \"barfoo\" =&gt; true Type. hasSuffix :: string -&gt; string -&gt; bool Arguments. [suffix] Suffix to check for. [content] Input string. Edit source. Noogle also knows. Aliases. lib.hasSuffix.",
    "raw_url": "/f/lib/strings/hasSuffix.html",
    "excerpt": "lib.strings.hasSuffix. Determine whether a string has given suffix. Example. hasSuffix \"foo\" \"foobar\" =&gt; false hasSuffix \"foo\" \"barfoo\" =&gt; true Type. hasSuffix :: string -&gt; string -&gt; bool Arguments. [suffix] Suffix",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/makeBinPath.html",
    "content": "lib.strings.makeBinPath. Construct a binary search path (such as $PATH) containing the binaries for a set of packages. Example. makeBinPath [\"/root\" \"/usr\" \"/usr/local\"] => \"/root/bin:/usr/bin:/usr/local/bin\" Edit source. Noogle also knows. Aliases. lib.makeBinPath.",
    "word_count": 31,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.makeBinPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.makeBinPath. Construct a binary search path (such as $PATH) containing the binaries for a set of packages. Example. makeBinPath [\"/root\" \"/usr\" \"/usr/local\"] =&gt; \"/root/bin:/usr/bin:/usr/local/bin\" Edit source. Noogle also knows. Aliases. lib.makeBinPath.",
    "raw_url": "/f/lib/strings/makeBinPath.html",
    "excerpt": "lib.strings.makeBinPath. Construct a binary search path (such as $PATH) containing the binaries for a set of packages. Example. makeBinPath [\"/root\" \"/usr\" \"/usr/local\"] =&gt; \"/root/bin:/usr/bin:/usr/local/bin\" Edit source. Noogle also knows. Aliases.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/escapeShellArgs.html",
    "content": "lib.strings.escapeShellArgs. Quote all arguments to be safely passed to the Bourne shell. Example. escapeShellArgs [\"one\" \"two three\" \"four'five\"] => \"'one' 'two three' 'four'\\\\''five'\" Type. escapeShellArgs :: [string] -> string Edit source. Noogle also knows. Aliases. lib.escapeShellArgs.",
    "word_count": 36,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.escapeShellArgs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.escapeShellArgs. Quote all arguments to be safely passed to the Bourne shell. Example. escapeShellArgs [\"one\" \"two three\" \"four'five\"] =&gt; \"'one' 'two three' 'four'\\\\''five'\" Type. escapeShellArgs :: [string] -&gt; string Edit source. Noogle also knows. Aliases. lib.escapeShellArgs.",
    "raw_url": "/f/lib/strings/escapeShellArgs.html",
    "excerpt": "lib.strings.escapeShellArgs. Quote all arguments to be safely passed to the Bourne shell. Example. escapeShellArgs [\"one\" \"two three\" \"four'five\"] =&gt; \"'one' 'two three' 'four'\\\\''five'\" Type. escapeShellArgs :: [string] -&gt; string Edit",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/stringAsChars.html",
    "content": "lib.strings.stringAsChars. Manipulate a string character by character and replace them by strings before concatenating the results. Example. stringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\" => \"nix\" Type. stringAsChars :: (string -> string) -> string -> string Arguments. [f] Function to map over each individual character. [s] Input string. Edit source. Noogle also knows. Aliases. lib.stringAsChars.",
    "word_count": 59,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.stringAsChars"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 30
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.stringAsChars. Manipulate a string character by character and replace them by strings before concatenating the results. Example. stringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\" =&gt; \"nix\" Type. stringAsChars :: (string -&gt; string) -&gt; string -&gt; string Arguments. [f] Function to map over each individual character. [s] Input string. Edit source. Noogle also knows. Aliases. lib.stringAsChars.",
    "raw_url": "/f/lib/strings/stringAsChars.html",
    "excerpt": "lib.strings.stringAsChars. Manipulate a string character by character and replace them by strings before concatenating the results. Example. stringAsChars (x: if x == \"a\" then \"i\" else x) \"nax\" =&gt; \"nix\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/head.html",
    "content": "lib.strings.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether a list is empty by comparing it with []. Noogle also knows. Aliases. builtins.head. lib.head. lib.lists.head.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.head Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether a list is empty by comparing it with []. Noogle also knows. Aliases. builtins.head. lib.head. lib.lists.head.",
    "raw_url": "/f/lib/strings/head.html",
    "excerpt": "lib.strings.head Primop. Takes 1 arguments. list. Return the first element of a list; abort evaluation if the argument isn’t a list or is an empty list. You can test whether",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/isConvertibleWithToString.html",
    "content": "lib.strings.isConvertibleWithToString. Check whether a list or other value can be passed to toString. Many types of value are coercible to string this way, including int, float, null, bool, list of similarly coercible values. Arguments. [x] Edit source.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.isConvertibleWithToString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 33
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.isConvertibleWithToString. Check whether a list or other value can be passed to toString. Many types of value are coercible to string this way, including int, float, null, bool, list of similarly coercible values. Arguments. [x] Edit source.",
    "raw_url": "/f/lib/strings/isConvertibleWithToString.html",
    "excerpt": "lib.strings.isConvertibleWithToString. Check whether a list or other value can be passed to toString. Many types of value are coercible to string this way, including int, float, null, bool, list of",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/makeSearchPath.html",
    "content": "lib.strings.makeSearchPath. Construct a Unix-style, colon-separated search path consisting of the given subDir appended to each of the given paths. Example. makeSearchPath \"bin\" [\"/root\" \"/usr\" \"/usr/local\"] => \"/root/bin:/usr/bin:/usr/local/bin\" makeSearchPath \"bin\" [\"\"] => \"/bin\" Type. makeSearchPath :: string -> [string] -> string Arguments. [subDir] Directory name to append. [paths] List of base paths. Edit source. Noogle also knows. Aliases. lib.makeSearchPath.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.makeSearchPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.makeSearchPath. Construct a Unix-style, colon-separated search path consisting of the given subDir appended to each of the given paths. Example. makeSearchPath \"bin\" [\"/root\" \"/usr\" \"/usr/local\"] =&gt; \"/root/bin:/usr/bin:/usr/local/bin\" makeSearchPath \"bin\" [\"\"] =&gt; \"/bin\" Type. makeSearchPath :: string -&gt; [string] -&gt; string Arguments. [subDir] Directory name to append. [paths] List of base paths. Edit source. Noogle also knows. Aliases. lib.makeSearchPath.",
    "raw_url": "/f/lib/strings/makeSearchPath.html",
    "excerpt": "lib.strings.makeSearchPath. Construct a Unix-style, colon-separated search path consisting of the given subDir appended to each of the given paths. Example. makeSearchPath \"bin\" [\"/root\" \"/usr\" \"/usr/local\"] =&gt; \"/root/bin:/usr/bin:/usr/local/bin\" makeSearchPath \"bin\" [\"\"]",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/typeOf.html",
    "content": "lib.strings.typeOf Primop. Takes 1 arguments. e. Return a string representing the type of the value e, namely \"int\", \"bool\", \"string\", \"path\", \"null\", \"set\", \"list\", \"lambda\" or \"float\". Noogle also knows. Aliases. builtins.typeOf.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.typeOf Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.typeOf Primop. Takes 1 arguments. e. Return a string representing the type of the value e, namely \"int\", \"bool\", \"string\", \"path\", \"null\", \"set\", \"list\", \"lambda\" or \"float\". Noogle also knows. Aliases. builtins.typeOf.",
    "raw_url": "/f/lib/strings/typeOf.html",
    "excerpt": "lib.strings.typeOf Primop. Takes 1 arguments. e. Return a string representing the type of the value e, namely \"int\", \"bool\", \"string\", \"path\", \"null\", \"set\", \"list\", \"lambda\" or \"float\". Noogle also knows.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/compareVersions.html",
    "content": "lib.strings.compareVersions Primop. Takes 2 arguments. s1, s2. Compare two strings representing versions and return -1 if version s1 is older than version s2, 0 if they are the same, and 1 if s1 is newer than s2. The version comparison algorithm is the same as the one used by nix-env -u. Noogle also knows. Aliases. builtins.compareVersions.",
    "word_count": 56,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.compareVersions Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.compareVersions Primop. Takes 2 arguments. s1, s2. Compare two strings representing versions and return -1 if version s1 is older than version s2, 0 if they are the same, and 1 if s1 is newer than s2. The version comparison algorithm is the same as the one used by nix-env -u. Noogle also knows. Aliases. builtins.compareVersions.",
    "raw_url": "/f/lib/strings/compareVersions.html",
    "excerpt": "lib.strings.compareVersions Primop. Takes 2 arguments. s1, s2. Compare two strings representing versions and return -1 if version s1 is older than version s2, 0 if they are the same, and",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/fileContents.html",
    "content": "lib.strings.fileContents. Read the contents of a file removing the trailing \\n. Example. $ echo \"1.0\" > ./version fileContents ./version => \"1.0\" Type. fileContents :: path -> string Arguments. [file] Edit source. Noogle also knows. Aliases. lib.fileContents.",
    "word_count": 36,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.fileContents"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.fileContents. Read the contents of a file removing the trailing \\n. Example. $ echo \"1.0\" &gt; ./version fileContents ./version =&gt; \"1.0\" Type. fileContents :: path -&gt; string Arguments. [file] Edit source. Noogle also knows. Aliases. lib.fileContents.",
    "raw_url": "/f/lib/strings/fileContents.html",
    "excerpt": "lib.strings.fileContents. Read the contents of a file removing the trailing \\n. Example. $ echo \"1.0\" &gt; ./version fileContents ./version =&gt; \"1.0\" Type. fileContents :: path -&gt; string Arguments. [file] Edit",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/isPath.html",
    "content": "lib.strings.isPath Primop. Takes 1 arguments. e. Return true if e evaluates to a path, and false otherwise. Noogle also knows. Aliases. builtins.isPath. lib.isPath.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.isPath Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.isPath Primop. Takes 1 arguments. e. Return true if e evaluates to a path, and false otherwise. Noogle also knows. Aliases. builtins.isPath. lib.isPath.",
    "raw_url": "/f/lib/strings/isPath.html",
    "excerpt": "lib.strings.isPath Primop. Takes 1 arguments. e. Return true if e evaluates to a path, and false otherwise. Noogle also knows. Aliases. builtins.isPath. lib.isPath.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/concatImapStringsSep.html",
    "content": "lib.strings.concatImapStringsSep. Same as concatMapStringsSep, but the mapping function additionally receives the position of its argument. Example. concatImapStringsSep \"-\" (pos: x: toString (x / pos)) [ 6 6 6 ] => \"6-3-2\" Type. concatIMapStringsSep :: string -> (int -> a -> string) -> [a] -> string Arguments. [sep] Separator to add between elements. [f] Function that receives elements and their positions. [list] List of input strings. Edit source. Noogle also knows. Aliases. lib.concatImapStringsSep.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.concatImapStringsSep"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 45
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.concatImapStringsSep. Same as concatMapStringsSep, but the mapping function additionally receives the position of its argument. Example. concatImapStringsSep \"-\" (pos: x: toString (x / pos)) [ 6 6 6 ] =&gt; \"6-3-2\" Type. concatIMapStringsSep :: string -&gt; (int -&gt; a -&gt; string) -&gt; [a] -&gt; string Arguments. [sep] Separator to add between elements. [f] Function that receives elements and their positions. [list] List of input strings. Edit source. Noogle also knows. Aliases. lib.concatImapStringsSep.",
    "raw_url": "/f/lib/strings/concatImapStringsSep.html",
    "excerpt": "lib.strings.concatImapStringsSep. Same as concatMapStringsSep, but the mapping function additionally receives the position of its argument. Example. concatImapStringsSep \"-\" (pos: x: toString (x / pos)) [ 6 6 6 ] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/toInt.html",
    "content": "lib.strings.toInt. Parse a string as an int. Does not support parsing of integers with preceding zero due to ambiguity between zero-padded and octal numbers. See toIntBase10. Example. toInt \"1337\" => 1337 toInt \"-4\" => -4 toInt \" 123 \" => 123 toInt \"00024\" => error: Ambiguity in interpretation of 00024 between octal and zero padded integer. toInt \"3.14\" => error: floating point JSON numbers are not supported Type. string -> int Arguments. [str] Edit source. Noogle also knows. Aliases. lib.toInt.",
    "word_count": 80,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.toInt"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 67
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 71
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.toInt. Parse a string as an int. Does not support parsing of integers with preceding zero due to ambiguity between zero-padded and octal numbers. See toIntBase10. Example. toInt \"1337\" =&gt; 1337 toInt \"-4\" =&gt; -4 toInt \" 123 \" =&gt; 123 toInt \"00024\" =&gt; error: Ambiguity in interpretation of 00024 between octal and zero padded integer. toInt \"3.14\" =&gt; error: floating point JSON numbers are not supported Type. string -&gt; int Arguments. [str] Edit source. Noogle also knows. Aliases. lib.toInt.",
    "raw_url": "/f/lib/strings/toInt.html",
    "excerpt": "lib.strings.toInt. Parse a string as an int. Does not support parsing of integers with preceding zero due to ambiguity between zero-padded and octal numbers. See toIntBase10. Example. toInt \"1337\" =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/removeSuffix.html",
    "content": "lib.strings.removeSuffix. Return a string without the specified suffix, if the suffix matches. Example. removeSuffix \"front\" \"homefront\" => \"home\" removeSuffix \"xxx\" \"homefront\" => \"homefront\" Type. string -> string -> string Arguments. [suffix] Suffix to remove if it matches. [str] Input string. Edit source. Noogle also knows. Aliases. lib.removeSuffix.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.removeSuffix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.removeSuffix. Return a string without the specified suffix, if the suffix matches. Example. removeSuffix \"front\" \"homefront\" =&gt; \"home\" removeSuffix \"xxx\" \"homefront\" =&gt; \"homefront\" Type. string -&gt; string -&gt; string Arguments. [suffix] Suffix to remove if it matches. [str] Input string. Edit source. Noogle also knows. Aliases. lib.removeSuffix.",
    "raw_url": "/f/lib/strings/removeSuffix.html",
    "excerpt": "lib.strings.removeSuffix. Return a string without the specified suffix, if the suffix matches. Example. removeSuffix \"front\" \"homefront\" =&gt; \"home\" removeSuffix \"xxx\" \"homefront\" =&gt; \"homefront\" Type. string -&gt; string -&gt; string Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/mesonBool.html",
    "content": "lib.strings.mesonBool. Create a -D={true,false} string that can be passed to typical Meson invocations. Example. mesonBool \"hardened\" true => \"-Dhardened=true\" mesonBool \"static\" false => \"-Dstatic=false\" Type. mesonBool :: string -> bool -> string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [condition] [flag] Edit source. Noogle also knows. Aliases. lib.mesonBool.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.mesonBool"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 24
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.mesonBool. Create a -D={true,false} string that can be passed to typical Meson invocations. Example. mesonBool \"hardened\" true =&gt; \"-Dhardened=true\" mesonBool \"static\" false =&gt; \"-Dstatic=false\" Type. mesonBool :: string -&gt; bool -&gt; string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [condition] [flag] Edit source. Noogle also knows. Aliases. lib.mesonBool.",
    "raw_url": "/f/lib/strings/mesonBool.html",
    "excerpt": "lib.strings.mesonBool. Create a -D={true,false} string that can be passed to typical Meson invocations. Example. mesonBool \"hardened\" true =&gt; \"-Dhardened=true\" mesonBool \"static\" false =&gt; \"-Dstatic=false\" Type. mesonBool :: string -&gt; bool",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/optionalString.html",
    "content": "lib.strings.optionalString. Depending on the boolean `cond', return either the given string or the empty string. Useful to concatenate against a bigger string. Example. optionalString true \"some-string\" => \"some-string\" optionalString false \"some-string\" => \"\" Type. optionalString :: bool -> string -> string Arguments. [cond] Condition. [string] String to return if condition is true. Edit source. Noogle also knows. Aliases. lib.optionalString.",
    "word_count": 59,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.optionalString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 22
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 33
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.optionalString. Depending on the boolean `cond', return either the given string or the empty string. Useful to concatenate against a bigger string. Example. optionalString true \"some-string\" =&gt; \"some-string\" optionalString false \"some-string\" =&gt; \"\" Type. optionalString :: bool -&gt; string -&gt; string Arguments. [cond] Condition. [string] String to return if condition is true. Edit source. Noogle also knows. Aliases. lib.optionalString.",
    "raw_url": "/f/lib/strings/optionalString.html",
    "excerpt": "lib.strings.optionalString. Depending on the boolean `cond', return either the given string or the empty string. Useful to concatenate against a bigger string. Example. optionalString true \"some-string\" =&gt; \"some-string\" optionalString false",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/hasPrefix.html",
    "content": "lib.strings.hasPrefix. Determine whether a string has given prefix. Example. hasPrefix \"foo\" \"foobar\" => true hasPrefix \"foo\" \"barfoo\" => false Type. hasPrefix :: string -> string -> bool Arguments. [pref] Prefix to check for. [str] Input string. Edit source. Noogle also knows. Aliases. lib.hasPrefix. lib.lists.hasPrefix. lib.path.hasPrefix.",
    "word_count": 45,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.hasPrefix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 8
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.hasPrefix. Determine whether a string has given prefix. Example. hasPrefix \"foo\" \"foobar\" =&gt; true hasPrefix \"foo\" \"barfoo\" =&gt; false Type. hasPrefix :: string -&gt; string -&gt; bool Arguments. [pref] Prefix to check for. [str] Input string. Edit source. Noogle also knows. Aliases. lib.hasPrefix. lib.lists.hasPrefix. lib.path.hasPrefix.",
    "raw_url": "/f/lib/strings/hasPrefix.html",
    "excerpt": "lib.strings.hasPrefix. Determine whether a string has given prefix. Example. hasPrefix \"foo\" \"foobar\" =&gt; true hasPrefix \"foo\" \"barfoo\" =&gt; false Type. hasPrefix :: string -&gt; string -&gt; bool Arguments. [pref] Prefix",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/replaceChars.html",
    "content": "lib.strings.replaceChars Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s. Example: builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\" evaluates to \"fabir\". Noogle also knows. Aliases. builtins.replaceStrings. lib.replaceChars. lib.replaceStrings. lib.strings.replaceStrings.",
    "word_count": 66,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.replaceChars Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.replaceChars Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s. Example: builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\" evaluates to \"fabir\". Noogle also knows. Aliases. builtins.replaceStrings. lib.replaceChars. lib.replaceStrings. lib.strings.replaceStrings.",
    "raw_url": "/f/lib/strings/replaceChars.html",
    "excerpt": "lib.strings.replaceChars Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy,",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/filter.html",
    "content": "lib.strings.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. builtins.filter. lib.filter. lib.lists.filter.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.filter Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. builtins.filter. lib.filter. lib.lists.filter.",
    "raw_url": "/f/lib/strings/filter.html",
    "excerpt": "lib.strings.filter Primop. Takes 2 arguments. f, list. Return a list consisting of the elements of list for which the function f returns true. Noogle also knows. Aliases. builtins.filter. lib.filter. lib.lists.filter.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/removePrefix.html",
    "content": "lib.strings.removePrefix. Return a string without the specified prefix, if the prefix matches. Example. removePrefix \"foo.\" \"foo.bar.baz\" => \"bar.baz\" removePrefix \"xxx\" \"foo.bar.baz\" => \"foo.bar.baz\" Type. string -> string -> string Arguments. [prefix] Prefix to remove if it matches. [str] Input string. Edit source. Noogle also knows. Aliases. lib.removePrefix. lib.lists.removePrefix. lib.path.removePrefix.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.removePrefix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.removePrefix. Return a string without the specified prefix, if the prefix matches. Example. removePrefix \"foo.\" \"foo.bar.baz\" =&gt; \"bar.baz\" removePrefix \"xxx\" \"foo.bar.baz\" =&gt; \"foo.bar.baz\" Type. string -&gt; string -&gt; string Arguments. [prefix] Prefix to remove if it matches. [str] Input string. Edit source. Noogle also knows. Aliases. lib.removePrefix. lib.lists.removePrefix. lib.path.removePrefix.",
    "raw_url": "/f/lib/strings/removePrefix.html",
    "excerpt": "lib.strings.removePrefix. Return a string without the specified prefix, if the prefix matches. Example. removePrefix \"foo.\" \"foo.bar.baz\" =&gt; \"bar.baz\" removePrefix \"xxx\" \"foo.bar.baz\" =&gt; \"foo.bar.baz\" Type. string -&gt; string -&gt; string Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/escapeC.html",
    "content": "lib.strings.escapeC. Escape occurrence of the element of list in string by converting to its ASCII value and prefixing it with \\x. Only works for printable ascii characters. Example. escapeC [\" \"] \"foo bar\" => \"foo\\\\x20bar\" Type. escapeC = [string] -> string -> string Arguments. [list] Edit source.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.escapeC"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 27
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 35
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 43
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.escapeC. Escape occurrence of the element of list in string by converting to its ASCII value and prefixing it with \\x. Only works for printable ascii characters. Example. escapeC [\" \"] \"foo bar\" =&gt; \"foo\\\\x20bar\" Type. escapeC = [string] -&gt; string -&gt; string Arguments. [list] Edit source.",
    "raw_url": "/f/lib/strings/escapeC.html",
    "excerpt": "lib.strings.escapeC. Escape occurrence of the element of list in string by converting to its ASCII value and prefixing it with \\x. Only works for printable ascii characters. Example. escapeC [\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/cmakeBool.html",
    "content": "lib.strings.cmakeBool. Create a -D={TRUE,FALSE} string that can be passed to typical CMake invocations. Example. cmakeBool \"ENABLE_STATIC_LIBS\" false => \"-DENABLESTATIC_LIBS:BOOL=FALSE\" Type. cmakeBool :: string -> bool -> string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [condition] [flag] Edit source. Noogle also knows. Aliases. lib.cmakeBool.",
    "word_count": 55,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.cmakeBool"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 45
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.cmakeBool. Create a -D={TRUE,FALSE} string that can be passed to typical CMake invocations. Example. cmakeBool \"ENABLE_STATIC_LIBS\" false =&gt; \"-DENABLESTATIC_LIBS:BOOL=FALSE\" Type. cmakeBool :: string -&gt; bool -&gt; string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [condition] [flag] Edit source. Noogle also knows. Aliases. lib.cmakeBool.",
    "raw_url": "/f/lib/strings/cmakeBool.html",
    "excerpt": "lib.strings.cmakeBool. Create a -D={TRUE,FALSE} string that can be passed to typical CMake invocations. Example. cmakeBool \"ENABLE_STATIC_LIBS\" false =&gt; \"-DENABLESTATIC_LIBS:BOOL=FALSE\" Type. cmakeBool :: string -&gt; bool -&gt; string @param condition The",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/commonSuffixLength.html",
    "content": "lib.strings.commonSuffixLength. Returns the length of the suffix common to both strings. Arguments. [a] [b] Edit source.",
    "word_count": 16,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.commonSuffixLength"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.commonSuffixLength. Returns the length of the suffix common to both strings. Arguments. [a] [b] Edit source.",
    "raw_url": "/f/lib/strings/commonSuffixLength.html",
    "excerpt": "lib.strings.commonSuffixLength. Returns the length of the suffix common to both strings. Arguments. [a] [b] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/stringLength.html",
    "content": "lib.strings.stringLength Primop. Takes 1 arguments. e. Return the length of the string e. If e is not a string, evaluation is aborted. Noogle also knows. Aliases. builtins.stringLength. lib.stringLength.",
    "word_count": 28,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.stringLength Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.stringLength Primop. Takes 1 arguments. e. Return the length of the string e. If e is not a string, evaluation is aborted. Noogle also knows. Aliases. builtins.stringLength. lib.stringLength.",
    "raw_url": "/f/lib/strings/stringLength.html",
    "excerpt": "lib.strings.stringLength Primop. Takes 1 arguments. e. Return the length of the string e. If e is not a string, evaluation is aborted. Noogle also knows. Aliases. builtins.stringLength. lib.stringLength.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/addContextFrom.html",
    "content": "lib.strings.addContextFrom. Appends string context from another string. This is an implementation detail of Nix and should be used carefully. Strings in Nix carry an invisible context which is a list of strings representing store paths. If the string is later used in a derivation attribute, the derivation will properly populate the inputDrvs and inputSrcs. Example. pkgs = import <nixpkgs> { }; addContextFrom pkgs.coreutils \"bar\" => \"bar\" Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.addContextFrom.",
    "word_count": 76,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.addContextFrom"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 54
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 66
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.addContextFrom. Appends string context from another string. This is an implementation detail of Nix and should be used carefully. Strings in Nix carry an invisible context which is a list of strings representing store paths. If the string is later used in a derivation attribute, the derivation will properly populate the inputDrvs and inputSrcs. Example. pkgs = import &lt;nixpkgs&gt; { }; addContextFrom pkgs.coreutils \"bar\" =&gt; \"bar\" Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.addContextFrom.",
    "raw_url": "/f/lib/strings/addContextFrom.html",
    "excerpt": "lib.strings.addContextFrom. Appends string context from another string. This is an implementation detail of Nix and should be used carefully. Strings in Nix carry an invisible context which is a list",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/readFile.html",
    "content": "lib.strings.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. builtins.readFile. lib.readFile. lib.trivial.readFile.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.readFile Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. builtins.readFile. lib.readFile. lib.trivial.readFile.",
    "raw_url": "/f/lib/strings/readFile.html",
    "excerpt": "lib.strings.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. builtins.readFile. lib.readFile. lib.trivial.readFile.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/concatStringsSep.html",
    "content": "lib.strings.concatStringsSep Primop. Takes 2 arguments. separator, list. Concatenate a list of strings with a separator between each element. Example. concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] => \"usr/local/bin\" Type. concatStringsSep :: string -> [string] -> string Edit source. Noogle also knows. Aliases. builtins.concatStringsSep. lib.concatStringsSep.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.concatStringsSep Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.concatStringsSep Primop. Takes 2 arguments. separator, list. Concatenate a list of strings with a separator between each element. Example. concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] =&gt; \"usr/local/bin\" Type. concatStringsSep :: string -&gt; [string] -&gt; string Edit source. Noogle also knows. Aliases. builtins.concatStringsSep. lib.concatStringsSep.",
    "raw_url": "/f/lib/strings/concatStringsSep.html",
    "excerpt": "lib.strings.concatStringsSep Primop. Takes 2 arguments. separator, list. Concatenate a list of strings with a separator between each element. Example. concatStringsSep \"/\" [\"usr\" \"local\" \"bin\"] =&gt; \"usr/local/bin\" Type. concatStringsSep :: string",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/escapeNixString.html",
    "content": "lib.strings.escapeNixString. Turn a string into a Nix expression representing that string. Example. escapeNixString \"hello\\${}\\n\" => \"\\\"hello\\\\\\${}\\\\n\\\"\" Type. string -> string Arguments. [s] Edit source.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.escapeNixString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 16
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.escapeNixString. Turn a string into a Nix expression representing that string. Example. escapeNixString \"hello\\${}\\n\" =&gt; \"\\\"hello\\\\\\${}\\\\n\\\"\" Type. string -&gt; string Arguments. [s] Edit source.",
    "raw_url": "/f/lib/strings/escapeNixString.html",
    "excerpt": "lib.strings.escapeNixString. Turn a string into a Nix expression representing that string. Example. escapeNixString \"hello\\${}\\n\" =&gt; \"\\\"hello\\\\\\${}\\\\n\\\"\" Type. string -&gt; string Arguments. [s] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/readPathsFromFile.html",
    "content": "lib.strings.readPathsFromFile. Read a list of paths from file, relative to the rootPath. Lines beginning with # are treated as comments and ignored. Whitespace is significant. NOTE: This function is not performant and should be avoided. Example. readPathsFromFile /prefix ./pkgs/development/libraries/qt-5/5.4/qtbase/series => [ \"/prefix/dlopen-resolv.patch\" \"/prefix/tzdir.patch\" \"/prefix/dlopen-libXcursor.patch\" \"/prefix/dlopen-openssl.patch\" \"/prefix/dlopen-dbus.patch\" \"/prefix/xdg-config-dirs.patch\" \"/prefix/nix-profiles-library-paths.patch\" \"/prefix/compose-search-path.patch\" ] Edit source. Noogle also knows. Aliases. lib.readPathsFromFile.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.readPathsFromFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.readPathsFromFile. Read a list of paths from file, relative to the rootPath. Lines beginning with # are treated as comments and ignored. Whitespace is significant. NOTE: This function is not performant and should be avoided. Example. readPathsFromFile /prefix ./pkgs/development/libraries/qt-5/5.4/qtbase/series =&gt; [ \"/prefix/dlopen-resolv.patch\" \"/prefix/tzdir.patch\" \"/prefix/dlopen-libXcursor.patch\" \"/prefix/dlopen-openssl.patch\" \"/prefix/dlopen-dbus.patch\" \"/prefix/xdg-config-dirs.patch\" \"/prefix/nix-profiles-library-paths.patch\" \"/prefix/compose-search-path.patch\" ] Edit source. Noogle also knows. Aliases. lib.readPathsFromFile.",
    "raw_url": "/f/lib/strings/readPathsFromFile.html",
    "excerpt": "lib.strings.readPathsFromFile. Read a list of paths from file, relative to the rootPath. Lines beginning with # are treated as comments and ignored. Whitespace is significant. NOTE: This function is not",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/concatMapStrings.html",
    "content": "lib.strings.concatMapStrings. Map a function over a list and concatenate the resulting strings. Example. concatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"] => \"afooabar\" Type. concatMapStrings :: (a -> string) -> [a] -> string Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.concatMapStrings.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.concatMapStrings"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.concatMapStrings. Map a function over a list and concatenate the resulting strings. Example. concatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"] =&gt; \"afooabar\" Type. concatMapStrings :: (a -&gt; string) -&gt; [a] -&gt; string Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.concatMapStrings.",
    "raw_url": "/f/lib/strings/concatMapStrings.html",
    "excerpt": "lib.strings.concatMapStrings. Map a function over a list and concatenate the resulting strings. Example. concatMapStrings (x: \"a\" + x) [\"foo\" \"bar\"] =&gt; \"afooabar\" Type. concatMapStrings :: (a -&gt; string) -&gt; [a]",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/isString.html",
    "content": "lib.strings.isString Primop. Takes 1 arguments. e. Return true if e evaluates to a string, and false otherwise. Noogle also knows. Aliases. builtins.isString. lib.isString.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.isString Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.isString Primop. Takes 1 arguments. e. Return true if e evaluates to a string, and false otherwise. Noogle also knows. Aliases. builtins.isString. lib.isString.",
    "raw_url": "/f/lib/strings/isString.html",
    "excerpt": "lib.strings.isString Primop. Takes 1 arguments. e. Return true if e evaluates to a string, and false otherwise. Noogle also knows. Aliases. builtins.isString. lib.isString.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/escapeXML.html",
    "content": "lib.strings.escapeXML. Escapes a string such that it is safe to include verbatim in an XML document. Example. escapeXML ''\"test\" 'test' < & >'' => \"&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;\" Type. string -> string Edit source. Noogle also knows. Aliases. lib.escapeXML.",
    "word_count": 40,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.escapeXML"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.escapeXML. Escapes a string such that it is safe to include verbatim in an XML document. Example. escapeXML ''\"test\" 'test' &lt; & &gt;'' =&gt; \"&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;\" Type. string -&gt; string Edit source. Noogle also knows. Aliases. lib.escapeXML.",
    "raw_url": "/f/lib/strings/escapeXML.html",
    "excerpt": "lib.strings.escapeXML. Escapes a string such that it is safe to include verbatim in an XML document. Example. escapeXML ''\"test\" 'test' &lt; & &gt;'' =&gt; \"&quot;test&quot; &apos;test&apos; &lt; &amp; &gt;\" Type.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/enableFeatureAs.html",
    "content": "lib.strings.enableFeatureAs. Create an --{enable-=,disable-} string that can be passed to standard GNU Autoconf scripts. Example. enableFeatureAs true \"shared\" \"foo\" => \"--enable-shared=foo\" enableFeatureAs false \"shared\" (throw \"ignored\") => \"--disable-shared\" Arguments. [flag] [feature] [value] Edit source. Noogle also knows. Aliases. lib.enableFeatureAs.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.enableFeatureAs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 28
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.enableFeatureAs. Create an --{enable-=,disable-} string that can be passed to standard GNU Autoconf scripts. Example. enableFeatureAs true \"shared\" \"foo\" =&gt; \"--enable-shared=foo\" enableFeatureAs false \"shared\" (throw \"ignored\") =&gt; \"--disable-shared\" Arguments. [flag] [feature] [value] Edit source. Noogle also knows. Aliases. lib.enableFeatureAs.",
    "raw_url": "/f/lib/strings/enableFeatureAs.html",
    "excerpt": "lib.strings.enableFeatureAs. Create an --{enable-=,disable-} string that can be passed to standard GNU Autoconf scripts. Example. enableFeatureAs true \"shared\" \"foo\" =&gt; \"--enable-shared=foo\" enableFeatureAs false \"shared\" (throw \"ignored\") =&gt; \"--disable-shared\" Arguments. [flag]",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/replaceStrings.html",
    "content": "lib.strings.replaceStrings Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s. Example: builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\" evaluates to \"fabir\". Noogle also knows. Aliases. builtins.replaceStrings. lib.replaceChars. lib.replaceStrings. lib.strings.replaceChars.",
    "word_count": 66,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.replaceStrings Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.replaceStrings Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy, that is, it is only evaluated when its corresponding pattern in from is matched in the string s. Example: builtins.replaceStrings [\"oo\" \"a\"] [\"a\" \"i\"] \"foobar\" evaluates to \"fabir\". Noogle also knows. Aliases. builtins.replaceStrings. lib.replaceChars. lib.replaceStrings. lib.strings.replaceChars.",
    "raw_url": "/f/lib/strings/replaceStrings.html",
    "excerpt": "lib.strings.replaceStrings Primop. Takes 3 arguments. from, to, s. Given string s, replace every occurrence of the strings in from with the corresponding string in to. The argument to is lazy,",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/stringToCharacters.html",
    "content": "lib.strings.stringToCharacters. Convert a string to a list of characters (i.e. singleton strings). This allows you to, e.g., map a function over each character. However, note that this will likely be horribly inefficient; Nix is not a general purpose programming language. Complex string manipulations should, if appropriate, be done in a derivation. Also note that Nix treats strings as a list of bytes and thus doesn't handle unicode. Example. stringToCharacters \"\" => [ ] stringToCharacters \"abc\" => [ \"a\" \"b\" \"c\" ] stringToCharacters \"🦄\" => [ \"�\" \"�\" \"�\" \"�\" ] Type. stringToCharacters :: string -> [string] Arguments. [s] Edit source. Noogle also knows. Aliases. lib.stringToCharacters.",
    "word_count": 105,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.stringToCharacters"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 67
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 90
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 96
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.stringToCharacters. Convert a string to a list of characters (i.e. singleton strings). This allows you to, e.g., map a function over each character. However, note that this will likely be horribly inefficient; Nix is not a general purpose programming language. Complex string manipulations should, if appropriate, be done in a derivation. Also note that Nix treats strings as a list of bytes and thus doesn't handle unicode. Example. stringToCharacters \"\" =&gt; [ ] stringToCharacters \"abc\" =&gt; [ \"a\" \"b\" \"c\" ] stringToCharacters \"🦄\" =&gt; [ \"�\" \"�\" \"�\" \"�\" ] Type. stringToCharacters :: string -&gt; [string] Arguments. [s] Edit source. Noogle also knows. Aliases. lib.stringToCharacters.",
    "raw_url": "/f/lib/strings/stringToCharacters.html",
    "excerpt": "lib.strings.stringToCharacters. Convert a string to a list of characters (i.e. singleton strings). This allows you to, e.g., map a function over each character. However, note that this will likely be",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/isList.html",
    "content": "lib.strings.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. builtins.isList. lib.isList. lib.lists.isList.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.isList Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. builtins.isList. lib.isList. lib.lists.isList.",
    "raw_url": "/f/lib/strings/isList.html",
    "excerpt": "lib.strings.isList Primop. Takes 1 arguments. e. Return true if e evaluates to a list, and false otherwise. Noogle also knows. Aliases. builtins.isList. lib.isList. lib.lists.isList.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/toShellVars.html",
    "content": "lib.strings.toShellVars. Translate an attribute set into corresponding shell variable declarations using toShellVar. Example. let foo = \"value\"; bar = foo; in '' ${toShellVars { inherit foo bar; }} [[ \"$foo\" == \"$bar\" ]] '' Type. attrsOf (string | listOf string | attrsOf string) -> string Arguments. [vars] Edit source. Noogle also knows. Aliases. lib.toShellVars.",
    "word_count": 54,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.toShellVars"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 45
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.toShellVars. Translate an attribute set into corresponding shell variable declarations using toShellVar. Example. let foo = \"value\"; bar = foo; in '' ${toShellVars { inherit foo bar; }} [[ \"$foo\" == \"$bar\" ]] '' Type. attrsOf (string | listOf string | attrsOf string) -&gt; string Arguments. [vars] Edit source. Noogle also knows. Aliases. lib.toShellVars.",
    "raw_url": "/f/lib/strings/toShellVars.html",
    "excerpt": "lib.strings.toShellVars. Translate an attribute set into corresponding shell variable declarations using toShellVar. Example. let foo = \"value\"; bar = foo; in '' ${toShellVars { inherit foo bar; }} [[ \"$foo\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/parseDrvName.html",
    "content": "lib.strings.parseDrvName Primop. Takes 1 arguments. s. Split the string s into a package name and version. The package name is everything up to but not including the first dash not followed by a letter, and the version is everything following that dash. The result is returned in a set { name, version }. Thus, builtins.parseDrvName \"nix-0.12pre12876\" returns { name = \"nix\"; version = \"0.12pre12876\"; }. Noogle also knows. Aliases. builtins.parseDrvName.",
    "word_count": 70,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.parseDrvName Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.parseDrvName Primop. Takes 1 arguments. s. Split the string s into a package name and version. The package name is everything up to but not including the first dash not followed by a letter, and the version is everything following that dash. The result is returned in a set { name, version }. Thus, builtins.parseDrvName \"nix-0.12pre12876\" returns { name = \"nix\"; version = \"0.12pre12876\"; }. Noogle also knows. Aliases. builtins.parseDrvName.",
    "raw_url": "/f/lib/strings/parseDrvName.html",
    "excerpt": "lib.strings.parseDrvName Primop. Takes 1 arguments. s. Split the string s into a package name and version. The package name is everything up to but not including the first dash not",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/isValidPosixName.html",
    "content": "lib.strings.isValidPosixName. Test whether the given name is a valid POSIX shell variable name. Example. isValidPosixName \"foo_bar000\" => true isValidPosixName \"0-bad.jpg\" => false Type. string -> bool Arguments. [name] Edit source. Noogle also knows. Aliases. lib.isValidPosixName.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.isValidPosixName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.isValidPosixName. Test whether the given name is a valid POSIX shell variable name. Example. isValidPosixName \"foo_bar000\" =&gt; true isValidPosixName \"0-bad.jpg\" =&gt; false Type. string -&gt; bool Arguments. [name] Edit source. Noogle also knows. Aliases. lib.isValidPosixName.",
    "raw_url": "/f/lib/strings/isValidPosixName.html",
    "excerpt": "lib.strings.isValidPosixName. Test whether the given name is a valid POSIX shell variable name. Example. isValidPosixName \"foo_bar000\" =&gt; true isValidPosixName \"0-bad.jpg\" =&gt; false Type. string -&gt; bool Arguments. [name] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/toUpper.html",
    "content": "lib.strings.toUpper. Converts an ASCII string to upper-case. Example. toUpper \"home\" => \"HOME\" Type. toUpper :: string -> string Edit source. Noogle also knows. Aliases. lib.toUpper.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.toUpper"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 7
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.toUpper. Converts an ASCII string to upper-case. Example. toUpper \"home\" =&gt; \"HOME\" Type. toUpper :: string -&gt; string Edit source. Noogle also knows. Aliases. lib.toUpper.",
    "raw_url": "/f/lib/strings/toUpper.html",
    "excerpt": "lib.strings.toUpper. Converts an ASCII string to upper-case. Example. toUpper \"home\" =&gt; \"HOME\" Type. toUpper :: string -&gt; string Edit source. Noogle also knows. Aliases. lib.toUpper.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/cmakeFeature.html",
    "content": "lib.strings.cmakeFeature. Create a -D:STRING= string that can be passed to typical CMake invocations. This is the most typical usage, so it deserves a special case. Example. cmakeFeature \"MODULES\" \"badblock\" => \"-DMODULES:STRING=badblock\" Type. cmakeFeature :: string -> string -> string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [feature] [value] Edit source. Noogle also knows. Aliases. lib.cmakeFeature.",
    "word_count": 67,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.cmakeFeature"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 25
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 57
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.cmakeFeature. Create a -D:STRING= string that can be passed to typical CMake invocations. This is the most typical usage, so it deserves a special case. Example. cmakeFeature \"MODULES\" \"badblock\" =&gt; \"-DMODULES:STRING=badblock\" Type. cmakeFeature :: string -&gt; string -&gt; string @param condition The condition to be made true or false @param flag The controlling flag of the condition Arguments. [feature] [value] Edit source. Noogle also knows. Aliases. lib.cmakeFeature.",
    "raw_url": "/f/lib/strings/cmakeFeature.html",
    "excerpt": "lib.strings.cmakeFeature. Create a -D:STRING= string that can be passed to typical CMake invocations. This is the most typical usage, so it deserves a special case. Example. cmakeFeature \"MODULES\" \"badblock\" =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/mesonEnable.html",
    "content": "lib.strings.mesonEnable. Create a -D={enabled,disabled} string that can be passed to typical Meson invocations. Example. mesonEnable \"docs\" true => \"-Ddocs=enabled\" mesonEnable \"savage\" false => \"-Dsavage=disabled\" Type. mesonEnable :: string -> bool -> string @param feature The feature to be enabled or disabled @param flag The controlling flag Arguments. [feature] [flag] Edit source. Noogle also knows. Aliases. lib.mesonEnable.",
    "word_count": 56,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.mesonEnable"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 24
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 46
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.mesonEnable. Create a -D={enabled,disabled} string that can be passed to typical Meson invocations. Example. mesonEnable \"docs\" true =&gt; \"-Ddocs=enabled\" mesonEnable \"savage\" false =&gt; \"-Dsavage=disabled\" Type. mesonEnable :: string -&gt; bool -&gt; string @param feature The feature to be enabled or disabled @param flag The controlling flag Arguments. [feature] [flag] Edit source. Noogle also knows. Aliases. lib.mesonEnable.",
    "raw_url": "/f/lib/strings/mesonEnable.html",
    "excerpt": "lib.strings.mesonEnable. Create a -D={enabled,disabled} string that can be passed to typical Meson invocations. Example. mesonEnable \"docs\" true =&gt; \"-Ddocs=enabled\" mesonEnable \"savage\" false =&gt; \"-Dsavage=disabled\" Type. mesonEnable :: string -&gt; bool",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/withFeature.html",
    "content": "lib.strings.withFeature. Create an --{with,without}- string that can be passed to standard GNU Autoconf scripts. Example. withFeature true \"shared\" => \"--with-shared\" withFeature false \"shared\" => \"--without-shared\" Arguments. [flag] [feature] Edit source. Noogle also knows. Aliases. lib.withFeature.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.withFeature"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.withFeature. Create an --{with,without}- string that can be passed to standard GNU Autoconf scripts. Example. withFeature true \"shared\" =&gt; \"--with-shared\" withFeature false \"shared\" =&gt; \"--without-shared\" Arguments. [flag] [feature] Edit source. Noogle also knows. Aliases. lib.withFeature.",
    "raw_url": "/f/lib/strings/withFeature.html",
    "excerpt": "lib.strings.withFeature. Create an --{with,without}- string that can be passed to standard GNU Autoconf scripts. Example. withFeature true \"shared\" =&gt; \"--with-shared\" withFeature false \"shared\" =&gt; \"--without-shared\" Arguments. [flag] [feature] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/getVersion.html",
    "content": "lib.strings.getVersion. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the version part from that argument. Example. getVersion \"youtube-dl-2016.01.01\" => \"2016.01.01\" getVersion pkgs.youtube-dl => \"2016.01.01\" Arguments. [x] Edit source. Noogle also knows. Aliases. lib.getVersion.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.getVersion"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.getVersion. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the version part from that argument. Example. getVersion \"youtube-dl-2016.01.01\" =&gt; \"2016.01.01\" getVersion pkgs.youtube-dl =&gt; \"2016.01.01\" Arguments. [x] Edit source. Noogle also knows. Aliases. lib.getVersion.",
    "raw_url": "/f/lib/strings/getVersion.html",
    "excerpt": "lib.strings.getVersion. This function takes an argument that's either a derivation or a derivation's \"name\" attribute and extracts the version part from that argument. Example. getVersion \"youtube-dl-2016.01.01\" =&gt; \"2016.01.01\" getVersion pkgs.youtube-dl",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/versionOlder.html",
    "content": "lib.strings.versionOlder. Return true if string v1 denotes a version older than v2. Example. versionOlder \"1.1\" \"1.2\" => true versionOlder \"1.1\" \"1.1\" => false Arguments. [v1] [v2] Edit source. Noogle also knows. Aliases. lib.versionOlder.",
    "word_count": 33,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.versionOlder"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 23
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.versionOlder. Return true if string v1 denotes a version older than v2. Example. versionOlder \"1.1\" \"1.2\" =&gt; true versionOlder \"1.1\" \"1.1\" =&gt; false Arguments. [v1] [v2] Edit source. Noogle also knows. Aliases. lib.versionOlder.",
    "raw_url": "/f/lib/strings/versionOlder.html",
    "excerpt": "lib.strings.versionOlder. Return true if string v1 denotes a version older than v2. Example. versionOlder \"1.1\" \"1.2\" =&gt; true versionOlder \"1.1\" \"1.1\" =&gt; false Arguments. [v1] [v2] Edit source. Noogle also",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/withFeatureAs.html",
    "content": "lib.strings.withFeatureAs. Create an --{with-=,without-} string that can be passed to standard GNU Autoconf scripts. Example. withFeatureAs true \"shared\" \"foo\" => \"--with-shared=foo\" withFeatureAs false \"shared\" (throw \"ignored\") => \"--without-shared\" Arguments. [flag] [feature] [value] Edit source. Noogle also knows. Aliases. lib.withFeatureAs.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.withFeatureAs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 28
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.withFeatureAs. Create an --{with-=,without-} string that can be passed to standard GNU Autoconf scripts. Example. withFeatureAs true \"shared\" \"foo\" =&gt; \"--with-shared=foo\" withFeatureAs false \"shared\" (throw \"ignored\") =&gt; \"--without-shared\" Arguments. [flag] [feature] [value] Edit source. Noogle also knows. Aliases. lib.withFeatureAs.",
    "raw_url": "/f/lib/strings/withFeatureAs.html",
    "excerpt": "lib.strings.withFeatureAs. Create an --{with-=,without-} string that can be passed to standard GNU Autoconf scripts. Example. withFeatureAs true \"shared\" \"foo\" =&gt; \"--with-shared=foo\" withFeatureAs false \"shared\" (throw \"ignored\") =&gt; \"--without-shared\" Arguments. [flag]",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/substring.html",
    "content": "lib.strings.substring Primop. Takes 3 arguments. start, len, s. Return the substring of s from character position start (zero-based) up to but not including start + len. If start is greater than the length of the string, an empty string is returned, and if start + len lies beyond the end of the string, only the substring up to the end of the string is returned. start must be non-negative. For example, builtins.substring 0 3 \"nixos\" evaluates to \"nix\". Noogle also knows. Aliases. builtins.substring. lib.substring.",
    "word_count": 84,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.substring Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.substring Primop. Takes 3 arguments. start, len, s. Return the substring of s from character position start (zero-based) up to but not including start + len. If start is greater than the length of the string, an empty string is returned, and if start + len lies beyond the end of the string, only the substring up to the end of the string is returned. start must be non-negative. For example, builtins.substring 0 3 \"nixos\" evaluates to \"nix\". Noogle also knows. Aliases. builtins.substring. lib.substring.",
    "raw_url": "/f/lib/strings/substring.html",
    "excerpt": "lib.strings.substring Primop. Takes 3 arguments. start, len, s. Return the substring of s from character position start (zero-based) up to but not including start + len. If start is greater",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/enableFeature.html",
    "content": "lib.strings.enableFeature. Create an --{enable,disable}- string that can be passed to standard GNU Autoconf scripts. Example. enableFeature true \"shared\" => \"--enable-shared\" enableFeature false \"shared\" => \"--disable-shared\" Arguments. [flag] [feature] Edit source. Noogle also knows. Aliases. lib.enableFeature.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.enableFeature"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.enableFeature. Create an --{enable,disable}- string that can be passed to standard GNU Autoconf scripts. Example. enableFeature true \"shared\" =&gt; \"--enable-shared\" enableFeature false \"shared\" =&gt; \"--disable-shared\" Arguments. [flag] [feature] Edit source. Noogle also knows. Aliases. lib.enableFeature.",
    "raw_url": "/f/lib/strings/enableFeature.html",
    "excerpt": "lib.strings.enableFeature. Create an --{enable,disable}- string that can be passed to standard GNU Autoconf scripts. Example. enableFeature true \"shared\" =&gt; \"--enable-shared\" enableFeature false \"shared\" =&gt; \"--disable-shared\" Arguments. [flag] [feature] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/escapeRegex.html",
    "content": "lib.strings.escapeRegex. Turn a string into an exact regular expression. Example. escapeRegex \"[^a-z]*\" => \"\\\\[\\\\^a-z]\\\\*\" Type. string -> string Edit source. Noogle also knows. Aliases. lib.escapeRegex.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.escapeRegex"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.escapeRegex. Turn a string into an exact regular expression. Example. escapeRegex \"[^a-z]*\" =&gt; \"\\\\[\\\\^a-z]\\\\*\" Type. string -&gt; string Edit source. Noogle also knows. Aliases. lib.escapeRegex.",
    "raw_url": "/f/lib/strings/escapeRegex.html",
    "excerpt": "lib.strings.escapeRegex. Turn a string into an exact regular expression. Example. escapeRegex \"[^a-z]*\" =&gt; \"\\\\[\\\\^a-z]\\\\*\" Type. string -&gt; string Edit source. Noogle also knows. Aliases. lib.escapeRegex.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/levenshteinAtMost.html",
    "content": "lib.strings.levenshteinAtMost. Returns whether the levenshtein distance between two strings is at most some value Complexity is O(min(n,m)) for k <= 2 and O(n*m) otherwise. Example. levenshteinAtMost 0 \"foo\" \"foo\" => true levenshteinAtMost 1 \"foo\" \"boa\" => false levenshteinAtMost 2 \"foo\" \"boa\" => true levenshteinAtMost 2 \"This is a sentence\" \"this is a sentense.\" => false levenshteinAtMost 3 \"This is a sentence\" \"this is a sentense.\" => true Type. levenshteinAtMost :: int -> string -> string -> bool Edit source.",
    "word_count": 79,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.levenshteinAtMost"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 67
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.levenshteinAtMost. Returns whether the levenshtein distance between two strings is at most some value Complexity is O(min(n,m)) for k &lt;= 2 and O(n*m) otherwise. Example. levenshteinAtMost 0 \"foo\" \"foo\" =&gt; true levenshteinAtMost 1 \"foo\" \"boa\" =&gt; false levenshteinAtMost 2 \"foo\" \"boa\" =&gt; true levenshteinAtMost 2 \"This is a sentence\" \"this is a sentense.\" =&gt; false levenshteinAtMost 3 \"This is a sentence\" \"this is a sentense.\" =&gt; true Type. levenshteinAtMost :: int -&gt; string -&gt; string -&gt; bool Edit source.",
    "raw_url": "/f/lib/strings/levenshteinAtMost.html",
    "excerpt": "lib.strings.levenshteinAtMost. Returns whether the levenshtein distance between two strings is at most some value Complexity is O(min(n,m)) for k &lt;= 2 and O(n*m) otherwise. Example. levenshteinAtMost 0 \"foo\" \"foo\" =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/splitString.html",
    "content": "lib.strings.splitString. Cut a string with a separator and produces a list of strings which were separated by this separator. Example. splitString \".\" \"foo.bar.baz\" => [ \"foo\" \"bar\" \"baz\" ] splitString \"/\" \"/usr/local/bin\" => [ \"\" \"usr\" \"local\" \"bin\" ] Arguments. [sep] [s] Edit source. Noogle also knows. Aliases. lib.splitString.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.splitString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.splitString. Cut a string with a separator and produces a list of strings which were separated by this separator. Example. splitString \".\" \"foo.bar.baz\" =&gt; [ \"foo\" \"bar\" \"baz\" ] splitString \"/\" \"/usr/local/bin\" =&gt; [ \"\" \"usr\" \"local\" \"bin\" ] Arguments. [sep] [s] Edit source. Noogle also knows. Aliases. lib.splitString.",
    "raw_url": "/f/lib/strings/splitString.html",
    "excerpt": "lib.strings.splitString. Cut a string with a separator and produces a list of strings which were separated by this separator. Example. splitString \".\" \"foo.bar.baz\" =&gt; [ \"foo\" \"bar\" \"baz\" ] splitString",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/sanitizeDerivationName.html",
    "content": "lib.strings.sanitizeDerivationName. Creates a valid derivation name from a potentially invalid one. Example. sanitizeDerivationName \"../hello.bar # foo\" => \"-hello.bar-foo\" sanitizeDerivationName \"\" => \"unknown\" sanitizeDerivationName pkgs.hello => \"-nix-store-2g75chlbpxlrqn15zlby2dfh8hr9qwbk-hello-2.10\" Type. sanitizeDerivationName :: String -> String Edit source.",
    "word_count": 34,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.sanitizeDerivationName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.sanitizeDerivationName. Creates a valid derivation name from a potentially invalid one. Example. sanitizeDerivationName \"../hello.bar # foo\" =&gt; \"-hello.bar-foo\" sanitizeDerivationName \"\" =&gt; \"unknown\" sanitizeDerivationName pkgs.hello =&gt; \"-nix-store-2g75chlbpxlrqn15zlby2dfh8hr9qwbk-hello-2.10\" Type. sanitizeDerivationName :: String -&gt; String Edit source.",
    "raw_url": "/f/lib/strings/sanitizeDerivationName.html",
    "excerpt": "lib.strings.sanitizeDerivationName. Creates a valid derivation name from a potentially invalid one. Example. sanitizeDerivationName \"../hello.bar # foo\" =&gt; \"-hello.bar-foo\" sanitizeDerivationName \"\" =&gt; \"unknown\" sanitizeDerivationName pkgs.hello =&gt; \"-nix-store-2g75chlbpxlrqn15zlby2dfh8hr9qwbk-hello-2.10\" Type. sanitizeDerivationName :: String",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/escapeShellArg.html",
    "content": "lib.strings.escapeShellArg. Quote string to be used safely within the Bourne shell. Example. escapeShellArg \"esc'ape\\nme\" => \"'esc'\\\\''ape\\nme'\" Type. escapeShellArg :: string -> string Arguments. [arg] Edit source. Noogle also knows. Aliases. lib.escapeShellArg.",
    "word_count": 31,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.escapeShellArg"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 16
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 22
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.escapeShellArg. Quote string to be used safely within the Bourne shell. Example. escapeShellArg \"esc'ape\\nme\" =&gt; \"'esc'\\\\''ape\\nme'\" Type. escapeShellArg :: string -&gt; string Arguments. [arg] Edit source. Noogle also knows. Aliases. lib.escapeShellArg.",
    "raw_url": "/f/lib/strings/escapeShellArg.html",
    "excerpt": "lib.strings.escapeShellArg. Quote string to be used safely within the Bourne shell. Example. escapeShellArg \"esc'ape\\nme\" =&gt; \"'esc'\\\\''ape\\nme'\" Type. escapeShellArg :: string -&gt; string Arguments. [arg] Edit source. Noogle also knows. Aliases.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/charToInt.html",
    "content": "lib.strings.charToInt. Convert char to ascii value, must be in printable range. Example. charToInt \"A\" => 65 charToInt \"(\" => 40 Type. charToInt :: string -> int Arguments. [c] Edit source.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.charToInt"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.charToInt. Convert char to ascii value, must be in printable range. Example. charToInt \"A\" =&gt; 65 charToInt \"(\" =&gt; 40 Type. charToInt :: string -&gt; int Arguments. [c] Edit source.",
    "raw_url": "/f/lib/strings/charToInt.html",
    "excerpt": "lib.strings.charToInt. Convert char to ascii value, must be in printable range. Example. charToInt \"A\" =&gt; 65 charToInt \"(\" =&gt; 40 Type. charToInt :: string -&gt; int Arguments. [c] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/toIntBase10.html",
    "content": "lib.strings.toIntBase10. Parse a string as a base 10 int. This supports parsing of zero-padded integers. Example. toIntBase10 \"1337\" => 1337 toIntBase10 \"-4\" => -4 toIntBase10 \" 123 \" => 123 toIntBase10 \"00024\" => 24 toIntBase10 \"3.14\" => error: floating point JSON numbers are not supported Type. string -> int Arguments. [str] Edit source. Noogle also knows. Aliases. lib.toIntBase10.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.toIntBase10"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 45
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 49
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.toIntBase10. Parse a string as a base 10 int. This supports parsing of zero-padded integers. Example. toIntBase10 \"1337\" =&gt; 1337 toIntBase10 \"-4\" =&gt; -4 toIntBase10 \" 123 \" =&gt; 123 toIntBase10 \"00024\" =&gt; 24 toIntBase10 \"3.14\" =&gt; error: floating point JSON numbers are not supported Type. string -&gt; int Arguments. [str] Edit source. Noogle also knows. Aliases. lib.toIntBase10.",
    "raw_url": "/f/lib/strings/toIntBase10.html",
    "excerpt": "lib.strings.toIntBase10. Parse a string as a base 10 int. This supports parsing of zero-padded integers. Example. toIntBase10 \"1337\" =&gt; 1337 toIntBase10 \"-4\" =&gt; -4 toIntBase10 \" 123 \" =&gt; 123",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/tail.html",
    "content": "lib.strings.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should generally be avoided since it's inefficient: unlike Haskell's tail, it takes O(n) time, so recursing over a list by repeatedly calling tail takes O(n^2) time. Noogle also knows. Aliases. builtins.tail. lib.tail. lib.lists.tail.",
    "word_count": 62,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.tail Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should generally be avoided since it's inefficient: unlike Haskell's tail, it takes O(n) time, so recursing over a list by repeatedly calling tail takes O(n^2) time. Noogle also knows. Aliases. builtins.tail. lib.tail. lib.lists.tail.",
    "raw_url": "/f/lib/strings/tail.html",
    "excerpt": "lib.strings.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/elemAt.html",
    "content": "lib.strings.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of bounds. Noogle also knows. Aliases. builtins.elemAt. lib.elemAt. lib.lists.elemAt.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.elemAt Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of bounds. Noogle also knows. Aliases. builtins.elemAt. lib.elemAt. lib.lists.elemAt.",
    "raw_url": "/f/lib/strings/elemAt.html",
    "excerpt": "lib.strings.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/levenshtein.html",
    "content": "lib.strings.levenshtein. Computes the Levenshtein distance between two strings. Complexity O(n*m) where n and m are the lengths of the strings. Algorithm adjusted from https://stackoverflow.com/a/9750974/6605742. Example. levenshtein \"foo\" \"foo\" => 0 levenshtein \"book\" \"hook\" => 1 levenshtein \"hello\" \"Heyo\" => 3 Type. levenshtein :: string -> string -> int Arguments. [a] [b] Edit source.",
    "word_count": 53,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.levenshtein"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 40
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 48
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.levenshtein. Computes the Levenshtein distance between two strings. Complexity O(n*m) where n and m are the lengths of the strings. Algorithm adjusted from https://stackoverflow.com/a/9750974/6605742. Example. levenshtein \"foo\" \"foo\" =&gt; 0 levenshtein \"book\" \"hook\" =&gt; 1 levenshtein \"hello\" \"Heyo\" =&gt; 3 Type. levenshtein :: string -&gt; string -&gt; int Arguments. [a] [b] Edit source.",
    "raw_url": "/f/lib/strings/levenshtein.html",
    "excerpt": "lib.strings.levenshtein. Computes the Levenshtein distance between two strings. Complexity O(n*m) where n and m are the lengths of the strings. Algorithm adjusted from https://stackoverflow.com/a/9750974/6605742. Example. levenshtein \"foo\" \"foo\" =&gt; 0",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/concatImapStrings.html",
    "content": "lib.strings.concatImapStrings. Like concatMapStrings except that the f functions also gets the position as a parameter. Example. concatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"] => \"1-foo2-bar\" Type. concatImapStrings :: (int -> a -> string) -> [a] -> string Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.concatImapStrings.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.concatImapStrings"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 37
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.concatImapStrings. Like concatMapStrings except that the f functions also gets the position as a parameter. Example. concatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"] =&gt; \"1-foo2-bar\" Type. concatImapStrings :: (int -&gt; a -&gt; string) -&gt; [a] -&gt; string Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.concatImapStrings.",
    "raw_url": "/f/lib/strings/concatImapStrings.html",
    "excerpt": "lib.strings.concatImapStrings. Like concatMapStrings except that the f functions also gets the position as a parameter. Example. concatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"] =&gt; \"1-foo2-bar\" Type. concatImapStrings :: (int -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/normalizePath.html",
    "content": "lib.strings.normalizePath. Normalize path, removing extraneous /s. Example. normalizePath \"/a//b///c/\" => \"/a/b/c/\" Type. normalizePath :: string -> string Arguments. [s] Edit source.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.normalizePath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 6
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 11
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.normalizePath. Normalize path, removing extraneous /s. Example. normalizePath \"/a//b///c/\" =&gt; \"/a/b/c/\" Type. normalizePath :: string -&gt; string Arguments. [s] Edit source.",
    "raw_url": "/f/lib/strings/normalizePath.html",
    "excerpt": "lib.strings.normalizePath. Normalize path, removing extraneous /s. Example. normalizePath \"/a//b///c/\" =&gt; \"/a/b/c/\" Type. normalizePath :: string -&gt; string Arguments. [s] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/isAttrs.html",
    "content": "lib.strings.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. builtins.isAttrs. lib.isAttrs. lib.attrsets.isAttrs.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.isAttrs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. builtins.isAttrs. lib.isAttrs. lib.attrsets.isAttrs.",
    "raw_url": "/f/lib/strings/isAttrs.html",
    "excerpt": "lib.strings.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. builtins.isAttrs. lib.isAttrs. lib.attrsets.isAttrs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/isCoercibleToString.html",
    "content": "lib.strings.isCoercibleToString. Soft-deprecated function. While the original implementation is available as isConvertibleWithToString, consider using isStringLike instead, if suitable. Edit source.",
    "word_count": 19,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.isCoercibleToString"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.isCoercibleToString. Soft-deprecated function. While the original implementation is available as isConvertibleWithToString, consider using isStringLike instead, if suitable. Edit source.",
    "raw_url": "/f/lib/strings/isCoercibleToString.html",
    "excerpt": "lib.strings.isCoercibleToString. Soft-deprecated function. While the original implementation is available as isConvertibleWithToString, consider using isStringLike instead, if suitable. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/versionAtLeast.html",
    "content": "lib.strings.versionAtLeast. Return true if string v1 denotes a version equal to or newer than v2. Example. versionAtLeast \"1.1\" \"1.0\" => true versionAtLeast \"1.1\" \"1.1\" => true versionAtLeast \"1.1\" \"1.2\" => false Arguments. [v1] [v2] Edit source. Noogle also knows. Aliases. lib.versionAtLeast.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.versionAtLeast"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 31
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.versionAtLeast. Return true if string v1 denotes a version equal to or newer than v2. Example. versionAtLeast \"1.1\" \"1.0\" =&gt; true versionAtLeast \"1.1\" \"1.1\" =&gt; true versionAtLeast \"1.1\" \"1.2\" =&gt; false Arguments. [v1] [v2] Edit source. Noogle also knows. Aliases. lib.versionAtLeast.",
    "raw_url": "/f/lib/strings/versionAtLeast.html",
    "excerpt": "lib.strings.versionAtLeast. Return true if string v1 denotes a version equal to or newer than v2. Example. versionAtLeast \"1.1\" \"1.0\" =&gt; true versionAtLeast \"1.1\" \"1.1\" =&gt; true versionAtLeast \"1.1\" \"1.2\" =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/fixedWidthNumber.html",
    "content": "lib.strings.fixedWidthNumber. Format a number adding leading zeroes up to fixed width. Example. fixedWidthNumber 5 15 => \"00015\" Arguments. [width] [n] Edit source. Noogle also knows. Aliases. lib.fixedWidthNumber.",
    "word_count": 27,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.fixedWidthNumber"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.fixedWidthNumber. Format a number adding leading zeroes up to fixed width. Example. fixedWidthNumber 5 15 =&gt; \"00015\" Arguments. [width] [n] Edit source. Noogle also knows. Aliases. lib.fixedWidthNumber.",
    "raw_url": "/f/lib/strings/fixedWidthNumber.html",
    "excerpt": "lib.strings.fixedWidthNumber. Format a number adding leading zeroes up to fixed width. Example. fixedWidthNumber 5 15 =&gt; \"00015\" Arguments. [width] [n] Edit source. Noogle also knows. Aliases. lib.fixedWidthNumber.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/match.html",
    "content": "lib.strings.match Primop. Takes 2 arguments. regex, str. Returns a list if the extended POSIX regular expression regex matches str precisely, otherwise returns null. Each item in the list is a regex group. builtins.match \"ab\" \"abc\" Evaluates to null. builtins.match \"abc\" \"abc\" Evaluates to [ ]. builtins.match \"a(b)(c)\" \"abc\" Evaluates to [ \"b\" \"c\" ]. builtins.match \"[[:space:]]+([[:upper:]]+)[[:space:]]+\" \" FOO \" Evaluates to [ \"FOO\" ]. Noogle also knows. Aliases. builtins.match.",
    "word_count": 69,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.match Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.match Primop. Takes 2 arguments. regex, str. Returns a list if the extended POSIX regular expression regex matches str precisely, otherwise returns null. Each item in the list is a regex group. builtins.match \"ab\" \"abc\" Evaluates to null. builtins.match \"abc\" \"abc\" Evaluates to [ ]. builtins.match \"a(b)(c)\" \"abc\" Evaluates to [ \"b\" \"c\" ]. builtins.match \"[[:space:]]+([[:upper:]]+)[[:space:]]+\" \" FOO \" Evaluates to [ \"FOO\" ]. Noogle also knows. Aliases. builtins.match.",
    "raw_url": "/f/lib/strings/match.html",
    "excerpt": "lib.strings.match Primop. Takes 2 arguments. regex, str. Returns a list if the extended POSIX regular expression regex matches str precisely, otherwise returns null. Each item in the list is a",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/toLower.html",
    "content": "lib.strings.toLower. Converts an ASCII string to lower-case. Example. toLower \"HOME\" => \"home\" Type. toLower :: string -> string Edit source. Noogle also knows. Aliases. lib.toLower.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.toLower"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 7
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.toLower. Converts an ASCII string to lower-case. Example. toLower \"HOME\" =&gt; \"home\" Type. toLower :: string -&gt; string Edit source. Noogle also knows. Aliases. lib.toLower.",
    "raw_url": "/f/lib/strings/toLower.html",
    "excerpt": "lib.strings.toLower. Converts an ASCII string to lower-case. Example. toLower \"HOME\" =&gt; \"home\" Type. toLower :: string -&gt; string Edit source. Noogle also knows. Aliases. lib.toLower.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/hasInfix.html",
    "content": "lib.strings.hasInfix. Determine whether a string contains the given infix. Example. hasInfix \"bc\" \"abcd\" => true hasInfix \"ab\" \"abcd\" => true hasInfix \"cd\" \"abcd\" => true hasInfix \"foo\" \"abcd\" => false Type. hasInfix :: string -> string -> bool Arguments. [infix] [content] Edit source. Noogle also knows. Aliases. lib.hasInfix.",
    "word_count": 48,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.hasInfix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 30
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 38
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.hasInfix. Determine whether a string contains the given infix. Example. hasInfix \"bc\" \"abcd\" =&gt; true hasInfix \"ab\" \"abcd\" =&gt; true hasInfix \"cd\" \"abcd\" =&gt; true hasInfix \"foo\" \"abcd\" =&gt; false Type. hasInfix :: string -&gt; string -&gt; bool Arguments. [infix] [content] Edit source. Noogle also knows. Aliases. lib.hasInfix.",
    "raw_url": "/f/lib/strings/hasInfix.html",
    "excerpt": "lib.strings.hasInfix. Determine whether a string contains the given infix. Example. hasInfix \"bc\" \"abcd\" =&gt; true hasInfix \"ab\" \"abcd\" =&gt; true hasInfix \"cd\" \"abcd\" =&gt; true hasInfix \"foo\" \"abcd\" =&gt; false",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/isStorePath.html",
    "content": "lib.strings.isStorePath. Check whether a value is a store path. Example. isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11/bin/python\" => false isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11\" => true isStorePath pkgs.python => true isStorePath [] || isStorePath 42 || isStorePath {} || … => false Arguments. [x] Edit source. Noogle also knows. Aliases. lib.isStorePath.",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.isStorePath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 34
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.isStorePath. Check whether a value is a store path. Example. isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11/bin/python\" =&gt; false isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11\" =&gt; true isStorePath pkgs.python =&gt; true isStorePath [] || isStorePath 42 || isStorePath {} || … =&gt; false Arguments. [x] Edit source. Noogle also knows. Aliases. lib.isStorePath.",
    "raw_url": "/f/lib/strings/isStorePath.html",
    "excerpt": "lib.strings.isStorePath. Check whether a value is a store path. Example. isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11/bin/python\" =&gt; false isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11\" =&gt; true isStorePath pkgs.python =&gt; true isStorePath [] || isStorePath 42 || isStorePath {}",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/floatToString.html",
    "content": "lib.strings.floatToString. Convert a float to a string, but emit a warning when precision is lost during the conversion. Example. floatToString 0.000001 => \"0.000001\" floatToString 0.0000001 => trace: warning: Imprecise conversion from float to string 0.000000 \"0.000000\" Arguments. [float] Edit source.",
    "word_count": 40,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.floatToString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 36
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.floatToString. Convert a float to a string, but emit a warning when precision is lost during the conversion. Example. floatToString 0.000001 =&gt; \"0.000001\" floatToString 0.0000001 =&gt; trace: warning: Imprecise conversion from float to string 0.000000 \"0.000000\" Arguments. [float] Edit source.",
    "raw_url": "/f/lib/strings/floatToString.html",
    "excerpt": "lib.strings.floatToString. Convert a float to a string, but emit a warning when precision is lost during the conversion. Example. floatToString 0.000001 =&gt; \"0.000001\" floatToString 0.0000001 =&gt; trace: warning: Imprecise conversion",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/toShellVar.html",
    "content": "lib.strings.toShellVar. Translate a Nix value into a shell variable declaration, with proper escaping. The value can be a string (mapped to a regular variable), a list of strings (mapped to a Bash-style array) or an attribute set of strings (mapped to a Bash-style associative array). Note that \"string\" includes string-coercible values like paths or derivations. Strings are translated into POSIX sh-compatible code; lists and attribute sets assume a shell that understands Bash syntax (e.g. Bash or ZSH). Example. '' ${toShellVar \"foo\" \"some string\"} [[ \"$foo\" == \"some string\" ]] '' Type. string -> (string | listOf string | attrsOf string) -> string Arguments. [name] [value] Edit source. Noogle also knows. Aliases. lib.toShellVar.",
    "word_count": 112,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.toShellVar"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 77
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 90
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 102
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.toShellVar. Translate a Nix value into a shell variable declaration, with proper escaping. The value can be a string (mapped to a regular variable), a list of strings (mapped to a Bash-style array) or an attribute set of strings (mapped to a Bash-style associative array). Note that \"string\" includes string-coercible values like paths or derivations. Strings are translated into POSIX sh-compatible code; lists and attribute sets assume a shell that understands Bash syntax (e.g. Bash or ZSH). Example. '' ${toShellVar \"foo\" \"some string\"} [[ \"$foo\" == \"some string\" ]] '' Type. string -&gt; (string | listOf string | attrsOf string) -&gt; string Arguments. [name] [value] Edit source. Noogle also knows. Aliases. lib.toShellVar.",
    "raw_url": "/f/lib/strings/toShellVar.html",
    "excerpt": "lib.strings.toShellVar. Translate a Nix value into a shell variable declaration, with proper escaping. The value can be a string (mapped to a regular variable), a list of strings (mapped to",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/elem.html",
    "content": "lib.strings.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. builtins.elem. lib.elem. lib.lists.elem.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.elem Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. builtins.elem. lib.elem. lib.lists.elem.",
    "raw_url": "/f/lib/strings/elem.html",
    "excerpt": "lib.strings.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. builtins.elem. lib.elem. lib.lists.elem.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/concatStrings.html",
    "content": "lib.strings.concatStrings. Concatenate a list of strings. Example. concatStrings [\"foo\" \"bar\"] => \"foobar\" Type. concatStrings :: [string] -> string Edit source. Noogle also knows. Aliases. lib.concatStrings.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.concatStrings"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 6
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.concatStrings. Concatenate a list of strings. Example. concatStrings [\"foo\" \"bar\"] =&gt; \"foobar\" Type. concatStrings :: [string] -&gt; string Edit source. Noogle also knows. Aliases. lib.concatStrings.",
    "raw_url": "/f/lib/strings/concatStrings.html",
    "excerpt": "lib.strings.concatStrings. Concatenate a list of strings. Example. concatStrings [\"foo\" \"bar\"] =&gt; \"foobar\" Type. concatStrings :: [string] -&gt; string Edit source. Noogle also knows. Aliases. lib.concatStrings.",
    "sub_results": []
  },
  {
    "url": "/f/lib/strings/isInt.html",
    "content": "lib.strings.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. builtins.isInt. lib.isInt. lib.trivial.isInt.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.strings.isInt Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.strings.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. builtins.isInt. lib.isInt. lib.trivial.isInt.",
    "raw_url": "/f/lib/strings/isInt.html",
    "excerpt": "lib.strings.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. builtins.isInt. lib.isInt. lib.trivial.isInt.",
    "sub_results": []
  },
  {
    "url": "/f/lib/remove.html",
    "content": "lib.remove. Remove elements equal to 'e' from a list. Useful for buildInputs. Example. remove 3 [ 1 3 4 3 ] => [ 1 4 ] Type. remove :: a -> [a] -> [a] Arguments. [e] Element to remove from the list. Edit source. Noogle also knows. Aliases. lib.lists.remove.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.remove"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 26
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 34
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.remove. Remove elements equal to 'e' from a list. Useful for buildInputs. Example. remove 3 [ 1 3 4 3 ] =&gt; [ 1 4 ] Type. remove :: a -&gt; [a] -&gt; [a] Arguments. [e] Element to remove from the list. Edit source. Noogle also knows. Aliases. lib.lists.remove.",
    "raw_url": "/f/lib/remove.html",
    "excerpt": "lib.remove. Remove elements equal to 'e' from a list. Useful for buildInputs. Example. remove 3 [ 1 3 4 3 ] =&gt; [ 1 4 ] Type. remove :: a",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/meta.html",
    "content": "lib.mergeAttrBy.meta. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -> attrs -> attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } => { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.meta.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.meta"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.meta. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } =&gt; { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.meta.",
    "raw_url": "/f/lib/mergeAttrBy/meta.html",
    "excerpt": "lib.mergeAttrBy.meta. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/preConfigure.html",
    "content": "lib.mergeAttrBy.preConfigure. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.preConfigure.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.preConfigure"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.preConfigure. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.preConfigure.",
    "raw_url": "/f/lib/mergeAttrBy/preConfigure.html",
    "excerpt": "lib.mergeAttrBy.preConfigure. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.preConfigure.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/propagatedBuildInputs.html",
    "content": "lib.mergeAttrBy.propagatedBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.propagatedBuildInputs.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.propagatedBuildInputs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.propagatedBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.propagatedBuildInputs.",
    "raw_url": "/f/lib/mergeAttrBy/propagatedBuildInputs.html",
    "excerpt": "lib.mergeAttrBy.propagatedBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/prePhases.html",
    "content": "lib.mergeAttrBy.prePhases. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.prePhases.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.prePhases"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.prePhases. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.prePhases.",
    "raw_url": "/f/lib/mergeAttrBy/prePhases.html",
    "excerpt": "lib.mergeAttrBy.prePhases. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/postInstall.html",
    "content": "lib.mergeAttrBy.postInstall. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.postInstall.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.postInstall"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.postInstall. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.postInstall.",
    "raw_url": "/f/lib/mergeAttrBy/postInstall.html",
    "excerpt": "lib.mergeAttrBy.postInstall. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.postInstall.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/flags.html",
    "content": "lib.mergeAttrBy.flags. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -> attrs -> attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } => { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.flags.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.flags"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.flags. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } =&gt; { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.flags.",
    "raw_url": "/f/lib/mergeAttrBy/flags.html",
    "excerpt": "lib.mergeAttrBy.flags. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/patches.html",
    "content": "lib.mergeAttrBy.patches. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.patches.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.patches"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.patches. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.patches.",
    "raw_url": "/f/lib/mergeAttrBy/patches.html",
    "excerpt": "lib.mergeAttrBy.patches. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/postAll.html",
    "content": "lib.mergeAttrBy.postAll. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.postAll.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.postAll"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.postAll. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.postAll.",
    "raw_url": "/f/lib/mergeAttrBy/postAll.html",
    "excerpt": "lib.mergeAttrBy.postAll. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/buildInputs.html",
    "content": "lib.mergeAttrBy.buildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.buildInputs.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.buildInputs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.buildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.buildInputs.",
    "raw_url": "/f/lib/mergeAttrBy/buildInputs.html",
    "excerpt": "lib.mergeAttrBy.buildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/passthru.html",
    "content": "lib.mergeAttrBy.passthru. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -> attrs -> attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } => { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.passthru.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.passthru"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.passthru. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } =&gt; { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.passthru.",
    "raw_url": "/f/lib/mergeAttrBy/passthru.html",
    "excerpt": "lib.mergeAttrBy.passthru. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/cfg.html",
    "content": "lib.mergeAttrBy.cfg. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -> attrs -> attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } => { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.cfg.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.cfg"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.cfg. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } =&gt; { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.cfg.",
    "raw_url": "/f/lib/mergeAttrBy/cfg.html",
    "excerpt": "lib.mergeAttrBy.cfg. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/nativeBuildInputs.html",
    "content": "lib.mergeAttrBy.nativeBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.nativeBuildInputs.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.nativeBuildInputs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.nativeBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.nativeBuildInputs.",
    "raw_url": "/f/lib/mergeAttrBy/nativeBuildInputs.html",
    "excerpt": "lib.mergeAttrBy.nativeBuildInputs. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrBy/configureFlags.html",
    "content": "lib.mergeAttrBy.configureFlags. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.configureFlags.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrBy.configureFlags"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrBy.configureFlags. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrBy.configureFlags.",
    "raw_url": "/f/lib/mergeAttrBy/configureFlags.html",
    "excerpt": "lib.mergeAttrBy.configureFlags. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkOptionDefault.html",
    "content": "lib.mkOptionDefault. Noogle also knows. Aliases. lib.modules.mkOptionDefault.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkOptionDefault"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkOptionDefault. Noogle also knows. Aliases. lib.modules.mkOptionDefault.",
    "raw_url": "/f/lib/mkOptionDefault.html",
    "excerpt": "lib.mkOptionDefault. Noogle also knows. Aliases. lib.modules.mkOptionDefault.",
    "sub_results": []
  },
  {
    "url": "/f/lib/cleanSource.html",
    "content": "lib.cleanSource. Filters a source tree removing version control files and directories using cleanSourceFilter. Example. cleanSource ./. Arguments. [src] Edit source. Noogle also knows. Aliases. lib.sources.cleanSource.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.cleanSource"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 16
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.cleanSource. Filters a source tree removing version control files and directories using cleanSourceFilter. Example. cleanSource ./. Arguments. [src] Edit source. Noogle also knows. Aliases. lib.sources.cleanSource.",
    "raw_url": "/f/lib/cleanSource.html",
    "excerpt": "lib.cleanSource. Filters a source tree removing version control files and directories using cleanSourceFilter. Example. cleanSource ./. Arguments. [src] Edit source. Noogle also knows. Aliases. lib.sources.cleanSource.",
    "sub_results": []
  },
  {
    "url": "/f/lib/literalExample.html",
    "content": "lib.literalExample. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values, e.g. functions, or values that depend on other values or packages. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.options.literalExample.",
    "word_count": 50,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.literalExample"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.literalExample. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values, e.g. functions, or values that depend on other values or packages. Arguments. [text] Edit source. Noogle also knows. Aliases. lib.options.literalExample.",
    "raw_url": "/f/lib/literalExample.html",
    "excerpt": "lib.literalExample. For use in the defaultText and example option attributes. Causes the given string to be rendered verbatim in the documentation as Nix code. This is necessary for complex values,",
    "sub_results": []
  },
  {
    "url": "/f/lib/isFloat.html",
    "content": "lib.isFloat Primop. Takes 1 arguments. e. Return true if e evaluates to a float, and false otherwise. Noogle also knows. Aliases. builtins.isFloat. lib.trivial.isFloat.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isFloat Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isFloat Primop. Takes 1 arguments. e. Return true if e evaluates to a float, and false otherwise. Noogle also knows. Aliases. builtins.isFloat. lib.trivial.isFloat.",
    "raw_url": "/f/lib/isFloat.html",
    "excerpt": "lib.isFloat Primop. Takes 1 arguments. e. Return true if e evaluates to a float, and false otherwise. Noogle also knows. Aliases. builtins.isFloat. lib.trivial.isFloat.",
    "sub_results": []
  },
  {
    "url": "/f/lib/bitAnd.html",
    "content": "lib.bitAnd Primop. Takes 2 arguments. e1, e2. bitwise “and” Edit source. Noogle also knows. Aliases. builtins.bitAnd. lib.trivial.bitAnd.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.bitAnd Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.bitAnd Primop. Takes 2 arguments. e1, e2. bitwise “and” Edit source. Noogle also knows. Aliases. builtins.bitAnd. lib.trivial.bitAnd.",
    "raw_url": "/f/lib/bitAnd.html",
    "excerpt": "lib.bitAnd Primop. Takes 2 arguments. e1, e2. bitwise “and” Edit source. Noogle also knows. Aliases. builtins.bitAnd. lib.trivial.bitAnd.",
    "sub_results": []
  },
  {
    "url": "/f/lib/warnIfNot.html",
    "content": "lib.warnIfNot. Like warnIf, but negated (warn if the first argument is false). Type. bool -> string -> a -> a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.warnIfNot.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.warnIfNot"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.warnIfNot. Like warnIf, but negated (warn if the first argument is false). Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.warnIfNot.",
    "raw_url": "/f/lib/warnIfNot.html",
    "excerpt": "lib.warnIfNot. Like warnIf, but negated (warn if the first argument is false). Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.warnIfNot.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeOptionDecls.html",
    "content": "lib.mergeOptionDecls. Merge multiple option declarations into a single declaration. In general, there should be only one declaration of each option. The exception is the ‘options’ attribute, which specifies sub-options. These can be specified multiple times to allow one module to add sub-options to an option declared somewhere else (e.g. multiple modules define sub-options for ‘fileSystems’). 'loc' is the list of attribute names where the option is located. 'opts' is a list of modules. Each module has an options attribute which correspond to the definition of 'loc' in 'opt.file'. Arguments. [loc] [opts] Edit source. Noogle also knows. Aliases. lib.modules.mergeOptionDecls.",
    "word_count": 98,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeOptionDecls"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 88
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeOptionDecls. Merge multiple option declarations into a single declaration. In general, there should be only one declaration of each option. The exception is the ‘options’ attribute, which specifies sub-options. These can be specified multiple times to allow one module to add sub-options to an option declared somewhere else (e.g. multiple modules define sub-options for ‘fileSystems’). 'loc' is the list of attribute names where the option is located. 'opts' is a list of modules. Each module has an options attribute which correspond to the definition of 'loc' in 'opt.file'. Arguments. [loc] [opts] Edit source. Noogle also knows. Aliases. lib.modules.mergeOptionDecls.",
    "raw_url": "/f/lib/mergeOptionDecls.html",
    "excerpt": "lib.mergeOptionDecls. Merge multiple option declarations into a single declaration. In general, there should be only one declaration of each option. The exception is the ‘options’ attribute, which specifies sub-options. These",
    "sub_results": []
  },
  {
    "url": "/f/lib/composeExtensions.html",
    "content": "lib.composeExtensions. Compose two extending functions of the type expected by 'extends' into one where changes made in the first are available in the 'super' of the second. Arguments. [f] [g] [final] [prev] Edit source. Noogle also knows. Aliases. lib.fixedPoints.composeExtensions.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.composeExtensions"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.composeExtensions. Compose two extending functions of the type expected by 'extends' into one where changes made in the first are available in the 'super' of the second. Arguments. [f] [g] [final] [prev] Edit source. Noogle also knows. Aliases. lib.fixedPoints.composeExtensions.",
    "raw_url": "/f/lib/composeExtensions.html",
    "excerpt": "lib.composeExtensions. Compose two extending functions of the type expected by 'extends' into one where changes made in the first are available in the 'super' of the second. Arguments. [f] [g]",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrs.html",
    "content": "lib.mergeAttrs. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -> attrs -> attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } => { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.trivial.mergeAttrs.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrs. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } =&gt; { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.trivial.mergeAttrs.",
    "raw_url": "/f/lib/mergeAttrs.html",
    "excerpt": "lib.mergeAttrs. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/isOptionType.html",
    "content": "lib.isOptionType. Noogle also knows. Aliases. lib.types.isOptionType.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isOptionType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isOptionType. Noogle also knows. Aliases. lib.types.isOptionType.",
    "raw_url": "/f/lib/isOptionType.html",
    "excerpt": "lib.isOptionType. Noogle also knows. Aliases. lib.types.isOptionType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/showOptionWithDefLocs.html",
    "content": "lib.showOptionWithDefLocs. Edit source. Noogle also knows. Aliases. lib.options.showOptionWithDefLocs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.showOptionWithDefLocs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.showOptionWithDefLocs. Edit source. Noogle also knows. Aliases. lib.options.showOptionWithDefLocs.",
    "raw_url": "/f/lib/showOptionWithDefLocs.html",
    "excerpt": "lib.showOptionWithDefLocs. Edit source. Noogle also knows. Aliases. lib.options.showOptionWithDefLocs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsToList.html",
    "content": "lib.attrsToList. Deconstruct an attrset to a list of name-value pairs as expected by builtins.listToAttrs. Each element of the resulting list is an attribute set with these attributes: name (string): The name of the attribute. value (any): The value of the attribute The following is always true: builtins.listToAttrs (attrsToList attrs) == attrs :::{.warning} The opposite is not always true. In general expect that. attrsToList (builtins.listToAttrs list) != list This is because the listToAttrs removes duplicate names and doesn't preserve the order of the list. ::: Example. attrsToList { foo = 1; bar = \"asdf\"; } => [ { name = \"bar\"; value = \"asdf\"; } { name = \"foo\"; value = 1; } ] Type. attrsToList :: AttrSet -> [ { name :: String; value :: Any; } ] Edit source. Noogle also knows. Aliases. lib.attrsets.attrsToList.",
    "word_count": 135,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsToList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 84
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 113
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsToList. Deconstruct an attrset to a list of name-value pairs as expected by builtins.listToAttrs. Each element of the resulting list is an attribute set with these attributes: name (string): The name of the attribute. value (any): The value of the attribute The following is always true: builtins.listToAttrs (attrsToList attrs) == attrs :::{.warning} The opposite is not always true. In general expect that. attrsToList (builtins.listToAttrs list) != list This is because the listToAttrs removes duplicate names and doesn't preserve the order of the list. ::: Example. attrsToList { foo = 1; bar = \"asdf\"; } =&gt; [ { name = \"bar\"; value = \"asdf\"; } { name = \"foo\"; value = 1; } ] Type. attrsToList :: AttrSet -&gt; [ { name :: String; value :: Any; } ] Edit source. Noogle also knows. Aliases. lib.attrsets.attrsToList.",
    "raw_url": "/f/lib/attrsToList.html",
    "excerpt": "lib.attrsToList. Deconstruct an attrset to a list of name-value pairs as expected by builtins.listToAttrs. Each element of the resulting list is an attribute set with these attributes: name (string): The",
    "sub_results": []
  },
  {
    "url": "/f/lib/pathIsGitRepo.html",
    "content": "lib.pathIsGitRepo. Edit source. Noogle also knows. Aliases. lib.sources.pathIsGitRepo.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.pathIsGitRepo"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.pathIsGitRepo. Edit source. Noogle also knows. Aliases. lib.sources.pathIsGitRepo.",
    "raw_url": "/f/lib/pathIsGitRepo.html",
    "excerpt": "lib.pathIsGitRepo. Edit source. Noogle also knows. Aliases. lib.sources.pathIsGitRepo.",
    "sub_results": []
  },
  {
    "url": "/f/lib/foldl'.html",
    "content": "lib.foldl' (Prime). Reduce a list by applying a binary operator from left to right, starting with an initial accumulator. Before each application of the operator, the accumulator value is evaluated. This behavior makes this function stricter than foldl. Unlike builtins.foldl', the initial accumulator argument is evaluated before the first iteration. A call like. foldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ] is (denotationally) equivalent to the following, but with the added benefit that foldl' itself will never overflow the stack. let acc₁ = builtins.seq acc₀ (op acc₀ x₀ ); acc₂ = builtins.seq acc₁ (op acc₁ x₁ ); acc₃ = builtins.seq acc₂ (op acc₂ x₂ ); ... accₙ = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁); accₙ₊₁ = builtins.seq accₙ (op accₙ xₙ ); in accₙ₊₁ # Or ignoring builtins.seq op (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ Example. foldl' (acc: x: acc + x) 0 [1 2 3] => 6 Type. foldl' :: (acc -> x -> acc) -> acc -> [x] -> acc Arguments. [op] The binary operation to run, where the two arguments are: acc: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration. x: The corresponding list element for this iteration. [acc] The initial accumulator value. [list] The list to fold. Edit source. Noogle also knows. Aliases. lib.lists.foldl'",
    "word_count": 227,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.foldl' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 143
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 156
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 170
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.foldl' (Prime). Reduce a list by applying a binary operator from left to right, starting with an initial accumulator. Before each application of the operator, the accumulator value is evaluated. This behavior makes this function stricter than foldl. Unlike builtins.foldl', the initial accumulator argument is evaluated before the first iteration. A call like. foldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ] is (denotationally) equivalent to the following, but with the added benefit that foldl' itself will never overflow the stack. let acc₁ = builtins.seq acc₀ (op acc₀ x₀ ); acc₂ = builtins.seq acc₁ (op acc₁ x₁ ); acc₃ = builtins.seq acc₂ (op acc₂ x₂ ); ... accₙ = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁); accₙ₊₁ = builtins.seq accₙ (op accₙ xₙ ); in accₙ₊₁ # Or ignoring builtins.seq op (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ Example. foldl' (acc: x: acc + x) 0 [1 2 3] =&gt; 6 Type. foldl' :: (acc -&gt; x -&gt; acc) -&gt; acc -&gt; [x] -&gt; acc Arguments. [op] The binary operation to run, where the two arguments are: acc: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration. x: The corresponding list element for this iteration. [acc] The initial accumulator value. [list] The list to fold. Edit source. Noogle also knows. Aliases. lib.lists.foldl'",
    "raw_url": "/f/lib/foldl'.html",
    "excerpt": "lib.foldl' (Prime). Reduce a list by applying a binary operator from left to right, starting with an initial accumulator. Before each application of the operator, the accumulator value is evaluated.",
    "sub_results": []
  },
  {
    "url": "/f/lib/extend.html",
    "content": "lib.extend. Edit source. Noogle also knows. Aliases. pkgs.extend.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.extend"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.extend. Edit source. Noogle also knows. Aliases. pkgs.extend.",
    "raw_url": "/f/lib/extend.html",
    "excerpt": "lib.extend. Edit source. Noogle also knows. Aliases. pkgs.extend.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkRenamedOptionModuleWith.html",
    "content": "lib.mkRenamedOptionModuleWith. Edit source. Noogle also knows. Aliases. lib.modules.mkRenamedOptionModuleWith.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkRenamedOptionModuleWith"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkRenamedOptionModuleWith. Edit source. Noogle also knows. Aliases. lib.modules.mkRenamedOptionModuleWith.",
    "raw_url": "/f/lib/mkRenamedOptionModuleWith.html",
    "excerpt": "lib.mkRenamedOptionModuleWith. Edit source. Noogle also knows. Aliases. lib.modules.mkRenamedOptionModuleWith.",
    "sub_results": []
  },
  {
    "url": "/f/lib/cartesianProductOfSets.html",
    "content": "lib.cartesianProductOfSets. Return the cartesian product of attribute set value combinations. Example. cartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; } => [ { a = 1; b = 10; } { a = 1; b = 20; } { a = 2; b = 10; } { a = 2; b = 20; } ] Type. cartesianProductOfSets :: AttrSet -> [AttrSet] Arguments. [attrsOfLists] Attribute set with attributes that are lists of values. Edit source. Noogle also knows. Aliases. lib.attrsets.cartesianProductOfSets.",
    "word_count": 85,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.cartesianProductOfSets"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 61
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 67
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.cartesianProductOfSets. Return the cartesian product of attribute set value combinations. Example. cartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; } =&gt; [ { a = 1; b = 10; } { a = 1; b = 20; } { a = 2; b = 10; } { a = 2; b = 20; } ] Type. cartesianProductOfSets :: AttrSet -&gt; [AttrSet] Arguments. [attrsOfLists] Attribute set with attributes that are lists of values. Edit source. Noogle also knows. Aliases. lib.attrsets.cartesianProductOfSets.",
    "raw_url": "/f/lib/cartesianProductOfSets.html",
    "excerpt": "lib.cartesianProductOfSets. Return the cartesian product of attribute set value combinations. Example. cartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; } =&gt; [ { a",
    "sub_results": []
  },
  {
    "url": "/f/lib/escapeRegex.html",
    "content": "lib.escapeRegex. Turn a string into an exact regular expression. Example. escapeRegex \"[^a-z]*\" => \"\\\\[\\\\^a-z]\\\\*\" Type. string -> string Edit source. Noogle also knows. Aliases. lib.strings.escapeRegex.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.escapeRegex"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.escapeRegex. Turn a string into an exact regular expression. Example. escapeRegex \"[^a-z]*\" =&gt; \"\\\\[\\\\^a-z]\\\\*\" Type. string -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.escapeRegex.",
    "raw_url": "/f/lib/escapeRegex.html",
    "excerpt": "lib.escapeRegex. Turn a string into an exact regular expression. Example. escapeRegex \"[^a-z]*\" =&gt; \"\\\\[\\\\^a-z]\\\\*\" Type. string -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.escapeRegex.",
    "sub_results": []
  },
  {
    "url": "/f/lib/updateManyAttrsByPath.html",
    "content": "lib.updateManyAttrsByPath. Update or set specific paths of an attribute set. Takes a list of updates to apply and an attribute set to apply them to, and returns the attribute set with the updates applied. Updates are represented as { path = ...; update = ...; } values, where path is a list of strings representing the attribute path that should be updated, and update is a function that takes the old value at that attribute path as an argument and returns the new value it should be. Properties: Updates to deeper attribute paths are applied before updates to more shallow attribute paths. Multiple updates to the same attribute path are applied in the order they appear in the update list. If any but the last path element leads into a value that is not an attribute set, an error is thrown. If there is an update for an attribute path that doesn't exist, accessing the argument in the update function causes an error, but intermediate attribute sets are implicitly created as needed. Example. updateManyAttrsByPath [ { path = [ \"a\" \"b\" ]; update = old: { d = old.c; }; } { path = [ \"a\" \"b\" \"c\" ]; update = old: old + 1; } { path = [ \"x\" \"y\" ]; update = old: \"xy\"; } ] { a.b.c = 0; } => { a = { b = { d = 1; }; }; x = { y = \"xy\"; }; } Type. updateManyAttrsByPath :: [{ path :: [String]; update :: (Any -> Any); }] -> AttrSet -> AttrSet Edit source. Noogle also knows. Aliases. lib.attrsets.updateManyAttrsByPath.",
    "word_count": 269,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.updateManyAttrsByPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 172
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 245
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.updateManyAttrsByPath. Update or set specific paths of an attribute set. Takes a list of updates to apply and an attribute set to apply them to, and returns the attribute set with the updates applied. Updates are represented as { path = ...; update = ...; } values, where path is a list of strings representing the attribute path that should be updated, and update is a function that takes the old value at that attribute path as an argument and returns the new value it should be. Properties: Updates to deeper attribute paths are applied before updates to more shallow attribute paths. Multiple updates to the same attribute path are applied in the order they appear in the update list. If any but the last path element leads into a value that is not an attribute set, an error is thrown. If there is an update for an attribute path that doesn't exist, accessing the argument in the update function causes an error, but intermediate attribute sets are implicitly created as needed. Example. updateManyAttrsByPath [ { path = [ \"a\" \"b\" ]; update = old: { d = old.c; }; } { path = [ \"a\" \"b\" \"c\" ]; update = old: old + 1; } { path = [ \"x\" \"y\" ]; update = old: \"xy\"; } ] { a.b.c = 0; } =&gt; { a = { b = { d = 1; }; }; x = { y = \"xy\"; }; } Type. updateManyAttrsByPath :: [{ path :: [String]; update :: (Any -&gt; Any); }] -&gt; AttrSet -&gt; AttrSet Edit source. Noogle also knows. Aliases. lib.attrsets.updateManyAttrsByPath.",
    "raw_url": "/f/lib/updateManyAttrsByPath.html",
    "excerpt": "lib.updateManyAttrsByPath. Update or set specific paths of an attribute set. Takes a list of updates to apply and an attribute set to apply them to, and returns the attribute set",
    "sub_results": []
  },
  {
    "url": "/f/lib/lessThan.html",
    "content": "lib.lessThan Primop. Takes 2 arguments. e1, e2. Return true if the number e1 is less than the number e2, and false otherwise. Evaluation aborts if either e1 or e2 does not evaluate to a number. Noogle also knows. Aliases. builtins.lessThan. lib.trivial.lessThan.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lessThan Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lessThan Primop. Takes 2 arguments. e1, e2. Return true if the number e1 is less than the number e2, and false otherwise. Evaluation aborts if either e1 or e2 does not evaluate to a number. Noogle also knows. Aliases. builtins.lessThan. lib.trivial.lessThan.",
    "raw_url": "/f/lib/lessThan.html",
    "excerpt": "lib.lessThan Primop. Takes 2 arguments. e1, e2. Return true if the number e1 is less than the number e2, and false otherwise. Evaluation aborts if either e1 or e2 does",
    "sub_results": []
  },
  {
    "url": "/f/lib/makeScopeWithSplicing'.html",
    "content": "lib.makeScopeWithSplicing' (Prime). Like makeScope, but aims to support cross compilation. It's still ugly, but hopefully it helps a little bit. Type. makeScopeWithSplicing' :: { splicePackages :: Splice -> AttrSet , newScope :: AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a } -> { otherSplices :: Splice, keep :: AttrSet -> AttrSet, extra :: AttrSet -> AttrSet } -> AttrSet Splice :: { pkgsBuildBuild :: AttrSet , pkgsBuildHost :: AttrSet , pkgsBuildTarget :: AttrSet , pkgsHostHost :: AttrSet , pkgsHostTarget :: AttrSet , pkgsTargetTarget :: AttrSet } Arguments. Edit source. Noogle also knows. Aliases. lib.customisation.makeScopeWithSplicing' pkgs.makeScopeWithSplicing'",
    "word_count": 98,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.makeScopeWithSplicing' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 89
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.makeScopeWithSplicing' (Prime). Like makeScope, but aims to support cross compilation. It's still ugly, but hopefully it helps a little bit. Type. makeScopeWithSplicing' :: { splicePackages :: Splice -&gt; AttrSet , newScope :: AttrSet -&gt; ((AttrSet -&gt; a) | Path) -&gt; AttrSet -&gt; a } -&gt; { otherSplices :: Splice, keep :: AttrSet -&gt; AttrSet, extra :: AttrSet -&gt; AttrSet } -&gt; AttrSet Splice :: { pkgsBuildBuild :: AttrSet , pkgsBuildHost :: AttrSet , pkgsBuildTarget :: AttrSet , pkgsHostHost :: AttrSet , pkgsHostTarget :: AttrSet , pkgsTargetTarget :: AttrSet } Arguments. Edit source. Noogle also knows. Aliases. lib.customisation.makeScopeWithSplicing' pkgs.makeScopeWithSplicing'",
    "raw_url": "/f/lib/makeScopeWithSplicing'.html",
    "excerpt": "lib.makeScopeWithSplicing' (Prime). Like makeScope, but aims to support cross compilation. It's still ugly, but hopefully it helps a little bit. Type. makeScopeWithSplicing' :: { splicePackages :: Splice -&gt; AttrSet ,",
    "sub_results": []
  },
  {
    "url": "/f/lib/recursiveUpdate.html",
    "content": "lib.recursiveUpdate. A recursive variant of the update operator ‘//’. The recursion stops when one of the attribute values is not an attribute set, in which case the right hand side value takes precedence over the left hand side value. Example. recursiveUpdate { boot.loader.grub.enable = true; boot.loader.grub.device = \"/dev/hda\"; } { boot.loader.grub.device = \"\"; } returns: { boot.loader.grub.enable = true; boot.loader.grub.device = \"\"; } Type. recursiveUpdate :: AttrSet -> AttrSet -> AttrSet Arguments. [lhs] Left attribute set of the merge. [rhs] Right attribute set of the merge. Edit source. Noogle also knows. Aliases. lib.attrsets.recursiveUpdate.",
    "word_count": 93,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.recursiveUpdate"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 39
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 63
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 71
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.recursiveUpdate. A recursive variant of the update operator ‘//’. The recursion stops when one of the attribute values is not an attribute set, in which case the right hand side value takes precedence over the left hand side value. Example. recursiveUpdate { boot.loader.grub.enable = true; boot.loader.grub.device = \"/dev/hda\"; } { boot.loader.grub.device = \"\"; } returns: { boot.loader.grub.enable = true; boot.loader.grub.device = \"\"; } Type. recursiveUpdate :: AttrSet -&gt; AttrSet -&gt; AttrSet Arguments. [lhs] Left attribute set of the merge. [rhs] Right attribute set of the merge. Edit source. Noogle also knows. Aliases. lib.attrsets.recursiveUpdate.",
    "raw_url": "/f/lib/recursiveUpdate.html",
    "excerpt": "lib.recursiveUpdate. A recursive variant of the update operator ‘//’. The recursion stops when one of the attribute values is not an attribute set, in which case the right hand side",
    "sub_results": []
  },
  {
    "url": "/f/lib/compareLists.html",
    "content": "lib.compareLists. Compare two lists element-by-element. Example. compareLists compare [] [] => 0 compareLists compare [] [ \"a\" ] => -1 compareLists compare [ \"a\" ] [] => 1 compareLists compare [ \"a\" \"b\" ] [ \"a\" \"c\" ] => -1 Arguments. [cmp] [a] [b] Edit source. Noogle also knows. Aliases. lib.lists.compareLists.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.compareLists"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 5
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.compareLists. Compare two lists element-by-element. Example. compareLists compare [] [] =&gt; 0 compareLists compare [] [ \"a\" ] =&gt; -1 compareLists compare [ \"a\" ] [] =&gt; 1 compareLists compare [ \"a\" \"b\" ] [ \"a\" \"c\" ] =&gt; -1 Arguments. [cmp] [a] [b] Edit source. Noogle also knows. Aliases. lib.lists.compareLists.",
    "raw_url": "/f/lib/compareLists.html",
    "excerpt": "lib.compareLists. Compare two lists element-by-element. Example. compareLists compare [] [] =&gt; 0 compareLists compare [] [ \"a\" ] =&gt; -1 compareLists compare [ \"a\" ] [] =&gt; 1 compareLists compare",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrVals.html",
    "content": "lib.attrVals. Return the specified attributes from a set. Example. attrVals [\"a\" \"b\" \"c\"] as => [as.a as.b as.c] Type. attrVals :: [String] -> AttrSet -> [Any] Arguments. [nameList] The list of attributes to fetch from set. Each attribute name must exist on the attrbitue set. [set] The set to get attribute values from. Edit source. Noogle also knows. Aliases. lib.attrsets.attrVals.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrVals"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 8
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 18
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrVals. Return the specified attributes from a set. Example. attrVals [\"a\" \"b\" \"c\"] as =&gt; [as.a as.b as.c] Type. attrVals :: [String] -&gt; AttrSet -&gt; [Any] Arguments. [nameList] The list of attributes to fetch from set. Each attribute name must exist on the attrbitue set. [set] The set to get attribute values from. Edit source. Noogle also knows. Aliases. lib.attrsets.attrVals.",
    "raw_url": "/f/lib/attrVals.html",
    "excerpt": "lib.attrVals. Return the specified attributes from a set. Example. attrVals [\"a\" \"b\" \"c\"] as =&gt; [as.a as.b as.c] Type. attrVals :: [String] -&gt; AttrSet -&gt; [Any] Arguments. [nameList] The list",
    "sub_results": []
  },
  {
    "url": "/f/lib/splitString.html",
    "content": "lib.splitString. Cut a string with a separator and produces a list of strings which were separated by this separator. Example. splitString \".\" \"foo.bar.baz\" => [ \"foo\" \"bar\" \"baz\" ] splitString \"/\" \"/usr/local/bin\" => [ \"\" \"usr\" \"local\" \"bin\" ] Arguments. [sep] [s] Edit source. Noogle also knows. Aliases. lib.strings.splitString.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.splitString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.splitString. Cut a string with a separator and produces a list of strings which were separated by this separator. Example. splitString \".\" \"foo.bar.baz\" =&gt; [ \"foo\" \"bar\" \"baz\" ] splitString \"/\" \"/usr/local/bin\" =&gt; [ \"\" \"usr\" \"local\" \"bin\" ] Arguments. [sep] [s] Edit source. Noogle also knows. Aliases. lib.strings.splitString.",
    "raw_url": "/f/lib/splitString.html",
    "excerpt": "lib.splitString. Cut a string with a separator and produces a list of strings which were separated by this separator. Example. splitString \".\" \"foo.bar.baz\" =&gt; [ \"foo\" \"bar\" \"baz\" ] splitString",
    "sub_results": []
  },
  {
    "url": "/f/lib/traceValSeqFn.html",
    "content": "lib.traceValSeqFn. A combination of traceVal and traceSeq that applies a provided function to the value to be traced after deepSeqing it. Arguments. [f] Function to apply. [v] Value to trace. Edit source. Noogle also knows. Aliases. lib.debug.traceValSeqFn.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.traceValSeqFn"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 21
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.traceValSeqFn. A combination of traceVal and traceSeq that applies a provided function to the value to be traced after deepSeqing it. Arguments. [f] Function to apply. [v] Value to trace. Edit source. Noogle also knows. Aliases. lib.debug.traceValSeqFn.",
    "raw_url": "/f/lib/traceValSeqFn.html",
    "excerpt": "lib.traceValSeqFn. A combination of traceVal and traceSeq that applies a provided function to the value to be traced after deepSeqing it. Arguments. [f] Function to apply. [v] Value to trace.",
    "sub_results": []
  },
  {
    "url": "/f/lib/fold.html",
    "content": "lib.fold. fold is an alias of foldr for historic reasons. Edit source. Noogle also knows. Aliases. lib.lists.fold.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fold"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fold. fold is an alias of foldr for historic reasons. Edit source. Noogle also knows. Aliases. lib.lists.fold.",
    "raw_url": "/f/lib/fold.html",
    "excerpt": "lib.fold. fold is an alias of foldr for historic reasons. Edit source. Noogle also knows. Aliases. lib.lists.fold.",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrByPath.html",
    "content": "lib.attrByPath. Return an attribute from nested attribute sets. Example. x = { a = { b = 3; }; } # [\"a\" \"b\"] is equivalent to x.a.b # 6 is a default value to return if the path does not exist in attrset attrByPath [\"a\" \"b\"] 6 x => 3 attrByPath [\"z\" \"z\"] 6 x => 6 Type. attrByPath :: [String] -> Any -> AttrSet -> Any Arguments. [attrPath] A list of strings representing the attribute path to return from set. [default] Default value if attrPath does not resolve to an existing value. [set] The nested attribute set to select values from. Edit source. Noogle also knows. Aliases. lib.attrsets.attrByPath.",
    "word_count": 109,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrByPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 8
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 57
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 67
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrByPath. Return an attribute from nested attribute sets. Example. x = { a = { b = 3; }; } # [\"a\" \"b\"] is equivalent to x.a.b # 6 is a default value to return if the path does not exist in attrset attrByPath [\"a\" \"b\"] 6 x =&gt; 3 attrByPath [\"z\" \"z\"] 6 x =&gt; 6 Type. attrByPath :: [String] -&gt; Any -&gt; AttrSet -&gt; Any Arguments. [attrPath] A list of strings representing the attribute path to return from set. [default] Default value if attrPath does not resolve to an existing value. [set] The nested attribute set to select values from. Edit source. Noogle also knows. Aliases. lib.attrsets.attrByPath.",
    "raw_url": "/f/lib/attrByPath.html",
    "excerpt": "lib.attrByPath. Return an attribute from nested attribute sets. Example. x = { a = { b = 3; }; } # [\"a\" \"b\"] is equivalent to x.a.b # 6 is",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeEqualOption.html",
    "content": "lib.mergeEqualOption. \"Merge\" option definitions by checking that they all have the same value. Arguments. [loc] [defs] Edit source. Noogle also knows. Aliases. lib.options.mergeEqualOption.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeEqualOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 13
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeEqualOption. \"Merge\" option definitions by checking that they all have the same value. Arguments. [loc] [defs] Edit source. Noogle also knows. Aliases. lib.options.mergeEqualOption.",
    "raw_url": "/f/lib/mergeEqualOption.html",
    "excerpt": "lib.mergeEqualOption. \"Merge\" option definitions by checking that they all have the same value. Arguments. [loc] [defs] Edit source. Noogle also knows. Aliases. lib.options.mergeEqualOption.",
    "sub_results": []
  },
  {
    "url": "/f/lib/fix.html",
    "content": "lib.fix. fix f computes the fixed point of the given function f. In other words, the return value is x in x = f x. f must be a lazy function. This means that x must be a value that can be partially evaluated, such as an attribute set, a list, or a function. This way, f can use one part of x to compute another part. Relation to syntactic recursion This section explains fix by refactoring from syntactic recursion to a call of fix instead. For context, Nix lets you define attributes in terms of other attributes syntactically using the rec { } syntax. nix-repl> rec { foo = \"foo\"; bar = \"bar\"; foobar = foo + bar; } { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } This is convenient when constructing a value to pass to a function for example, but an equivalent effect can be achieved with the let binding syntax: nix-repl> let self = { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }; in self { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } But in general you can get more reuse out of let bindings by refactoring them to a function. nix-repl> f = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } This is where fix comes in, it contains the syntactic recursion that's not in f anymore. nix-repl> fix = f: let self = f self; in self; By applying fix we get the final result. nix-repl> fix f { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } Such a refactored f using fix is not useful by itself. See extends for an example use case. There self is also often called final. Example. fix (self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }) => { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } fix (self: [ 1 2 (elemAt self 0 + elemAt self 1) ]) => [ 1 2 3 ] Type. fix :: (a -> a) -> a Arguments. [f] Edit source. Noogle also knows. Aliases. lib.fixedPoints.fix.",
    "word_count": 360,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 296
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 343
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 351
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fix. fix f computes the fixed point of the given function f. In other words, the return value is x in x = f x. f must be a lazy function. This means that x must be a value that can be partially evaluated, such as an attribute set, a list, or a function. This way, f can use one part of x to compute another part. Relation to syntactic recursion This section explains fix by refactoring from syntactic recursion to a call of fix instead. For context, Nix lets you define attributes in terms of other attributes syntactically using the rec { } syntax. nix-repl&gt; rec { foo = \"foo\"; bar = \"bar\"; foobar = foo + bar; } { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } This is convenient when constructing a value to pass to a function for example, but an equivalent effect can be achieved with the let binding syntax: nix-repl&gt; let self = { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }; in self { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } But in general you can get more reuse out of let bindings by refactoring them to a function. nix-repl&gt; f = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } This is where fix comes in, it contains the syntactic recursion that's not in f anymore. nix-repl&gt; fix = f: let self = f self; in self; By applying fix we get the final result. nix-repl&gt; fix f { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } Such a refactored f using fix is not useful by itself. See extends for an example use case. There self is also often called final. Example. fix (self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }) =&gt; { bar = \"bar\"; foo = \"foo\"; foobar = \"foobar\"; } fix (self: [ 1 2 (elemAt self 0 + elemAt self 1) ]) =&gt; [ 1 2 3 ] Type. fix :: (a -&gt; a) -&gt; a Arguments. [f] Edit source. Noogle also knows. Aliases. lib.fixedPoints.fix.",
    "raw_url": "/f/lib/fix.html",
    "excerpt": "lib.fix. fix f computes the fixed point of the given function f. In other words, the return value is x in x = f x. f must be a lazy",
    "sub_results": []
  },
  {
    "url": "/f/lib/setName.html",
    "content": "lib.setName. Change the symbolic name of a package for presentation purposes (i.e., so that nix-env users can tell them apart). Arguments. [name] [drv] Edit source. Noogle also knows. Aliases. lib.meta.setName.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.setName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.setName. Change the symbolic name of a package for presentation purposes (i.e., so that nix-env users can tell them apart). Arguments. [name] [drv] Edit source. Noogle also knows. Aliases. lib.meta.setName.",
    "raw_url": "/f/lib/setName.html",
    "excerpt": "lib.setName. Change the symbolic name of a package for presentation purposes (i.e., so that nix-env users can tell them apart). Arguments. [name] [drv] Edit source. Noogle also knows. Aliases. lib.meta.setName.",
    "sub_results": []
  },
  {
    "url": "/f/lib/bitXor.html",
    "content": "lib.bitXor Primop. Takes 2 arguments. e1, e2. bitwise “xor” Edit source. Noogle also knows. Aliases. builtins.bitXor. lib.trivial.bitXor.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.bitXor Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.bitXor Primop. Takes 2 arguments. e1, e2. bitwise “xor” Edit source. Noogle also knows. Aliases. builtins.bitXor. lib.trivial.bitXor.",
    "raw_url": "/f/lib/bitXor.html",
    "excerpt": "lib.bitXor Primop. Takes 2 arguments. e1, e2. bitwise “xor” Edit source. Noogle also knows. Aliases. builtins.bitXor. lib.trivial.bitXor.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrsByFuncDefaultsClean.html",
    "content": "lib.mergeAttrsByFuncDefaultsClean. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrsByFuncDefaultsClean.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrsByFuncDefaultsClean"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrsByFuncDefaultsClean. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrsByFuncDefaultsClean.",
    "raw_url": "/f/lib/mergeAttrsByFuncDefaultsClean.html",
    "excerpt": "lib.mergeAttrsByFuncDefaultsClean. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrsByFuncDefaultsClean.",
    "sub_results": []
  },
  {
    "url": "/f/lib/pathIsRegularFile.html",
    "content": "lib.pathIsRegularFile. Whether a path exists and is a regular file, meaning not a symlink or any other special file type. Example. pathIsRegularFile /. => false pathIsRegularFile /this/does/not/exist => false pathIsRegularFile /some/file.nix => true Type. pathIsRegularFile :: Path -> Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.filesystem.pathIsRegularFile. lib.sources.pathIsRegularFile.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.pathIsRegularFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 33
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.pathIsRegularFile. Whether a path exists and is a regular file, meaning not a symlink or any other special file type. Example. pathIsRegularFile /. =&gt; false pathIsRegularFile /this/does/not/exist =&gt; false pathIsRegularFile /some/file.nix =&gt; true Type. pathIsRegularFile :: Path -&gt; Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.filesystem.pathIsRegularFile. lib.sources.pathIsRegularFile.",
    "raw_url": "/f/lib/pathIsRegularFile.html",
    "excerpt": "lib.pathIsRegularFile. Whether a path exists and is a regular file, meaning not a symlink or any other special file type. Example. pathIsRegularFile /. =&gt; false pathIsRegularFile /this/does/not/exist =&gt; false pathIsRegularFile",
    "sub_results": []
  },
  {
    "url": "/f/lib/escapeShellArg.html",
    "content": "lib.escapeShellArg. Quote string to be used safely within the Bourne shell. Example. escapeShellArg \"esc'ape\\nme\" => \"'esc'\\\\''ape\\nme'\" Type. escapeShellArg :: string -> string Arguments. [arg] Edit source. Noogle also knows. Aliases. lib.strings.escapeShellArg.",
    "word_count": 31,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.escapeShellArg"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 16
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 22
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.escapeShellArg. Quote string to be used safely within the Bourne shell. Example. escapeShellArg \"esc'ape\\nme\" =&gt; \"'esc'\\\\''ape\\nme'\" Type. escapeShellArg :: string -&gt; string Arguments. [arg] Edit source. Noogle also knows. Aliases. lib.strings.escapeShellArg.",
    "raw_url": "/f/lib/escapeShellArg.html",
    "excerpt": "lib.escapeShellArg. Quote string to be used safely within the Bourne shell. Example. escapeShellArg \"esc'ape\\nme\" =&gt; \"'esc'\\\\''ape\\nme'\" Type. escapeShellArg :: string -&gt; string Arguments. [arg] Edit source. Noogle also knows. Aliases.",
    "sub_results": []
  },
  {
    "url": "/f/lib/assertOneOf.html",
    "content": "lib.assertOneOf. Specialized assertMsg for checking if val is one of the elements of the list xs. Useful for checking enums. Example. let sslLibrary = \"libressl\"; in assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"bearssl\" ] stderr> error: sslLibrary must be one of [ stderr> \"openssl\" stderr> \"bearssl\" stderr> ], but is: \"libressl\" Type. assertOneOf :: String -> ComparableVal -> List ComparableVal -> Bool Arguments. [name] The name of the variable the user entered val into, for inclusion in the error message. [val] The value of what the user provided, to be compared against the values in xs. [xs] The list of valid values. Edit source. Noogle also knows. Aliases. lib.asserts.assertOneOf.",
    "word_count": 108,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.assertOneOf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 50
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 61
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.assertOneOf. Specialized assertMsg for checking if val is one of the elements of the list xs. Useful for checking enums. Example. let sslLibrary = \"libressl\"; in assertOneOf \"sslLibrary\" sslLibrary [ \"openssl\" \"bearssl\" ] stderr&gt; error: sslLibrary must be one of [ stderr&gt; \"openssl\" stderr&gt; \"bearssl\" stderr&gt; ], but is: \"libressl\" Type. assertOneOf :: String -&gt; ComparableVal -&gt; List ComparableVal -&gt; Bool Arguments. [name] The name of the variable the user entered val into, for inclusion in the error message. [val] The value of what the user provided, to be compared against the values in xs. [xs] The list of valid values. Edit source. Noogle also knows. Aliases. lib.asserts.assertOneOf.",
    "raw_url": "/f/lib/assertOneOf.html",
    "excerpt": "lib.assertOneOf. Specialized assertMsg for checking if val is one of the elements of the list xs. Useful for checking enums. Example. let sslLibrary = \"libressl\"; in assertOneOf \"sslLibrary\" sslLibrary [",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkMerge.html",
    "content": "lib.mkMerge. Edit source. Noogle also knows. Aliases. lib.modules.mkMerge.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkMerge"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkMerge. Edit source. Noogle also knows. Aliases. lib.modules.mkMerge.",
    "raw_url": "/f/lib/mkMerge.html",
    "excerpt": "lib.mkMerge. Edit source. Noogle also knows. Aliases. lib.modules.mkMerge.",
    "sub_results": []
  },
  {
    "url": "/f/lib/optionAttrSetToDocList'.html",
    "content": "lib.optionAttrSetToDocList' (Prime). Edit source. Noogle also knows. Aliases. lib.options.optionAttrSetToDocList'",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.optionAttrSetToDocList' (Prime)"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.optionAttrSetToDocList' (Prime). Edit source. Noogle also knows. Aliases. lib.options.optionAttrSetToDocList'",
    "raw_url": "/f/lib/optionAttrSetToDocList'.html",
    "excerpt": "lib.optionAttrSetToDocList' (Prime). Edit source. Noogle also knows. Aliases. lib.options.optionAttrSetToDocList'",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrByFunc.html",
    "content": "lib.mergeAttrByFunc. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrByFunc.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrByFunc"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrByFunc. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrByFunc.",
    "raw_url": "/f/lib/mergeAttrByFunc.html",
    "excerpt": "lib.mergeAttrByFunc. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrByFunc.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrsByFuncDefaults.html",
    "content": "lib.mergeAttrsByFuncDefaults. Noogle also knows. Aliases. lib.misc.mergeAttrsByFuncDefaults.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrsByFuncDefaults"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrsByFuncDefaults. Noogle also knows. Aliases. lib.misc.mergeAttrsByFuncDefaults.",
    "raw_url": "/f/lib/mergeAttrsByFuncDefaults.html",
    "excerpt": "lib.mergeAttrsByFuncDefaults. Noogle also knows. Aliases. lib.misc.mergeAttrsByFuncDefaults.",
    "sub_results": []
  },
  {
    "url": "/f/lib/compare.html",
    "content": "lib.compare. C-style comparisons a < b, compare a b => -1 a == b, compare a b => 0 a > b, compare a b => 1. Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.trivial.compare.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.compare"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.compare. C-style comparisons a &lt; b, compare a b =&gt; -1 a == b, compare a b =&gt; 0 a &gt; b, compare a b =&gt; 1. Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.trivial.compare.",
    "raw_url": "/f/lib/compare.html",
    "excerpt": "lib.compare. C-style comparisons a &lt; b, compare a b =&gt; -1 a == b, compare a b =&gt; 0 a &gt; b, compare a b =&gt; 1. Arguments. [a] [b]",
    "sub_results": []
  },
  {
    "url": "/f/lib/extends.html",
    "content": "lib.extends. Modify the contents of an explicitly recursive attribute set in a way that honors self-references. This is accomplished with a function. g = self: super: { foo = super.foo + \" + \"; } that has access to the unmodified input (super) as well as the final non-recursive representation of the attribute set (self). extends differs from the native // operator insofar as that it's applied before references to self are resolved: nix-repl> fix (extends g f) { bar = \"bar\"; foo = \"foo + \"; foobar = \"foo + bar\"; } The name of the function is inspired by object-oriented inheritance, i.e. think of it as an infix operator g extends f that mimics the syntax from Java. It may seem counter-intuitive to have the \"base class\" as the second argument, but it's nice this way if several uses of extends are cascaded. To get a better understanding how extends turns a function with a fix point (the package set we start with) into a new function with a different fix point (the desired packages set) lets just see, how extends g f unfolds with g and f defined above: extends g f = self: let super = f self; in super // g self super; = self: let super = { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }; in super // g self super = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } // g self { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } // { foo = \"foo\" + \" + \"; } = self: { foo = \"foo + \"; bar = \"bar\"; foobar = self.foo + self.bar; } Arguments. [f] [rattrs] [self] Edit source. Noogle also knows. Aliases. lib.fixedPoints.extends.",
    "word_count": 316,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.extends"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 305
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.extends. Modify the contents of an explicitly recursive attribute set in a way that honors self-references. This is accomplished with a function. g = self: super: { foo = super.foo + \" + \"; } that has access to the unmodified input (super) as well as the final non-recursive representation of the attribute set (self). extends differs from the native // operator insofar as that it's applied before references to self are resolved: nix-repl&gt; fix (extends g f) { bar = \"bar\"; foo = \"foo + \"; foobar = \"foo + bar\"; } The name of the function is inspired by object-oriented inheritance, i.e. think of it as an infix operator g extends f that mimics the syntax from Java. It may seem counter-intuitive to have the \"base class\" as the second argument, but it's nice this way if several uses of extends are cascaded. To get a better understanding how extends turns a function with a fix point (the package set we start with) into a new function with a different fix point (the desired packages set) lets just see, how extends g f unfolds with g and f defined above: extends g f = self: let super = f self; in super // g self super; = self: let super = { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; }; in super // g self super = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } // g self { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } = self: { foo = \"foo\"; bar = \"bar\"; foobar = self.foo + self.bar; } // { foo = \"foo\" + \" + \"; } = self: { foo = \"foo + \"; bar = \"bar\"; foobar = self.foo + self.bar; } Arguments. [f] [rattrs] [self] Edit source. Noogle also knows. Aliases. lib.fixedPoints.extends.",
    "raw_url": "/f/lib/extends.html",
    "excerpt": "lib.extends. Modify the contents of an explicitly recursive attribute set in a way that honors self-references. This is accomplished with a function. g = self: super: { foo = super.foo",
    "sub_results": []
  },
  {
    "url": "/f/lib/groupBy.html",
    "content": "lib.groupBy Primop. Takes 2 arguments. f, list. Groups elements of list together by the string returned from the function f called on each element. It returns an attribute set where each attribute value contains the elements of list that are mapped to the same corresponding attribute name returned by f. For example, builtins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"] evaluates to. { b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; } Noogle also knows. Aliases. builtins.groupBy. lib.lists.groupBy.",
    "word_count": 80,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.groupBy Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.groupBy Primop. Takes 2 arguments. f, list. Groups elements of list together by the string returned from the function f called on each element. It returns an attribute set where each attribute value contains the elements of list that are mapped to the same corresponding attribute name returned by f. For example, builtins.groupBy (builtins.substring 0 1) [\"foo\" \"bar\" \"baz\"] evaluates to. { b = [ \"bar\" \"baz\" ]; f = [ \"foo\" ]; } Noogle also knows. Aliases. builtins.groupBy. lib.lists.groupBy.",
    "raw_url": "/f/lib/groupBy.html",
    "excerpt": "lib.groupBy Primop. Takes 2 arguments. f, list. Groups elements of list together by the string returned from the function f called on each element. It returns an attribute set where",
    "sub_results": []
  },
  {
    "url": "/f/lib/importTOML.html",
    "content": "lib.importTOML. Reads a TOML file. Type. importTOML :: path -> any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.modules.importTOML. lib.trivial.importTOML.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.importTOML"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 5
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.importTOML. Reads a TOML file. Type. importTOML :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.modules.importTOML. lib.trivial.importTOML.",
    "raw_url": "/f/lib/importTOML.html",
    "excerpt": "lib.importTOML. Reads a TOML file. Type. importTOML :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.modules.importTOML. lib.trivial.importTOML.",
    "sub_results": []
  },
  {
    "url": "/f/lib/warnIf.html",
    "content": "lib.warnIf. Like warn, but only warn when the first argument is true. Type. bool -> string -> a -> a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.warnIf.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.warnIf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.warnIf. Like warn, but only warn when the first argument is true. Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.warnIf.",
    "raw_url": "/f/lib/warnIf.html",
    "excerpt": "lib.warnIf. Like warn, but only warn when the first argument is true. Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.trivial.warnIf.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkImageMediaOverride.html",
    "content": "lib.mkImageMediaOverride. Noogle also knows. Aliases. lib.modules.mkImageMediaOverride.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkImageMediaOverride"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkImageMediaOverride. Noogle also knows. Aliases. lib.modules.mkImageMediaOverride.",
    "raw_url": "/f/lib/mkImageMediaOverride.html",
    "excerpt": "lib.mkImageMediaOverride. Noogle also knows. Aliases. lib.modules.mkImageMediaOverride.",
    "sub_results": []
  },
  {
    "url": "/f/lib/lowPrio.html",
    "content": "lib.lowPrio. Decrease the nix-env priority of the package, i.e., other versions/variants of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.meta.lowPrio. pkgs.lowPrio.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.lowPrio"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.lowPrio. Decrease the nix-env priority of the package, i.e., other versions/variants of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.meta.lowPrio. pkgs.lowPrio.",
    "raw_url": "/f/lib/lowPrio.html",
    "excerpt": "lib.lowPrio. Decrease the nix-env priority of the package, i.e., other versions/variants of the package will be preferred. Edit source. Noogle also knows. Aliases. lib.meta.lowPrio. pkgs.lowPrio.",
    "sub_results": []
  },
  {
    "url": "/f/lib/toIntBase10.html",
    "content": "lib.toIntBase10. Parse a string as a base 10 int. This supports parsing of zero-padded integers. Example. toIntBase10 \"1337\" => 1337 toIntBase10 \"-4\" => -4 toIntBase10 \" 123 \" => 123 toIntBase10 \"00024\" => 24 toIntBase10 \"3.14\" => error: floating point JSON numbers are not supported Type. string -> int Arguments. [str] Edit source. Noogle also knows. Aliases. lib.strings.toIntBase10.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toIntBase10"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 45
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 49
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toIntBase10. Parse a string as a base 10 int. This supports parsing of zero-padded integers. Example. toIntBase10 \"1337\" =&gt; 1337 toIntBase10 \"-4\" =&gt; -4 toIntBase10 \" 123 \" =&gt; 123 toIntBase10 \"00024\" =&gt; 24 toIntBase10 \"3.14\" =&gt; error: floating point JSON numbers are not supported Type. string -&gt; int Arguments. [str] Edit source. Noogle also knows. Aliases. lib.strings.toIntBase10.",
    "raw_url": "/f/lib/toIntBase10.html",
    "excerpt": "lib.toIntBase10. Parse a string as a base 10 int. This supports parsing of zero-padded integers. Example. toIntBase10 \"1337\" =&gt; 1337 toIntBase10 \"-4\" =&gt; -4 toIntBase10 \" 123 \" =&gt; 123",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeAttrsWithFunc.html",
    "content": "lib.mergeAttrsWithFunc. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrsWithFunc.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeAttrsWithFunc"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeAttrsWithFunc. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrsWithFunc.",
    "raw_url": "/f/lib/mergeAttrsWithFunc.html",
    "excerpt": "lib.mergeAttrsWithFunc. Edit source. Noogle also knows. Aliases. lib.misc.mergeAttrsWithFunc.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/pipe.html",
    "content": "lib.trivial.pipe. Pipes a value through a list of functions, left to right. Example. pipe 2 [ (x: x + 2) # 2 + 2 = 4 (x: x * 2) # 4 * 2 = 8 ] => 8 # ideal to do text transformations pipe [ \"a/b\" \"a/c\" ] [ # create the cp command (map (file: ''cp \"${src}/${file}\" $out\\n'')) # concatenate all commands into one string lib.concatStrings # make that string into a nix derivation (pkgs.runCommand \"copy-to-out\" {}) ] => <drv which copies all files to $out> The output type of each function has to be the input type of the next function, and the last function returns the final value. Type. pipe :: a -> [<functions>] -> <return type of last function> Arguments. [val] [functions] Edit source. Noogle also knows. Aliases. lib.pipe.",
    "word_count": 135,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.pipe"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 113
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 125
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.pipe. Pipes a value through a list of functions, left to right. Example. pipe 2 [ (x: x + 2) # 2 + 2 = 4 (x: x * 2) # 4 * 2 = 8 ] =&gt; 8 # ideal to do text transformations pipe [ \"a/b\" \"a/c\" ] [ # create the cp command (map (file: ''cp \"${src}/${file}\" $out\\n'')) # concatenate all commands into one string lib.concatStrings # make that string into a nix derivation (pkgs.runCommand \"copy-to-out\" {}) ] =&gt; &lt;drv which copies all files to $out&gt; The output type of each function has to be the input type of the next function, and the last function returns the final value. Type. pipe :: a -&gt; [&lt;functions&gt;] -&gt; &lt;return type of last function&gt; Arguments. [val] [functions] Edit source. Noogle also knows. Aliases. lib.pipe.",
    "raw_url": "/f/lib/trivial/pipe.html",
    "excerpt": "lib.trivial.pipe. Pipes a value through a list of functions, left to right. Example. pipe 2 [ (x: x + 2) # 2 + 2 = 4 (x: x * 2)",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/toBaseDigits.html",
    "content": "lib.trivial.toBaseDigits. toBaseDigits base i converts the positive integer i to a list of its digits in the given base. For example: toBaseDigits 10 123 => [ 1 2 3 ] toBaseDigits 2 6 => [ 1 1 0 ] toBaseDigits 16 250 => [ 15 10 ] Arguments. [base] [i] Edit source. Noogle also knows. Aliases. lib.toBaseDigits.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.toBaseDigits"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.toBaseDigits. toBaseDigits base i converts the positive integer i to a list of its digits in the given base. For example: toBaseDigits 10 123 =&gt; [ 1 2 3 ] toBaseDigits 2 6 =&gt; [ 1 1 0 ] toBaseDigits 16 250 =&gt; [ 15 10 ] Arguments. [base] [i] Edit source. Noogle also knows. Aliases. lib.toBaseDigits.",
    "raw_url": "/f/lib/trivial/toBaseDigits.html",
    "excerpt": "lib.trivial.toBaseDigits. toBaseDigits base i converts the positive integer i to a list of its digits in the given base. For example: toBaseDigits 10 123 =&gt; [ 1 2 3 ]",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/bitOr.html",
    "content": "lib.trivial.bitOr Primop. Takes 2 arguments. e1, e2. bitwise “or” Edit source. Noogle also knows. Aliases. builtins.bitOr. lib.bitOr.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.bitOr Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.bitOr Primop. Takes 2 arguments. e1, e2. bitwise “or” Edit source. Noogle also knows. Aliases. builtins.bitOr. lib.bitOr.",
    "raw_url": "/f/lib/trivial/bitOr.html",
    "excerpt": "lib.trivial.bitOr Primop. Takes 2 arguments. e1, e2. bitwise “or” Edit source. Noogle also knows. Aliases. builtins.bitOr. lib.bitOr.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/throwIf.html",
    "content": "lib.trivial.throwIf. Like throwIfNot, but negated (throw if the first argument is true). Type. bool -> string -> a -> a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.throwIf.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.throwIf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.throwIf. Like throwIfNot, but negated (throw if the first argument is true). Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.throwIf.",
    "raw_url": "/f/lib/trivial/throwIf.html",
    "excerpt": "lib.trivial.throwIf. Like throwIfNot, but negated (throw if the first argument is true). Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.throwIf.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/const.html",
    "content": "lib.trivial.const. The constant function Ignores the second argument. If called with only one argument, constructs a function that always returns a static value. Example. let f = const 5; in f 10 => 5 Type. const :: a -> b -> a Arguments. [x] Value to return. [y] Value to ignore. Edit source. Noogle also knows. Aliases. lib.const.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.const"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.const. The constant function Ignores the second argument. If called with only one argument, constructs a function that always returns a static value. Example. let f = const 5; in f 10 =&gt; 5 Type. const :: a -&gt; b -&gt; a Arguments. [x] Value to return. [y] Value to ignore. Edit source. Noogle also knows. Aliases. lib.const.",
    "raw_url": "/f/lib/trivial/const.html",
    "excerpt": "lib.trivial.const. The constant function Ignores the second argument. If called with only one argument, constructs a function that always returns a static value. Example. let f = const 5; in",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/and.html",
    "content": "lib.trivial.and. boolean “and” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.and.",
    "word_count": 13,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.and"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 3
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.and. boolean “and” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.and.",
    "raw_url": "/f/lib/trivial/and.html",
    "excerpt": "lib.trivial.and. boolean “and” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.and.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/checkListOfEnum.html",
    "content": "lib.trivial.checkListOfEnum. Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise. Example. let colorVariants = [\"bright\" \"dark\" \"black\"] in checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants; => error: color variants: bright, black unexpected; valid ones: standard, light, dark Type. String -> List ComparableVal -> List ComparableVal -> a -> a Arguments. [msg] [valid] [given] Edit source. Noogle also knows. Aliases. lib.checkListOfEnum.",
    "word_count": 76,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.checkListOfEnum"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 53
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 65
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.checkListOfEnum. Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise. Example. let colorVariants = [\"bright\" \"dark\" \"black\"] in checkListOfEnum \"color variants\" [ \"standard\" \"light\" \"dark\" ] colorVariants; =&gt; error: color variants: bright, black unexpected; valid ones: standard, light, dark Type. String -&gt; List ComparableVal -&gt; List ComparableVal -&gt; a -&gt; a Arguments. [msg] [valid] [given] Edit source. Noogle also knows. Aliases. lib.checkListOfEnum.",
    "raw_url": "/f/lib/trivial/checkListOfEnum.html",
    "excerpt": "lib.trivial.checkListOfEnum. Check if the elements in a list are valid values from a enum, returning the identity function, or throwing an error message otherwise. Example. let colorVariants = [\"bright\" \"dark\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/toFunction.html",
    "content": "lib.trivial.toFunction. Turns any non-callable values into constant functions. Returns callable values as is. Example. nix-repl> lib.toFunction 1 2 1 nix-repl> lib.toFunction (x: x + 1) 2 3 Arguments. [v] Any value. Edit source. Noogle also knows. Aliases. lib.toFunction.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.toFunction"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.toFunction. Turns any non-callable values into constant functions. Returns callable values as is. Example. nix-repl&gt; lib.toFunction 1 2 1 nix-repl&gt; lib.toFunction (x: x + 1) 2 3 Arguments. [v] Any value. Edit source. Noogle also knows. Aliases. lib.toFunction.",
    "raw_url": "/f/lib/trivial/toFunction.html",
    "excerpt": "lib.trivial.toFunction. Turns any non-callable values into constant functions. Returns callable values as is. Example. nix-repl&gt; lib.toFunction 1 2 1 nix-repl&gt; lib.toFunction (x: x + 1) 2 3 Arguments. [v] Any",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/throwIfNot.html",
    "content": "lib.trivial.throwIfNot. Like the assert b; e expression, but with a custom error message and without the semicolon. If true, return the identity function, r: r. If false, throw the error message. Calls can be juxtaposed using function application, as (r: r) a = a, so (r: r) (r: r) a = a, and so forth. Example. throwIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\" lib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays pkgs Type. bool -> string -> a -> a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.throwIfNot.",
    "word_count": 103,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.throwIfNot"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 55
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 85
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 93
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.throwIfNot. Like the assert b; e expression, but with a custom error message and without the semicolon. If true, return the identity function, r: r. If false, throw the error message. Calls can be juxtaposed using function application, as (r: r) a = a, so (r: r) (r: r) a = a, and so forth. Example. throwIfNot (lib.isList overlays) \"The overlays argument to nixpkgs must be a list.\" lib.foldr (x: throwIfNot (lib.isFunction x) \"All overlays passed to nixpkgs must be functions.\") (r: r) overlays pkgs Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.throwIfNot.",
    "raw_url": "/f/lib/trivial/throwIfNot.html",
    "excerpt": "lib.trivial.throwIfNot. Like the assert b; e expression, but with a custom error message and without the semicolon. If true, return the identity function, r: r. If false, throw the error",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/seq.html",
    "content": "lib.trivial.seq Primop. Takes 2 arguments. e1, e2. Evaluate e1, then evaluate and return e2. This ensures that a computation is strict in the value of e1. Noogle also knows. Aliases. builtins.seq. lib.seq.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.seq Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.seq Primop. Takes 2 arguments. e1, e2. Evaluate e1, then evaluate and return e2. This ensures that a computation is strict in the value of e1. Noogle also knows. Aliases. builtins.seq. lib.seq.",
    "raw_url": "/f/lib/trivial/seq.html",
    "excerpt": "lib.trivial.seq Primop. Takes 2 arguments. e1, e2. Evaluate e1, then evaluate and return e2. This ensures that a computation is strict in the value of e1. Noogle also knows. Aliases.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/pathExists.html",
    "content": "lib.trivial.pathExists Primop. Takes 1 arguments. path. Return true if the path path exists at evaluation time, and false otherwise. Noogle also knows. Aliases. builtins.pathExists. lib.pathExists.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.pathExists Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.pathExists Primop. Takes 1 arguments. path. Return true if the path path exists at evaluation time, and false otherwise. Noogle also knows. Aliases. builtins.pathExists. lib.pathExists.",
    "raw_url": "/f/lib/trivial/pathExists.html",
    "excerpt": "lib.trivial.pathExists Primop. Takes 1 arguments. path. Return true if the path path exists at evaluation time, and false otherwise. Noogle also knows. Aliases. builtins.pathExists. lib.pathExists.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/id.html",
    "content": "lib.trivial.id. The identity function For when you need a function that does “nothing”. Type. id :: a -> a Arguments. [x] The value to return. Edit source. Noogle also knows. Aliases. lib.id.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.id"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 19
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.id. The identity function For when you need a function that does “nothing”. Type. id :: a -&gt; a Arguments. [x] The value to return. Edit source. Noogle also knows. Aliases. lib.id.",
    "raw_url": "/f/lib/trivial/id.html",
    "excerpt": "lib.trivial.id. The identity function For when you need a function that does “nothing”. Type. id :: a -&gt; a Arguments. [x] The value to return. Edit source. Noogle also knows.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/toHexString.html",
    "content": "lib.trivial.toHexString. Convert the given positive integer to a string of its hexadecimal representation. For example: toHexString 0 => \"0\" toHexString 16 => \"10\" toHexString 250 => \"FA\" Arguments. [i] Edit source. Noogle also knows. Aliases. lib.toHexString.",
    "word_count": 36,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.toHexString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.toHexString. Convert the given positive integer to a string of its hexadecimal representation. For example: toHexString 0 =&gt; \"0\" toHexString 16 =&gt; \"10\" toHexString 250 =&gt; \"FA\" Arguments. [i] Edit source. Noogle also knows. Aliases. lib.toHexString.",
    "raw_url": "/f/lib/trivial/toHexString.html",
    "excerpt": "lib.trivial.toHexString. Convert the given positive integer to a string of its hexadecimal representation. For example: toHexString 0 =&gt; \"0\" toHexString 16 =&gt; \"10\" toHexString 250 =&gt; \"FA\" Arguments. [i] Edit",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/add.html",
    "content": "lib.trivial.add Primop. Takes 2 arguments. e1, e2. Return the sum of the numbers e1 and e2. Noogle also knows. Aliases. builtins.add. lib.add.",
    "word_count": 22,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.add Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.add Primop. Takes 2 arguments. e1, e2. Return the sum of the numbers e1 and e2. Noogle also knows. Aliases. builtins.add. lib.add.",
    "raw_url": "/f/lib/trivial/add.html",
    "excerpt": "lib.trivial.add Primop. Takes 2 arguments. e1, e2. Return the sum of the numbers e1 and e2. Noogle also knows. Aliases. builtins.add. lib.add.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/isFunction.html",
    "content": "lib.trivial.isFunction. Check whether something is a function or something annotated with function args. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.isFunction.",
    "word_count": 22,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.isFunction"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 13
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.isFunction. Check whether something is a function or something annotated with function args. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.isFunction.",
    "raw_url": "/f/lib/trivial/isFunction.html",
    "excerpt": "lib.trivial.isFunction. Check whether something is a function or something annotated with function args. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.isFunction.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/min.html",
    "content": "lib.trivial.min. Return minimum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.min.",
    "word_count": 16,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.min"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 6
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.min. Return minimum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.min.",
    "raw_url": "/f/lib/trivial/min.html",
    "excerpt": "lib.trivial.min. Return minimum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.min.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/info.html",
    "content": "lib.trivial.info. Edit source. Noogle also knows. Aliases. lib.info.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.info"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.info. Edit source. Noogle also knows. Aliases. lib.info.",
    "raw_url": "/f/lib/trivial/info.html",
    "excerpt": "lib.trivial.info. Edit source. Noogle also knows. Aliases. lib.info.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/readFile.html",
    "content": "lib.trivial.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. builtins.readFile. lib.readFile. lib.strings.readFile.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.readFile Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. builtins.readFile. lib.readFile. lib.strings.readFile.",
    "raw_url": "/f/lib/trivial/readFile.html",
    "excerpt": "lib.trivial.readFile Primop. Takes 1 arguments. path. Return the contents of the file path as a string. Noogle also knows. Aliases. builtins.readFile. lib.readFile. lib.strings.readFile.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/mapNullable.html",
    "content": "lib.trivial.mapNullable. Apply function if the supplied argument is non-null. Example. mapNullable (x: x+1) null => null mapNullable (x: x+1) 22 => 23 Arguments. [f] Function to call. [a] Argument to check for null before passing it to f. Edit source. Noogle also knows. Aliases. lib.mapNullable.",
    "word_count": 45,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.mapNullable"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 22
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.mapNullable. Apply function if the supplied argument is non-null. Example. mapNullable (x: x+1) null =&gt; null mapNullable (x: x+1) 22 =&gt; 23 Arguments. [f] Function to call. [a] Argument to check for null before passing it to f. Edit source. Noogle also knows. Aliases. lib.mapNullable.",
    "raw_url": "/f/lib/trivial/mapNullable.html",
    "excerpt": "lib.trivial.mapNullable. Apply function if the supplied argument is non-null. Example. mapNullable (x: x+1) null =&gt; null mapNullable (x: x+1) 22 =&gt; 23 Arguments. [f] Function to call. [a] Argument to",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/revisionWithDefault.html",
    "content": "lib.trivial.revisionWithDefault. Attempts to return the the current revision of nixpkgs and returns the supplied default value otherwise. Type. revisionWithDefault :: string -> string Arguments. [default] Default value to return if revision can not be determined. Edit source.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.revisionWithDefault"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 23
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.revisionWithDefault. Attempts to return the the current revision of nixpkgs and returns the supplied default value otherwise. Type. revisionWithDefault :: string -&gt; string Arguments. [default] Default value to return if revision can not be determined. Edit source.",
    "raw_url": "/f/lib/trivial/revisionWithDefault.html",
    "excerpt": "lib.trivial.revisionWithDefault. Attempts to return the the current revision of nixpkgs and returns the supplied default value otherwise. Type. revisionWithDefault :: string -&gt; string Arguments. [default] Default value to return if",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/functionArgs.html",
    "content": "lib.trivial.functionArgs. Extract the expected function arguments from a function. This works both with nix-native { a, b ? foo, ... }: style functions and functions with args set with 'setFunctionArgs'. It has the same return type and semantics as builtins.functionArgs. setFunctionArgs : (a → b) → Map String Bool. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.functionArgs.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.functionArgs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 49
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.functionArgs. Extract the expected function arguments from a function. This works both with nix-native { a, b ? foo, ... }: style functions and functions with args set with 'setFunctionArgs'. It has the same return type and semantics as builtins.functionArgs. setFunctionArgs : (a → b) → Map String Bool. Arguments. [f] Edit source. Noogle also knows. Aliases. lib.functionArgs.",
    "raw_url": "/f/lib/trivial/functionArgs.html",
    "excerpt": "lib.trivial.functionArgs. Extract the expected function arguments from a function. This works both with nix-native { a, b ? foo, ... }: style functions and functions with args set with 'setFunctionArgs'.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/importJSON.html",
    "content": "lib.trivial.importJSON. Reads a JSON file. Type. importJSON :: path -> any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importJSON. lib.modules.importJSON.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.importJSON"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 5
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.importJSON. Reads a JSON file. Type. importJSON :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importJSON. lib.modules.importJSON.",
    "raw_url": "/f/lib/trivial/importJSON.html",
    "excerpt": "lib.trivial.importJSON. Reads a JSON file. Type. importJSON :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importJSON. lib.modules.importJSON.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/warn.html",
    "content": "lib.trivial.warn. Print a warning before returning the second argument. This function behaves like builtins.trace, but requires a string message and formats it as a warning, including the warning: prefix. To get a call stack trace and abort evaluation, set the environment variable NIX_ABORT_ON_WARN=true and set the Nix options --option pure-eval false --show-trace. Type. string -> a -> a Edit source. Noogle also knows. Aliases. lib.warn.",
    "word_count": 65,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.warn"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 52
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.warn. Print a warning before returning the second argument. This function behaves like builtins.trace, but requires a string message and formats it as a warning, including the warning: prefix. To get a call stack trace and abort evaluation, set the environment variable NIX_ABORT_ON_WARN=true and set the Nix options --option pure-eval false --show-trace. Type. string -&gt; a -&gt; a Edit source. Noogle also knows. Aliases. lib.warn.",
    "raw_url": "/f/lib/trivial/warn.html",
    "excerpt": "lib.trivial.warn. Print a warning before returning the second argument. This function behaves like builtins.trace, but requires a string message and formats it as a warning, including the warning: prefix. To",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/genericClosure.html",
    "content": "lib.trivial.genericClosure Primop. Takes 1 arguments. attrset. Takes an attrset with the following attributes: startSet [ Item ] A list of start items. Each item must be an attrset containing a key. The key must be comparable. operator Item -> [ Item ] A function. returns a list of attrsets. GenericClosure starts with the startSet and recursively applying the operator function to each item. The attrsets in the startSet and the attrsets produced by operator must contain a value named key which is comparable. The result is produced by calling operator for each item with a value for key that has not been called yet including newly produced items. The function terminates when no new items are produced. The resulting list of attrsets contains only attrsets with a unique key. For example, builtins.genericClosure { startSet = [ {key = 5;} ]; operator = item: [{ key = if (item.key / 2 ) * 2 == item.key then item.key / 2 else 3 * item.key + 1; }]; } evaluates to. [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ] Noogle also knows. Aliases. builtins.genericClosure. lib.genericClosure.",
    "word_count": 207,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.genericClosure Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.genericClosure Primop. Takes 1 arguments. attrset. Takes an attrset with the following attributes: startSet [ Item ] A list of start items. Each item must be an attrset containing a key. The key must be comparable. operator Item -&gt; [ Item ] A function. returns a list of attrsets. GenericClosure starts with the startSet and recursively applying the operator function to each item. The attrsets in the startSet and the attrsets produced by operator must contain a value named key which is comparable. The result is produced by calling operator for each item with a value for key that has not been called yet including newly produced items. The function terminates when no new items are produced. The resulting list of attrsets contains only attrsets with a unique key. For example, builtins.genericClosure { startSet = [ {key = 5;} ]; operator = item: [{ key = if (item.key / 2 ) * 2 == item.key then item.key / 2 else 3 * item.key + 1; }]; } evaluates to. [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ] Noogle also knows. Aliases. builtins.genericClosure. lib.genericClosure.",
    "raw_url": "/f/lib/trivial/genericClosure.html",
    "excerpt": "lib.trivial.genericClosure Primop. Takes 1 arguments. attrset. Takes an attrset with the following attributes: startSet [ Item ] A list of start items. Each item must be an attrset containing a",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/bitNot.html",
    "content": "lib.trivial.bitNot. bitwise “not” Edit source. Noogle also knows. Aliases. lib.bitNot.",
    "word_count": 10,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.bitNot"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.bitNot. bitwise “not” Edit source. Noogle also knows. Aliases. lib.bitNot.",
    "raw_url": "/f/lib/trivial/bitNot.html",
    "excerpt": "lib.trivial.bitNot. bitwise “not” Edit source. Noogle also knows. Aliases. lib.bitNot.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/isBool.html",
    "content": "lib.trivial.isBool Primop. Takes 1 arguments. e. Return true if e evaluates to a bool, and false otherwise. Noogle also knows. Aliases. builtins.isBool. lib.isBool.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.isBool Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.isBool Primop. Takes 1 arguments. e. Return true if e evaluates to a bool, and false otherwise. Noogle also knows. Aliases. builtins.isBool. lib.isBool.",
    "raw_url": "/f/lib/trivial/isBool.html",
    "excerpt": "lib.trivial.isBool Primop. Takes 1 arguments. e. Return true if e evaluates to a bool, and false otherwise. Noogle also knows. Aliases. builtins.isBool. lib.isBool.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/flip.html",
    "content": "lib.trivial.flip. Flip the order of the arguments of a binary function. Example. flip concat [1] [2] => [ 2 1 ] Type. flip :: (a -> b -> c) -> (b -> a -> c) Arguments. [f] [a] [b] Edit source. Noogle also knows. Aliases. lib.flip.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.flip"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.flip. Flip the order of the arguments of a binary function. Example. flip concat [1] [2] =&gt; [ 2 1 ] Type. flip :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) Arguments. [f] [a] [b] Edit source. Noogle also knows. Aliases. lib.flip.",
    "raw_url": "/f/lib/trivial/flip.html",
    "excerpt": "lib.trivial.flip. Flip the order of the arguments of a binary function. Example. flip concat [1] [2] =&gt; [ 2 1 ] Type. flip :: (a -&gt; b -&gt; c) -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/or.html",
    "content": "lib.trivial.or. boolean “or” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.or.",
    "word_count": 13,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.or"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 3
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.or. boolean “or” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.or.",
    "raw_url": "/f/lib/trivial/or.html",
    "excerpt": "lib.trivial.or. boolean “or” Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.or.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/splitByAndCompare.html",
    "content": "lib.trivial.splitByAndCompare. Split type into two subtypes by predicate p, take all elements of the first subtype to be less than all the elements of the second subtype, compare elements of a single subtype with yes and no respectively. Example. let cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in cmp \"a\" \"z\" => -1 cmp \"fooa\" \"fooz\" => -1 cmp \"f\" \"a\" => 1 cmp \"fooa\" \"a\" => -1 # while compare \"fooa\" \"a\" => 1 Type. (a -> bool) -> (a -> a -> int) -> (a -> a -> int) -> (a -> a -> int) Arguments. [p] Predicate. [yes] Comparison function if predicate holds for both values. [no] Comparison function if predicate holds for neither value. [a] First value to compare. [b] Second value to compare. Edit source. Noogle also knows. Aliases. lib.splitByAndCompare.",
    "word_count": 135,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.splitByAndCompare"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 38
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 75
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 97
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.splitByAndCompare. Split type into two subtypes by predicate p, take all elements of the first subtype to be less than all the elements of the second subtype, compare elements of a single subtype with yes and no respectively. Example. let cmp = splitByAndCompare (hasPrefix \"foo\") compare compare; in cmp \"a\" \"z\" =&gt; -1 cmp \"fooa\" \"fooz\" =&gt; -1 cmp \"f\" \"a\" =&gt; 1 cmp \"fooa\" \"a\" =&gt; -1 # while compare \"fooa\" \"a\" =&gt; 1 Type. (a -&gt; bool) -&gt; (a -&gt; a -&gt; int) -&gt; (a -&gt; a -&gt; int) -&gt; (a -&gt; a -&gt; int) Arguments. [p] Predicate. [yes] Comparison function if predicate holds for both values. [no] Comparison function if predicate holds for neither value. [a] First value to compare. [b] Second value to compare. Edit source. Noogle also knows. Aliases. lib.splitByAndCompare.",
    "raw_url": "/f/lib/trivial/splitByAndCompare.html",
    "excerpt": "lib.trivial.splitByAndCompare. Split type into two subtypes by predicate p, take all elements of the first subtype to be less than all the elements of the second subtype, compare elements of",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/isFloat.html",
    "content": "lib.trivial.isFloat Primop. Takes 1 arguments. e. Return true if e evaluates to a float, and false otherwise. Noogle also knows. Aliases. builtins.isFloat. lib.isFloat.",
    "word_count": 23,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.isFloat Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.isFloat Primop. Takes 1 arguments. e. Return true if e evaluates to a float, and false otherwise. Noogle also knows. Aliases. builtins.isFloat. lib.isFloat.",
    "raw_url": "/f/lib/trivial/isFloat.html",
    "excerpt": "lib.trivial.isFloat Primop. Takes 1 arguments. e. Return true if e evaluates to a float, and false otherwise. Noogle also knows. Aliases. builtins.isFloat. lib.isFloat.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/bitAnd.html",
    "content": "lib.trivial.bitAnd Primop. Takes 2 arguments. e1, e2. bitwise “and” Edit source. Noogle also knows. Aliases. builtins.bitAnd. lib.bitAnd.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.bitAnd Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.bitAnd Primop. Takes 2 arguments. e1, e2. bitwise “and” Edit source. Noogle also knows. Aliases. builtins.bitAnd. lib.bitAnd.",
    "raw_url": "/f/lib/trivial/bitAnd.html",
    "excerpt": "lib.trivial.bitAnd Primop. Takes 2 arguments. e1, e2. bitwise “and” Edit source. Noogle also knows. Aliases. builtins.bitAnd. lib.bitAnd.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/warnIfNot.html",
    "content": "lib.trivial.warnIfNot. Like warnIf, but negated (warn if the first argument is false). Type. bool -> string -> a -> a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.warnIfNot.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.warnIfNot"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.warnIfNot. Like warnIf, but negated (warn if the first argument is false). Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.warnIfNot.",
    "raw_url": "/f/lib/trivial/warnIfNot.html",
    "excerpt": "lib.trivial.warnIfNot. Like warnIf, but negated (warn if the first argument is false). Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.warnIfNot.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/mergeAttrs.html",
    "content": "lib.trivial.mergeAttrs. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -> attrs -> attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } => { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.mergeAttrs.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.mergeAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.mergeAttrs. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b = 3; c = 4; } =&gt; { a = 1; b = 3; c = 4; } Arguments. [x] Left attribute set. [y] Right attribute set (higher precedence for equal keys). Edit source. Noogle also knows. Aliases. lib.mergeAttrs.",
    "raw_url": "/f/lib/trivial/mergeAttrs.html",
    "excerpt": "lib.trivial.mergeAttrs. Merge two attribute sets shallowly, right side trumps left mergeAttrs :: attrs -&gt; attrs -&gt; attrs. Example. mergeAttrs { a = 1; b = 2; } { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/lessThan.html",
    "content": "lib.trivial.lessThan Primop. Takes 2 arguments. e1, e2. Return true if the number e1 is less than the number e2, and false otherwise. Evaluation aborts if either e1 or e2 does not evaluate to a number. Noogle also knows. Aliases. builtins.lessThan. lib.lessThan.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.lessThan Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.lessThan Primop. Takes 2 arguments. e1, e2. Return true if the number e1 is less than the number e2, and false otherwise. Evaluation aborts if either e1 or e2 does not evaluate to a number. Noogle also knows. Aliases. builtins.lessThan. lib.lessThan.",
    "raw_url": "/f/lib/trivial/lessThan.html",
    "excerpt": "lib.trivial.lessThan Primop. Takes 2 arguments. e1, e2. Return true if the number e1 is less than the number e2, and false otherwise. Evaluation aborts if either e1 or e2 does",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/bitXor.html",
    "content": "lib.trivial.bitXor Primop. Takes 2 arguments. e1, e2. bitwise “xor” Edit source. Noogle also knows. Aliases. builtins.bitXor. lib.bitXor.",
    "word_count": 17,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.bitXor Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.bitXor Primop. Takes 2 arguments. e1, e2. bitwise “xor” Edit source. Noogle also knows. Aliases. builtins.bitXor. lib.bitXor.",
    "raw_url": "/f/lib/trivial/bitXor.html",
    "excerpt": "lib.trivial.bitXor Primop. Takes 2 arguments. e1, e2. bitwise “xor” Edit source. Noogle also knows. Aliases. builtins.bitXor. lib.bitXor.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/compare.html",
    "content": "lib.trivial.compare. C-style comparisons a < b, compare a b => -1 a == b, compare a b => 0 a > b, compare a b => 1. Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.compare.",
    "word_count": 37,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.compare"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 27
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.compare. C-style comparisons a &lt; b, compare a b =&gt; -1 a == b, compare a b =&gt; 0 a &gt; b, compare a b =&gt; 1. Arguments. [a] [b] Edit source. Noogle also knows. Aliases. lib.compare.",
    "raw_url": "/f/lib/trivial/compare.html",
    "excerpt": "lib.trivial.compare. C-style comparisons a &lt; b, compare a b =&gt; -1 a == b, compare a b =&gt; 0 a &gt; b, compare a b =&gt; 1. Arguments. [a] [b]",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/importTOML.html",
    "content": "lib.trivial.importTOML. Reads a TOML file. Type. importTOML :: path -> any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importTOML. lib.modules.importTOML.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.importTOML"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 5
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.importTOML. Reads a TOML file. Type. importTOML :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importTOML. lib.modules.importTOML.",
    "raw_url": "/f/lib/trivial/importTOML.html",
    "excerpt": "lib.trivial.importTOML. Reads a TOML file. Type. importTOML :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importTOML. lib.modules.importTOML.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/warnIf.html",
    "content": "lib.trivial.warnIf. Like warn, but only warn when the first argument is true. Type. bool -> string -> a -> a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.warnIf.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.warnIf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.warnIf. Like warn, but only warn when the first argument is true. Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.warnIf.",
    "raw_url": "/f/lib/trivial/warnIf.html",
    "excerpt": "lib.trivial.warnIf. Like warn, but only warn when the first argument is true. Type. bool -&gt; string -&gt; a -&gt; a Arguments. [cond] [msg] Edit source. Noogle also knows. Aliases. lib.warnIf.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/isInOldestRelease.html",
    "content": "lib.trivial.isInOldestRelease. Whether a feature is supported in all supported releases (at the time of release branch-off, if applicable). See oldestSupportedRelease. Arguments. [release] Release number of feature introduction as an integer, e.g. 2111 for 21.11. Set it to the upcoming release, matching the nixpkgs/.version file. Edit source. Noogle also knows. Aliases. lib.isInOldestRelease.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.isInOldestRelease"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.isInOldestRelease. Whether a feature is supported in all supported releases (at the time of release branch-off, if applicable). See oldestSupportedRelease. Arguments. [release] Release number of feature introduction as an integer, e.g. 2111 for 21.11. Set it to the upcoming release, matching the nixpkgs/.version file. Edit source. Noogle also knows. Aliases. lib.isInOldestRelease.",
    "raw_url": "/f/lib/trivial/isInOldestRelease.html",
    "excerpt": "lib.trivial.isInOldestRelease. Whether a feature is supported in all supported releases (at the time of release branch-off, if applicable). See oldestSupportedRelease. Arguments. [release] Release number of feature introduction as an integer,",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/showWarnings.html",
    "content": "lib.trivial.showWarnings. Edit source. Noogle also knows. Aliases. lib.showWarnings.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.showWarnings"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.showWarnings. Edit source. Noogle also knows. Aliases. lib.showWarnings.",
    "raw_url": "/f/lib/trivial/showWarnings.html",
    "excerpt": "lib.trivial.showWarnings. Edit source. Noogle also knows. Aliases. lib.showWarnings.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/mod.html",
    "content": "lib.trivial.mod. Integer modulus. Example. mod 11 10 => 1 mod 1 10 => 1 Arguments. [base] [int] Edit source. Noogle also knows. Aliases. lib.mod.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.mod"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 3
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.mod. Integer modulus. Example. mod 11 10 =&gt; 1 mod 1 10 =&gt; 1 Arguments. [base] [int] Edit source. Noogle also knows. Aliases. lib.mod.",
    "raw_url": "/f/lib/trivial/mod.html",
    "excerpt": "lib.trivial.mod. Integer modulus. Example. mod 11 10 =&gt; 1 mod 1 10 =&gt; 1 Arguments. [base] [int] Edit source. Noogle also knows. Aliases. lib.mod.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/max.html",
    "content": "lib.trivial.max. Return maximum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.max.",
    "word_count": 16,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.max"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 6
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.max. Return maximum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.max.",
    "raw_url": "/f/lib/trivial/max.html",
    "excerpt": "lib.trivial.max. Return maximum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.max.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/boolToString.html",
    "content": "lib.trivial.boolToString. Convert a boolean to a string. This function uses the strings \"true\" and \"false\" to represent boolean values. Calling toString on a bool instead returns \"1\" and \"\" (sic!). Type. boolToString :: bool -> string Arguments. [b] Edit source. Noogle also knows. Aliases. lib.boolToString.",
    "word_count": 45,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.boolToString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 30
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 36
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.boolToString. Convert a boolean to a string. This function uses the strings \"true\" and \"false\" to represent boolean values. Calling toString on a bool instead returns \"1\" and \"\" (sic!). Type. boolToString :: bool -&gt; string Arguments. [b] Edit source. Noogle also knows. Aliases. lib.boolToString.",
    "raw_url": "/f/lib/trivial/boolToString.html",
    "excerpt": "lib.trivial.boolToString. Convert a boolean to a string. This function uses the strings \"true\" and \"false\" to represent boolean values. Calling toString on a bool instead returns \"1\" and \"\" (sic!).",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/concat.html",
    "content": "lib.trivial.concat. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.concat.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.concat"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.concat. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.concat.",
    "raw_url": "/f/lib/trivial/concat.html",
    "excerpt": "lib.trivial.concat. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/sub.html",
    "content": "lib.trivial.sub Primop. Takes 2 arguments. e1, e2. Return the difference between the numbers e1 and e2. Noogle also knows. Aliases. builtins.sub. lib.sub.",
    "word_count": 22,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.sub Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.sub Primop. Takes 2 arguments. e1, e2. Return the difference between the numbers e1 and e2. Noogle also knows. Aliases. builtins.sub. lib.sub.",
    "raw_url": "/f/lib/trivial/sub.html",
    "excerpt": "lib.trivial.sub Primop. Takes 2 arguments. e1, e2. Return the difference between the numbers e1 and e2. Noogle also knows. Aliases. builtins.sub. lib.sub.",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/deepSeq.html",
    "content": "lib.trivial.deepSeq Primop. Takes 2 arguments. e1, e2. This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are also evaluated recursively. Noogle also knows. Aliases. builtins.deepSeq. lib.deepSeq.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.deepSeq Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.deepSeq Primop. Takes 2 arguments. e1, e2. This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are also evaluated recursively. Noogle also knows. Aliases. builtins.deepSeq. lib.deepSeq.",
    "raw_url": "/f/lib/trivial/deepSeq.html",
    "excerpt": "lib.trivial.deepSeq Primop. Takes 2 arguments. e1, e2. This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/setFunctionArgs.html",
    "content": "lib.trivial.setFunctionArgs. Add metadata about expected function arguments to a function. The metadata should match the format given by builtins.functionArgs, i.e. a set from expected argument to a bool representing whether that argument has a default or not. setFunctionArgs : (a → b) → Map String Bool → (a → b) This function is necessary because you can't dynamically create a function of the { a, b ? foo, ... }: format, but some facilities like callPackage expect to be able to query expected arguments. Arguments. [f] [args] Edit source. Noogle also knows. Aliases. lib.setFunctionArgs.",
    "word_count": 94,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.setFunctionArgs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 84
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.setFunctionArgs. Add metadata about expected function arguments to a function. The metadata should match the format given by builtins.functionArgs, i.e. a set from expected argument to a bool representing whether that argument has a default or not. setFunctionArgs : (a → b) → Map String Bool → (a → b) This function is necessary because you can't dynamically create a function of the { a, b ? foo, ... }: format, but some facilities like callPackage expect to be able to query expected arguments. Arguments. [f] [args] Edit source. Noogle also knows. Aliases. lib.setFunctionArgs.",
    "raw_url": "/f/lib/trivial/setFunctionArgs.html",
    "excerpt": "lib.trivial.setFunctionArgs. Add metadata about expected function arguments to a function. The metadata should match the format given by builtins.functionArgs, i.e. a set from expected argument to a bool representing whether",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/mirrorFunctionArgs.html",
    "content": "lib.trivial.mirrorFunctionArgs. mirrorFunctionArgs f g creates a new function g' with the same behavior as g (g' x == g x) but its function arguments mirroring f (lib.functionArgs g' == lib.functionArgs f). Example. addab = {a, b}: a + b addab { a = 2; b = 4; } => 6 lib.functionArgs addab => { a = false; b = false; } addab1 = attrs: addab attrs + 1 addab1 { a = 2; b = 4; } => 7 lib.functionArgs addab1 => { } addab1' = lib.mirrorFunctionArgs addab addab1 addab1' { a = 2; b = 4; } => 7 lib.functionArgs addab1' => { a = false; b = false; } Type. mirrorFunctionArgs :: (a -> b) -> (a -> c) -> (a -> c) Arguments. [f] Function to provide the argument metadata. Edit source. Noogle also knows. Aliases. lib.mirrorFunctionArgs.",
    "word_count": 140,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.mirrorFunctionArgs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 31
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 111
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 125
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.mirrorFunctionArgs. mirrorFunctionArgs f g creates a new function g' with the same behavior as g (g' x == g x) but its function arguments mirroring f (lib.functionArgs g' == lib.functionArgs f). Example. addab = {a, b}: a + b addab { a = 2; b = 4; } =&gt; 6 lib.functionArgs addab =&gt; { a = false; b = false; } addab1 = attrs: addab attrs + 1 addab1 { a = 2; b = 4; } =&gt; 7 lib.functionArgs addab1 =&gt; { } addab1' = lib.mirrorFunctionArgs addab addab1 addab1' { a = 2; b = 4; } =&gt; 7 lib.functionArgs addab1' =&gt; { a = false; b = false; } Type. mirrorFunctionArgs :: (a -&gt; b) -&gt; (a -&gt; c) -&gt; (a -&gt; c) Arguments. [f] Function to provide the argument metadata. Edit source. Noogle also knows. Aliases. lib.mirrorFunctionArgs.",
    "raw_url": "/f/lib/trivial/mirrorFunctionArgs.html",
    "excerpt": "lib.trivial.mirrorFunctionArgs. mirrorFunctionArgs f g creates a new function g' with the same behavior as g (g' x == g x) but its function arguments mirroring f (lib.functionArgs g' == lib.functionArgs",
    "sub_results": []
  },
  {
    "url": "/f/lib/trivial/isInt.html",
    "content": "lib.trivial.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. builtins.isInt. lib.isInt. lib.strings.isInt.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.trivial.isInt Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.trivial.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. builtins.isInt. lib.isInt. lib.strings.isInt.",
    "raw_url": "/f/lib/trivial/isInt.html",
    "excerpt": "lib.trivial.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. builtins.isInt. lib.isInt. lib.strings.isInt.",
    "sub_results": []
  },
  {
    "url": "/f/lib/isInOldestRelease.html",
    "content": "lib.isInOldestRelease. Whether a feature is supported in all supported releases (at the time of release branch-off, if applicable). See oldestSupportedRelease. Arguments. [release] Release number of feature introduction as an integer, e.g. 2111 for 21.11. Set it to the upcoming release, matching the nixpkgs/.version file. Edit source. Noogle also knows. Aliases. lib.trivial.isInOldestRelease.",
    "word_count": 51,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isInOldestRelease"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isInOldestRelease. Whether a feature is supported in all supported releases (at the time of release branch-off, if applicable). See oldestSupportedRelease. Arguments. [release] Release number of feature introduction as an integer, e.g. 2111 for 21.11. Set it to the upcoming release, matching the nixpkgs/.version file. Edit source. Noogle also knows. Aliases. lib.trivial.isInOldestRelease.",
    "raw_url": "/f/lib/isInOldestRelease.html",
    "excerpt": "lib.isInOldestRelease. Whether a feature is supported in all supported releases (at the time of release branch-off, if applicable). See oldestSupportedRelease. Arguments. [release] Release number of feature introduction as an integer,",
    "sub_results": []
  },
  {
    "url": "/f/lib/versions/patch.html",
    "content": "lib.versions.patch. Get the patch version string from a string. Example. patch \"1.2.3\" => \"3\" Arguments. [v] Edit source.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.versions.patch"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.versions.patch. Get the patch version string from a string. Example. patch \"1.2.3\" =&gt; \"3\" Arguments. [v] Edit source.",
    "raw_url": "/f/lib/versions/patch.html",
    "excerpt": "lib.versions.patch. Get the patch version string from a string. Example. patch \"1.2.3\" =&gt; \"3\" Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/versions/pad.html",
    "content": "lib.versions.pad. Pad a version string with zeros to match the given number of components. Example. pad 3 \"1.2\" => \"1.2.0\" pad 3 \"1.3-rc1\" => \"1.3.0-rc1\" pad 3 \"1.2.3.4\" => \"1.2.3\" Arguments. [n] [version] Edit source.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.versions.pad"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 30
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.versions.pad. Pad a version string with zeros to match the given number of components. Example. pad 3 \"1.2\" =&gt; \"1.2.0\" pad 3 \"1.3-rc1\" =&gt; \"1.3.0-rc1\" pad 3 \"1.2.3.4\" =&gt; \"1.2.3\" Arguments. [n] [version] Edit source.",
    "raw_url": "/f/lib/versions/pad.html",
    "excerpt": "lib.versions.pad. Pad a version string with zeros to match the given number of components. Example. pad 3 \"1.2\" =&gt; \"1.2.0\" pad 3 \"1.3-rc1\" =&gt; \"1.3.0-rc1\" pad 3 \"1.2.3.4\" =&gt; \"1.2.3\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/versions/splitVersion.html",
    "content": "lib.versions.splitVersion Primop. Takes 1 arguments. s. Break a version string into its component parts. Example. splitVersion \"1.2.3\" => [\"1\" \"2\" \"3\"] Edit source. Noogle also knows. Aliases. builtins.splitVersion. lib.splitVersion.",
    "word_count": 29,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.versions.splitVersion Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.versions.splitVersion Primop. Takes 1 arguments. s. Break a version string into its component parts. Example. splitVersion \"1.2.3\" =&gt; [\"1\" \"2\" \"3\"] Edit source. Noogle also knows. Aliases. builtins.splitVersion. lib.splitVersion.",
    "raw_url": "/f/lib/versions/splitVersion.html",
    "excerpt": "lib.versions.splitVersion Primop. Takes 1 arguments. s. Break a version string into its component parts. Example. splitVersion \"1.2.3\" =&gt; [\"1\" \"2\" \"3\"] Edit source. Noogle also knows. Aliases. builtins.splitVersion. lib.splitVersion.",
    "sub_results": []
  },
  {
    "url": "/f/lib/versions/major.html",
    "content": "lib.versions.major. Get the major version string from a string. Example. major \"1.2.3\" => \"1\" Arguments. [v] Edit source.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.versions.major"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.versions.major. Get the major version string from a string. Example. major \"1.2.3\" =&gt; \"1\" Arguments. [v] Edit source.",
    "raw_url": "/f/lib/versions/major.html",
    "excerpt": "lib.versions.major. Get the major version string from a string. Example. major \"1.2.3\" =&gt; \"1\" Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/versions/minor.html",
    "content": "lib.versions.minor. Get the minor version string from a string. Example. minor \"1.2.3\" => \"2\" Arguments. [v] Edit source.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.versions.minor"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.versions.minor. Get the minor version string from a string. Example. minor \"1.2.3\" =&gt; \"2\" Arguments. [v] Edit source.",
    "raw_url": "/f/lib/versions/minor.html",
    "excerpt": "lib.versions.minor. Get the minor version string from a string. Example. minor \"1.2.3\" =&gt; \"2\" Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/versions/majorMinor.html",
    "content": "lib.versions.majorMinor. Get string of the first two parts (major and minor) of a version string. Example. majorMinor \"1.2.3\" => \"1.2\" Arguments. [v] Edit source.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.versions.majorMinor"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.versions.majorMinor. Get string of the first two parts (major and minor) of a version string. Example. majorMinor \"1.2.3\" =&gt; \"1.2\" Arguments. [v] Edit source.",
    "raw_url": "/f/lib/versions/majorMinor.html",
    "excerpt": "lib.versions.majorMinor. Get string of the first two parts (major and minor) of a version string. Example. majorMinor \"1.2.3\" =&gt; \"1.2\" Arguments. [v] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/overrideDerivation.html",
    "content": "lib.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -> ( Derivation -> AttrSet ) -> Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. pkgs.dockerTools.overrideDerivation. lib.customisation.overrideDerivation. pkgs.pythonPackages.overrideDerivation. pkgs.stdenv.overrideDerivation. pkgs.writers.overrideDerivation.",
    "word_count": 208,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.overrideDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 157
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 182
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 194
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original are overridden according to the function f. The function f is called with the original derivation attributes. overrideDerivation allows certain \"ad-hoc\" customisation scenarios (e.g. in ~/.config/nixpkgs/config.nix). For instance, if you want to \"patch\" the derivation returned by a package function in Nixpkgs to build another version than what the function itself provides. For another application, see build-support/vm, where this function is used to build arbitrary derivations inside a QEMU virtual machine. Note that in order to preserve evaluation errors, the new derivation's outPath depends on the old one's, which means that this function cannot be used in circular situations when the old derivation also depends on the new one. You should in general prefer drv.overrideAttrs over this function; see the nixpkgs manual for more information on overriding. Example. mySed = overrideDerivation pkgs.gnused (oldAttrs: { name = \"sed-4.2.2-pre\"; src = fetchurl { url = ftp://alpha.gnu.org/gnu/sed/sed-4.2.2-pre.tar.bz2; hash = \"sha256-MxBJRcM2rYzQYwJ5XKxhXTQByvSg5jZc5cSHEZoB2IY=\"; }; patches = []; }); Type. overrideDerivation :: Derivation -&gt; ( Derivation -&gt; AttrSet ) -&gt; Derivation Arguments. [drv] [f] Edit source. Noogle also knows. Aliases. pkgs.dockerTools.overrideDerivation. lib.customisation.overrideDerivation. pkgs.pythonPackages.overrideDerivation. pkgs.stdenv.overrideDerivation. pkgs.writers.overrideDerivation.",
    "raw_url": "/f/lib/overrideDerivation.html",
    "excerpt": "lib.overrideDerivation. overrideDerivation drv f takes a derivation (i.e., the result of a call to the builtin function derivation) and returns a new derivation in which the attributes of the original",
    "sub_results": []
  },
  {
    "url": "/f/lib/imap0.html",
    "content": "lib.imap0. Map with index starting from 0. Example. imap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] => [ \"a-0\" \"b-1\" ] Type. imap0 :: (int -> a -> b) -> [a] -> [b] Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.lists.imap0.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.imap0"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 7
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.imap0. Map with index starting from 0. Example. imap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] =&gt; [ \"a-0\" \"b-1\" ] Type. imap0 :: (int -&gt; a -&gt; b) -&gt; [a] -&gt; [b] Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.lists.imap0.",
    "raw_url": "/f/lib/imap0.html",
    "excerpt": "lib.imap0. Map with index starting from 0. Example. imap0 (i: v: \"${v}-${toString i}\") [\"a\" \"b\"] =&gt; [ \"a-0\" \"b-1\" ] Type. imap0 :: (int -&gt; a -&gt; b) -&gt; [a]",
    "sub_results": []
  },
  {
    "url": "/f/lib/isDerivation.html",
    "content": "lib.isDerivation. Check whether the argument is a derivation. Any set with { type = \"derivation\"; } counts as a derivation. Example. nixpkgs = import <nixpkgs> {} isDerivation nixpkgs.ruby => true isDerivation \"foobar\" => false Type. isDerivation :: Any -> Bool Arguments. [value] Value to check. Edit source. Noogle also knows. Aliases. lib.attrsets.isDerivation.",
    "word_count": 52,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isDerivation. Check whether the argument is a derivation. Any set with { type = \"derivation\"; } counts as a derivation. Example. nixpkgs = import &lt;nixpkgs&gt; {} isDerivation nixpkgs.ruby =&gt; true isDerivation \"foobar\" =&gt; false Type. isDerivation :: Any -&gt; Bool Arguments. [value] Value to check. Edit source. Noogle also knows. Aliases. lib.attrsets.isDerivation.",
    "raw_url": "/f/lib/isDerivation.html",
    "excerpt": "lib.isDerivation. Check whether the argument is a derivation. Any set with { type = \"derivation\"; } counts as a derivation. Example. nixpkgs = import &lt;nixpkgs&gt; {} isDerivation nixpkgs.ruby =&gt; true",
    "sub_results": []
  },
  {
    "url": "/f/lib/tail.html",
    "content": "lib.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should generally be avoided since it's inefficient: unlike Haskell's tail, it takes O(n) time, so recursing over a list by repeatedly calling tail takes O(n^2) time. Noogle also knows. Aliases. builtins.tail. lib.lists.tail. lib.strings.tail.",
    "word_count": 62,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.tail Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should generally be avoided since it's inefficient: unlike Haskell's tail, it takes O(n) time, so recursing over a list by repeatedly calling tail takes O(n^2) time. Noogle also knows. Aliases. builtins.tail. lib.lists.tail. lib.strings.tail.",
    "raw_url": "/f/lib/tail.html",
    "excerpt": "lib.tail Primop. Takes 1 arguments. list. Return the list without its first item; abort evaluation if the argument isn’t a list or is an empty list. Warning. This function should",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/cleanSourceWith.html",
    "content": "lib.sources.cleanSourceWith. Like builtins.filterSource, except it will compose with itself, allowing you to chain multiple calls together without any intermediate copies being put in the nix store. Example. lib.cleanSourceWith { filter = f; src = lib.cleanSourceWith { filter = g; src = ./.; }; } # Succeeds! builtins.filterSource f (builtins.filterSource g ./.) # Fails! Arguments. Edit source. Noogle also knows. Aliases. lib.cleanSourceWith.",
    "word_count": 61,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.cleanSourceWith"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 26
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 53
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.cleanSourceWith. Like builtins.filterSource, except it will compose with itself, allowing you to chain multiple calls together without any intermediate copies being put in the nix store. Example. lib.cleanSourceWith { filter = f; src = lib.cleanSourceWith { filter = g; src = ./.; }; } # Succeeds! builtins.filterSource f (builtins.filterSource g ./.) # Fails! Arguments. Edit source. Noogle also knows. Aliases. lib.cleanSourceWith.",
    "raw_url": "/f/lib/sources/cleanSourceWith.html",
    "excerpt": "lib.sources.cleanSourceWith. Like builtins.filterSource, except it will compose with itself, allowing you to chain multiple calls together without any intermediate copies being put in the nix store. Example. lib.cleanSourceWith { filter",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/canCleanSource.html",
    "content": "lib.sources.canCleanSource. Edit source. Noogle also knows. Aliases. lib.canCleanSource.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.canCleanSource"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.canCleanSource. Edit source. Noogle also knows. Aliases. lib.canCleanSource.",
    "raw_url": "/f/lib/sources/canCleanSource.html",
    "excerpt": "lib.sources.canCleanSource. Edit source. Noogle also knows. Aliases. lib.canCleanSource.",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/sourceFilesBySuffices.html",
    "content": "lib.sources.sourceFilesBySuffices. Get all files ending with the specified suffices from the given source directory or its descendants, omitting files that do not match any suffix. The result of the example below will include files like ./dir/module.c and ./dir/subdir/doc.xml if present. Example. sourceFilesBySuffices ./. [ \".xml\" \".c\" ] Type. sourceLike -> [String] -> Source Arguments. [src] Path or source containing the files to be returned. [exts] A list of file suffix strings. Edit source. Noogle also knows. Aliases. lib.sourceFilesBySuffices.",
    "word_count": 78,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.sourceFilesBySuffices"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 40
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 53
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.sourceFilesBySuffices. Get all files ending with the specified suffices from the given source directory or its descendants, omitting files that do not match any suffix. The result of the example below will include files like ./dir/module.c and ./dir/subdir/doc.xml if present. Example. sourceFilesBySuffices ./. [ \".xml\" \".c\" ] Type. sourceLike -&gt; [String] -&gt; Source Arguments. [src] Path or source containing the files to be returned. [exts] A list of file suffix strings. Edit source. Noogle also knows. Aliases. lib.sourceFilesBySuffices.",
    "raw_url": "/f/lib/sources/sourceFilesBySuffices.html",
    "excerpt": "lib.sources.sourceFilesBySuffices. Get all files ending with the specified suffices from the given source directory or its descendants, omitting files that do not match any suffix. The result of the example",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/trace.html",
    "content": "lib.sources.trace. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This function takes a final argument to return. In comparison, traceVal returns the given file set argument. This variant is useful for tracing file sets in the Nix repl. Example. trace (unions [ ./Makefile ./src ./tests/run.sh ]) null => trace: /home/user/src/myProject trace: - Makefile (regular) trace: - src (all files in directory) trace: - tests trace: - run.sh (regular) null Type. trace :: FileSet -> Any -> Any Arguments. [fileset] The file set to trace. This argument can also be a path, which gets implicitly coerced to a file set. Edit source. Noogle also knows. Aliases. lib.fileset.trace.",
    "word_count": 126,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.trace"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 58
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 89
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 97
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.trace. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This function takes a final argument to return. In comparison, traceVal returns the given file set argument. This variant is useful for tracing file sets in the Nix repl. Example. trace (unions [ ./Makefile ./src ./tests/run.sh ]) null =&gt; trace: /home/user/src/myProject trace: - Makefile (regular) trace: - src (all files in directory) trace: - tests trace: - run.sh (regular) null Type. trace :: FileSet -&gt; Any -&gt; Any Arguments. [fileset] The file set to trace. This argument can also be a path, which gets implicitly coerced to a file set. Edit source. Noogle also knows. Aliases. lib.fileset.trace.",
    "raw_url": "/f/lib/sources/trace.html",
    "excerpt": "lib.sources.trace. Incrementally evaluate and trace a file set in a pretty way. This function is only intended for debugging purposes. The exact tracing format is unspecified and may change. This",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/pathIsDirectory.html",
    "content": "lib.sources.pathIsDirectory. Whether a path exists and is a directory. Example. pathIsDirectory /. => true pathIsDirectory /this/does/not/exist => false pathIsDirectory /some/file.nix => false Type. pathIsDirectory :: Path -> Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.pathIsDirectory. lib.filesystem.pathIsDirectory.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.pathIsDirectory"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 28
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.pathIsDirectory. Whether a path exists and is a directory. Example. pathIsDirectory /. =&gt; true pathIsDirectory /this/does/not/exist =&gt; false pathIsDirectory /some/file.nix =&gt; false Type. pathIsDirectory :: Path -&gt; Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.pathIsDirectory. lib.filesystem.pathIsDirectory.",
    "raw_url": "/f/lib/sources/pathIsDirectory.html",
    "excerpt": "lib.sources.pathIsDirectory. Whether a path exists and is a directory. Example. pathIsDirectory /. =&gt; true pathIsDirectory /this/does/not/exist =&gt; false pathIsDirectory /some/file.nix =&gt; false Type. pathIsDirectory :: Path -&gt; Bool Arguments. [path]",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/cleanSourceFilter.html",
    "content": "lib.sources.cleanSourceFilter. A basic filter for cleanSourceWith that removes directories of version control system, backup files (*~) and some generated files. Arguments. [name] [type] Edit source. Noogle also knows. Aliases. lib.cleanSourceFilter.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.cleanSourceFilter"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 20
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.cleanSourceFilter. A basic filter for cleanSourceWith that removes directories of version control system, backup files (*~) and some generated files. Arguments. [name] [type] Edit source. Noogle also knows. Aliases. lib.cleanSourceFilter.",
    "raw_url": "/f/lib/sources/cleanSourceFilter.html",
    "excerpt": "lib.sources.cleanSourceFilter. A basic filter for cleanSourceWith that removes directories of version control system, backup files (*~) and some generated files. Arguments. [name] [type] Edit source. Noogle also knows. Aliases. lib.cleanSourceFilter.",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/pathHasContext.html",
    "content": "lib.sources.pathHasContext Primop. Takes 1 arguments. s. Return true if string s has a non-empty context. The context can be obtained with getContext. Noogle also knows. Aliases. builtins.hasContext. lib.pathHasContext.",
    "word_count": 28,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.pathHasContext Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.pathHasContext Primop. Takes 1 arguments. s. Return true if string s has a non-empty context. The context can be obtained with getContext. Noogle also knows. Aliases. builtins.hasContext. lib.pathHasContext.",
    "raw_url": "/f/lib/sources/pathHasContext.html",
    "excerpt": "lib.sources.pathHasContext Primop. Takes 1 arguments. s. Return true if string s has a non-empty context. The context can be obtained with getContext. Noogle also knows. Aliases. builtins.hasContext. lib.pathHasContext.",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/pathType.html",
    "content": "lib.sources.pathType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else. Example. pathType /. => \"directory\" pathType /some/file.nix => \"regular\" Type. pathType :: Path -> String Edit source. Noogle also knows. Aliases. builtins.readFileType. lib.pathType. lib.filesystem.pathType.",
    "word_count": 65,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.pathType Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 41
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.pathType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a regular file, \"symlink\" for a symlink, or \"unknown\" for anything else. Example. pathType /. =&gt; \"directory\" pathType /some/file.nix =&gt; \"regular\" Type. pathType :: Path -&gt; String Edit source. Noogle also knows. Aliases. builtins.readFileType. lib.pathType. lib.filesystem.pathType.",
    "raw_url": "/f/lib/sources/pathType.html",
    "excerpt": "lib.sources.pathType Primop. Takes 1 arguments. p. The type of a path. The path needs to exist and be accessible. The result is either \"directory\" for a directory, \"regular\" for a",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/cleanSource.html",
    "content": "lib.sources.cleanSource. Filters a source tree removing version control files and directories using cleanSourceFilter. Example. cleanSource ./. Arguments. [src] Edit source. Noogle also knows. Aliases. lib.cleanSource.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.cleanSource"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 16
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.cleanSource. Filters a source tree removing version control files and directories using cleanSourceFilter. Example. cleanSource ./. Arguments. [src] Edit source. Noogle also knows. Aliases. lib.cleanSource.",
    "raw_url": "/f/lib/sources/cleanSource.html",
    "excerpt": "lib.sources.cleanSource. Filters a source tree removing version control files and directories using cleanSourceFilter. Example. cleanSource ./. Arguments. [src] Edit source. Noogle also knows. Aliases. lib.cleanSource.",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/pathIsGitRepo.html",
    "content": "lib.sources.pathIsGitRepo. Edit source. Noogle also knows. Aliases. lib.pathIsGitRepo.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.pathIsGitRepo"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.pathIsGitRepo. Edit source. Noogle also knows. Aliases. lib.pathIsGitRepo.",
    "raw_url": "/f/lib/sources/pathIsGitRepo.html",
    "excerpt": "lib.sources.pathIsGitRepo. Edit source. Noogle also knows. Aliases. lib.pathIsGitRepo.",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/pathIsRegularFile.html",
    "content": "lib.sources.pathIsRegularFile. Whether a path exists and is a regular file, meaning not a symlink or any other special file type. Example. pathIsRegularFile /. => false pathIsRegularFile /this/does/not/exist => false pathIsRegularFile /some/file.nix => true Type. pathIsRegularFile :: Path -> Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.pathIsRegularFile. lib.filesystem.pathIsRegularFile.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.pathIsRegularFile"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 33
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.pathIsRegularFile. Whether a path exists and is a regular file, meaning not a symlink or any other special file type. Example. pathIsRegularFile /. =&gt; false pathIsRegularFile /this/does/not/exist =&gt; false pathIsRegularFile /some/file.nix =&gt; true Type. pathIsRegularFile :: Path -&gt; Bool Arguments. [path] Edit source. Noogle also knows. Aliases. lib.pathIsRegularFile. lib.filesystem.pathIsRegularFile.",
    "raw_url": "/f/lib/sources/pathIsRegularFile.html",
    "excerpt": "lib.sources.pathIsRegularFile. Whether a path exists and is a regular file, meaning not a symlink or any other special file type. Example. pathIsRegularFile /. =&gt; false pathIsRegularFile /this/does/not/exist =&gt; false pathIsRegularFile",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/commitIdFromGitRepo.html",
    "content": "lib.sources.commitIdFromGitRepo. Get the commit id of a git repo. Example. commitIdFromGitRepo <nixpkgs/.git> Arguments. [path] Edit source. Noogle also knows. Aliases. lib.commitIdFromGitRepo.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.commitIdFromGitRepo"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.commitIdFromGitRepo. Get the commit id of a git repo. Example. commitIdFromGitRepo &lt;nixpkgs/.git&gt; Arguments. [path] Edit source. Noogle also knows. Aliases. lib.commitIdFromGitRepo.",
    "raw_url": "/f/lib/sources/commitIdFromGitRepo.html",
    "excerpt": "lib.sources.commitIdFromGitRepo. Get the commit id of a git repo. Example. commitIdFromGitRepo &lt;nixpkgs/.git&gt; Arguments. [path] Edit source. Noogle also knows. Aliases. lib.commitIdFromGitRepo.",
    "sub_results": []
  },
  {
    "url": "/f/lib/sources/sourceByRegex.html",
    "content": "lib.sources.sourceByRegex. Filter sources by a list of regular expressions. Example. src = sourceByRegex ./my-subproject [\".*\\.py$\" \"^database.sql$\"] Arguments. [src] [regexes] Edit source. Noogle also knows. Aliases. lib.sourceByRegex.",
    "word_count": 26,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sources.sourceByRegex"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 16
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sources.sourceByRegex. Filter sources by a list of regular expressions. Example. src = sourceByRegex ./my-subproject [\".*\\.py$\" \"^database.sql$\"] Arguments. [src] [regexes] Edit source. Noogle also knows. Aliases. lib.sourceByRegex.",
    "raw_url": "/f/lib/sources/sourceByRegex.html",
    "excerpt": "lib.sources.sourceByRegex. Filter sources by a list of regular expressions. Example. src = sourceByRegex ./my-subproject [\".*\\.py$\" \"^database.sql$\"] Arguments. [src] [regexes] Edit source. Noogle also knows. Aliases. lib.sourceByRegex.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkFixStrictness.html",
    "content": "lib.mkFixStrictness. The identity function For when you need a function that does “nothing”. Type. id :: a -> a Arguments. [x] The value to return. Edit source. Noogle also knows. Aliases. lib.modules.mkFixStrictness.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkFixStrictness"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 19
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkFixStrictness. The identity function For when you need a function that does “nothing”. Type. id :: a -&gt; a Arguments. [x] The value to return. Edit source. Noogle also knows. Aliases. lib.modules.mkFixStrictness.",
    "raw_url": "/f/lib/mkFixStrictness.html",
    "excerpt": "lib.mkFixStrictness. The identity function For when you need a function that does “nothing”. Type. id :: a -&gt; a Arguments. [x] The value to return. Edit source. Noogle also knows.",
    "sub_results": []
  },
  {
    "url": "/f/lib/elemAt.html",
    "content": "lib.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of bounds. Noogle also knows. Aliases. builtins.elemAt. lib.lists.elemAt. lib.strings.elemAt.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.elemAt Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of bounds. Noogle also knows. Aliases. builtins.elemAt. lib.lists.elemAt. lib.strings.elemAt.",
    "raw_url": "/f/lib/elemAt.html",
    "excerpt": "lib.elemAt Primop. Takes 2 arguments. xs, n. Return element n from the list xs. Elements are counted starting from 0. A fatal error occurs if the index is out of",
    "sub_results": []
  },
  {
    "url": "/f/lib/nameValuePair.html",
    "content": "lib.nameValuePair. Utility function that creates a {name, value} pair as expected by builtins.listToAttrs. Example. nameValuePair \"some\" 6 => { name = \"some\"; value = 6; } Type. nameValuePair :: String -> Any -> { name :: String; value :: Any; } Arguments. [name] Attribute name. [value] Attribute value. Edit source. Noogle also knows. Aliases. lib.attrsets.nameValuePair.",
    "word_count": 55,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.nameValuePair"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 26
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.nameValuePair. Utility function that creates a {name, value} pair as expected by builtins.listToAttrs. Example. nameValuePair \"some\" 6 =&gt; { name = \"some\"; value = 6; } Type. nameValuePair :: String -&gt; Any -&gt; { name :: String; value :: Any; } Arguments. [name] Attribute name. [value] Attribute value. Edit source. Noogle also knows. Aliases. lib.attrsets.nameValuePair.",
    "raw_url": "/f/lib/nameValuePair.html",
    "excerpt": "lib.nameValuePair. Utility function that creates a {name, value} pair as expected by builtins.listToAttrs. Example. nameValuePair \"some\" 6 =&gt; { name = \"some\"; value = 6; } Type. nameValuePair :: String",
    "sub_results": []
  },
  {
    "url": "/f/lib/flatten.html",
    "content": "lib.flatten. Flatten the argument into a single list; that is, nested lists are spliced into the top-level lists. Example. flatten [1 [2 [3] 4] 5] => [1 2 3 4 5] flatten 1 => [1] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.lists.flatten.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.flatten"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.flatten. Flatten the argument into a single list; that is, nested lists are spliced into the top-level lists. Example. flatten [1 [2 [3] 4] 5] =&gt; [1 2 3 4 5] flatten 1 =&gt; [1] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.lists.flatten.",
    "raw_url": "/f/lib/flatten.html",
    "excerpt": "lib.flatten. Flatten the argument into a single list; that is, nested lists are spliced into the top-level lists. Example. flatten [1 [2 [3] 4] 5] =&gt; [1 2 3 4",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkChangedOptionModule.html",
    "content": "lib.mkChangedOptionModule. Single \"from\" version of mkMergedOptionModule. Return a module that causes a warning to be shown if the \"from\" option is defined; the defined value can be used in the \"mergeFn\" to set the \"to\" value. This function can be used to change an option into another that has a different type. \"mergeFn\" takes the module \"config\" as a parameter and must return a value of \"to\" option type. mkChangedOptionModule [ \"a\" \"b\" \"c\" ] [ \"x\" \"y\" \"z\" ] (config: let value = getAttrFromPath [ \"a\" \"b\" \"c\" ] config; in if value > 100 then \"high\" else \"normal\"). options.a.b.c is a removed int option. options.x.y.z is a new str option that supersedes a.b.c This show a warning if a.b.c is set, and set the value of x.y.z to the result of the change function. Arguments. [from] [to] [changeFn] Edit source. Noogle also knows. Aliases. lib.modules.mkChangedOptionModule.",
    "word_count": 147,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkChangedOptionModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 136
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkChangedOptionModule. Single \"from\" version of mkMergedOptionModule. Return a module that causes a warning to be shown if the \"from\" option is defined; the defined value can be used in the \"mergeFn\" to set the \"to\" value. This function can be used to change an option into another that has a different type. \"mergeFn\" takes the module \"config\" as a parameter and must return a value of \"to\" option type. mkChangedOptionModule [ \"a\" \"b\" \"c\" ] [ \"x\" \"y\" \"z\" ] (config: let value = getAttrFromPath [ \"a\" \"b\" \"c\" ] config; in if value &gt; 100 then \"high\" else \"normal\"). options.a.b.c is a removed int option. options.x.y.z is a new str option that supersedes a.b.c This show a warning if a.b.c is set, and set the value of x.y.z to the result of the change function. Arguments. [from] [to] [changeFn] Edit source. Noogle also knows. Aliases. lib.modules.mkChangedOptionModule.",
    "raw_url": "/f/lib/mkChangedOptionModule.html",
    "excerpt": "lib.mkChangedOptionModule. Single \"from\" version of mkMergedOptionModule. Return a module that causes a warning to be shown if the \"from\" option is defined; the defined value can be used in the",
    "sub_results": []
  },
  {
    "url": "/f/lib/any.html",
    "content": "lib.any Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for at least one element of list. Example. any isString [ 1 \"a\" { } ] => true any isString [ 1 { } ] => false Type. any :: (a -> bool) -> [a] -> bool Edit source. Noogle also knows. Aliases. builtins.any. lib.lists.any.",
    "word_count": 59,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.any Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 21
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.any Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for at least one element of list. Example. any isString [ 1 \"a\" { } ] =&gt; true any isString [ 1 { } ] =&gt; false Type. any :: (a -&gt; bool) -&gt; [a] -&gt; bool Edit source. Noogle also knows. Aliases. builtins.any. lib.lists.any.",
    "raw_url": "/f/lib/any.html",
    "excerpt": "lib.any Primop. Takes 2 arguments. pred, list. Return true if function pred returns true for at least one element of list. Example. any isString [ 1 \"a\" { } ]",
    "sub_results": []
  },
  {
    "url": "/f/lib/getLicenseFromSpdxId.html",
    "content": "lib.getLicenseFromSpdxId. Get the corresponding attribute in lib.licenses from the SPDX ID. For SPDX IDs, see https://spdx.org/licenses. Example. lib.getLicenseFromSpdxId \"MIT\" == lib.licenses.mit => true lib.getLicenseFromSpdxId \"mIt\" == lib.licenses.mit => true lib.getLicenseFromSpdxId \"MY LICENSE\" => trace: warning: getLicenseFromSpdxId: No license matches the given SPDX ID: MY LICENSE => { shortName = \"MY LICENSE\"; } Type. getLicenseFromSpdxId :: str -> AttrSet Edit source. Noogle also knows. Aliases. lib.meta.getLicenseFromSpdxId.",
    "word_count": 65,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getLicenseFromSpdxId"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 52
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getLicenseFromSpdxId. Get the corresponding attribute in lib.licenses from the SPDX ID. For SPDX IDs, see https://spdx.org/licenses. Example. lib.getLicenseFromSpdxId \"MIT\" == lib.licenses.mit =&gt; true lib.getLicenseFromSpdxId \"mIt\" == lib.licenses.mit =&gt; true lib.getLicenseFromSpdxId \"MY LICENSE\" =&gt; trace: warning: getLicenseFromSpdxId: No license matches the given SPDX ID: MY LICENSE =&gt; { shortName = \"MY LICENSE\"; } Type. getLicenseFromSpdxId :: str -&gt; AttrSet Edit source. Noogle also knows. Aliases. lib.meta.getLicenseFromSpdxId.",
    "raw_url": "/f/lib/getLicenseFromSpdxId.html",
    "excerpt": "lib.getLicenseFromSpdxId. Get the corresponding attribute in lib.licenses from the SPDX ID. For SPDX IDs, see https://spdx.org/licenses. Example. lib.getLicenseFromSpdxId \"MIT\" == lib.licenses.mit =&gt; true lib.getLicenseFromSpdxId \"mIt\" == lib.licenses.mit =&gt; true lib.getLicenseFromSpdxId",
    "sub_results": []
  },
  {
    "url": "/f/lib/getExe.html",
    "content": "lib.getExe. Get the path to the main program of a package based on meta.mainProgram. Example. getExe pkgs.hello => \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe pkgs.mustache-go => \"/nix/store/am9ml4f4ywvivxnkiaqwr0hyxka1xjsf-mustache-go-1.3.0/bin/mustache\" Type. getExe :: package -> string Arguments. [x] Edit source. Noogle also knows. Aliases. lib.meta.getExe.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getExe"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getExe. Get the path to the main program of a package based on meta.mainProgram. Example. getExe pkgs.hello =&gt; \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe pkgs.mustache-go =&gt; \"/nix/store/am9ml4f4ywvivxnkiaqwr0hyxka1xjsf-mustache-go-1.3.0/bin/mustache\" Type. getExe :: package -&gt; string Arguments. [x] Edit source. Noogle also knows. Aliases. lib.meta.getExe.",
    "raw_url": "/f/lib/getExe.html",
    "excerpt": "lib.getExe. Get the path to the main program of a package based on meta.mainProgram. Example. getExe pkgs.hello =&gt; \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe pkgs.mustache-go =&gt; \"/nix/store/am9ml4f4ywvivxnkiaqwr0hyxka1xjsf-mustache-go-1.3.0/bin/mustache\" Type. getExe :: package -&gt; string Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/nixType.html",
    "content": "lib.nixType. Edit source. Noogle also knows. Aliases. lib.misc.nixType.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.nixType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.nixType. Edit source. Noogle also knows. Aliases. lib.misc.nixType.",
    "raw_url": "/f/lib/nixType.html",
    "excerpt": "lib.nixType. Edit source. Noogle also knows. Aliases. lib.misc.nixType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/concatImapStrings.html",
    "content": "lib.concatImapStrings. Like concatMapStrings except that the f functions also gets the position as a parameter. Example. concatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"] => \"1-foo2-bar\" Type. concatImapStrings :: (int -> a -> string) -> [a] -> string Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.strings.concatImapStrings.",
    "word_count": 47,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concatImapStrings"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 37
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concatImapStrings. Like concatMapStrings except that the f functions also gets the position as a parameter. Example. concatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"] =&gt; \"1-foo2-bar\" Type. concatImapStrings :: (int -&gt; a -&gt; string) -&gt; [a] -&gt; string Arguments. [f] [list] Edit source. Noogle also knows. Aliases. lib.strings.concatImapStrings.",
    "raw_url": "/f/lib/concatImapStrings.html",
    "excerpt": "lib.concatImapStrings. Like concatMapStrings except that the f functions also gets the position as a parameter. Example. concatImapStrings (pos: x: \"${toString pos}-${x}\") [\"foo\" \"bar\"] =&gt; \"1-foo2-bar\" Type. concatImapStrings :: (int -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/isAttrs.html",
    "content": "lib.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. builtins.isAttrs. lib.attrsets.isAttrs. lib.strings.isAttrs.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isAttrs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. builtins.isAttrs. lib.attrsets.isAttrs. lib.strings.isAttrs.",
    "raw_url": "/f/lib/isAttrs.html",
    "excerpt": "lib.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. builtins.isAttrs. lib.attrsets.isAttrs. lib.strings.isAttrs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/maybeAttr.html",
    "content": "lib.maybeAttr. Edit source. Noogle also knows. Aliases. lib.misc.maybeAttr.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.maybeAttr"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.maybeAttr. Edit source. Noogle also knows. Aliases. lib.misc.maybeAttr.",
    "raw_url": "/f/lib/maybeAttr.html",
    "excerpt": "lib.maybeAttr. Edit source. Noogle also knows. Aliases. lib.misc.maybeAttr.",
    "sub_results": []
  },
  {
    "url": "/f/lib/makeOverridable.html",
    "content": "lib.makeOverridable. makeOverridable takes a function from attribute set to attribute set and injects override attribute which can be used to override arguments of the function. Please refer to documentation on <pkg>.overrideDerivation to learn about overrideDerivation and caveats related to its use. Example. nix-repl> x = {a, b}: { result = a + b; } nix-repl> y = lib.makeOverridable x { a = 1; b = 2; } nix-repl> y { override = «lambda»; overrideDerivation = «lambda»; result = 3; } nix-repl> y.override { a = 10; } { override = «lambda»; overrideDerivation = «lambda»; result = 12; } Type. makeOverridable :: (AttrSet -> a) -> AttrSet -> a Arguments. [f] Edit source. Noogle also knows. Aliases. lib.customisation.makeOverridable. pkgs.makeOverridable.",
    "word_count": 118,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.makeOverridable"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 41
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 98
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 108
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.makeOverridable. makeOverridable takes a function from attribute set to attribute set and injects override attribute which can be used to override arguments of the function. Please refer to documentation on &lt;pkg&gt;.overrideDerivation to learn about overrideDerivation and caveats related to its use. Example. nix-repl&gt; x = {a, b}: { result = a + b; } nix-repl&gt; y = lib.makeOverridable x { a = 1; b = 2; } nix-repl&gt; y { override = «lambda»; overrideDerivation = «lambda»; result = 3; } nix-repl&gt; y.override { a = 10; } { override = «lambda»; overrideDerivation = «lambda»; result = 12; } Type. makeOverridable :: (AttrSet -&gt; a) -&gt; AttrSet -&gt; a Arguments. [f] Edit source. Noogle also knows. Aliases. lib.customisation.makeOverridable. pkgs.makeOverridable.",
    "raw_url": "/f/lib/makeOverridable.html",
    "excerpt": "lib.makeOverridable. makeOverridable takes a function from attribute set to attribute set and injects override attribute which can be used to override arguments of the function. Please refer to documentation on",
    "sub_results": []
  },
  {
    "url": "/f/lib/showWarnings.html",
    "content": "lib.showWarnings. Edit source. Noogle also knows. Aliases. lib.trivial.showWarnings.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.showWarnings"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.showWarnings. Edit source. Noogle also knows. Aliases. lib.trivial.showWarnings.",
    "raw_url": "/f/lib/showWarnings.html",
    "excerpt": "lib.showWarnings. Edit source. Noogle also knows. Aliases. lib.trivial.showWarnings.",
    "sub_results": []
  },
  {
    "url": "/f/lib/versionAtLeast.html",
    "content": "lib.versionAtLeast. Return true if string v1 denotes a version equal to or newer than v2. Example. versionAtLeast \"1.1\" \"1.0\" => true versionAtLeast \"1.1\" \"1.1\" => true versionAtLeast \"1.1\" \"1.2\" => false Arguments. [v1] [v2] Edit source. Noogle also knows. Aliases. lib.strings.versionAtLeast.",
    "word_count": 41,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.versionAtLeast"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 31
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.versionAtLeast. Return true if string v1 denotes a version equal to or newer than v2. Example. versionAtLeast \"1.1\" \"1.0\" =&gt; true versionAtLeast \"1.1\" \"1.1\" =&gt; true versionAtLeast \"1.1\" \"1.2\" =&gt; false Arguments. [v1] [v2] Edit source. Noogle also knows. Aliases. lib.strings.versionAtLeast.",
    "raw_url": "/f/lib/versionAtLeast.html",
    "excerpt": "lib.versionAtLeast. Return true if string v1 denotes a version equal to or newer than v2. Example. versionAtLeast \"1.1\" \"1.0\" =&gt; true versionAtLeast \"1.1\" \"1.1\" =&gt; true versionAtLeast \"1.1\" \"1.2\" =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/mapAttrs.html",
    "content": "lib.mapAttrs Primop. Takes 2 arguments. f, attrset. Apply a function to each element in an attribute set, creating a new attribute set. Example. mapAttrs (name: value: name + \"-\" + value) { x = \"foo\"; y = \"bar\"; } => { x = \"x-foo\"; y = \"y-bar\"; } Type. mapAttrs :: (String -> Any -> Any) -> AttrSet -> AttrSet Edit source. Noogle also knows. Aliases. builtins.mapAttrs. lib.attrsets.mapAttrs.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mapAttrs Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 22
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 48
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mapAttrs Primop. Takes 2 arguments. f, attrset. Apply a function to each element in an attribute set, creating a new attribute set. Example. mapAttrs (name: value: name + \"-\" + value) { x = \"foo\"; y = \"bar\"; } =&gt; { x = \"x-foo\"; y = \"y-bar\"; } Type. mapAttrs :: (String -&gt; Any -&gt; Any) -&gt; AttrSet -&gt; AttrSet Edit source. Noogle also knows. Aliases. builtins.mapAttrs. lib.attrsets.mapAttrs.",
    "raw_url": "/f/lib/mapAttrs.html",
    "excerpt": "lib.mapAttrs Primop. Takes 2 arguments. f, attrset. Apply a function to each element in an attribute set, creating a new attribute set. Example. mapAttrs (name: value: name + \"-\" +",
    "sub_results": []
  },
  {
    "url": "/f/lib/traceValSeqNFn.html",
    "content": "lib.traceValSeqNFn. A combination of traceVal and traceSeqN that applies a provided function to the value to be traced. Arguments. [f] Function to apply. [depth] [v] Value to trace. Edit source. Noogle also knows. Aliases. lib.debug.traceValSeqNFn.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.traceValSeqNFn"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 18
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.traceValSeqNFn. A combination of traceVal and traceSeqN that applies a provided function to the value to be traced. Arguments. [f] Function to apply. [depth] [v] Value to trace. Edit source. Noogle also knows. Aliases. lib.debug.traceValSeqNFn.",
    "raw_url": "/f/lib/traceValSeqNFn.html",
    "excerpt": "lib.traceValSeqNFn. A combination of traceVal and traceSeqN that applies a provided function to the value to be traced. Arguments. [f] Function to apply. [depth] [v] Value to trace. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mod.html",
    "content": "lib.mod. Integer modulus. Example. mod 11 10 => 1 mod 1 10 => 1 Arguments. [base] [int] Edit source. Noogle also knows. Aliases. lib.trivial.mod.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mod"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 3
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mod. Integer modulus. Example. mod 11 10 =&gt; 1 mod 1 10 =&gt; 1 Arguments. [base] [int] Edit source. Noogle also knows. Aliases. lib.trivial.mod.",
    "raw_url": "/f/lib/mod.html",
    "excerpt": "lib.mod. Integer modulus. Example. mod 11 10 =&gt; 1 mod 1 10 =&gt; 1 Arguments. [base] [int] Edit source. Noogle also knows. Aliases. lib.trivial.mod.",
    "sub_results": []
  },
  {
    "url": "/f/lib/cli/toGNUCommandLineShell.html",
    "content": "lib.cli.toGNUCommandLineShell. Automatically convert an attribute set to command-line options. This helps protect against malformed command lines and also to reduce boilerplate related to command-line construction for simple use cases. toGNUCommandLine returns a list of nix strings. toGNUCommandLineShell returns an escaped shell string. Example. cli.toGNUCommandLine {} { data = builtins.toJSON { id = 0; }; X = \"PUT\"; retry = 3; retry-delay = null; url = [ \"https://example.com/foo\" \"https://example.com/bar\" ]; silent = false; verbose = true; } => [ \"-X\" \"PUT\" \"--data\" \"{\\\"id\\\":0}\" \"--retry\" \"3\" \"--url\" \"https://example.com/foo\" \"--url\" \"https://example.com/bar\" \"--verbose\" ] cli.toGNUCommandLineShell {} { data = builtins.toJSON { id = 0; }; X = \"PUT\"; retry = 3; retry-delay = null; url = [ \"https://example.com/foo\" \"https://example.com/bar\" ]; silent = false; verbose = true; } => \"'-X' 'PUT' '--data' '{\\\"id\\\":0}' '--retry' '3' '--url' 'https://example.com/foo' '--url' 'https://example.com/bar' '--verbose'\"; Arguments. [options] [attrs] Edit source.",
    "word_count": 140,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.cli.toGNUCommandLineShell"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 42
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 135
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.cli.toGNUCommandLineShell. Automatically convert an attribute set to command-line options. This helps protect against malformed command lines and also to reduce boilerplate related to command-line construction for simple use cases. toGNUCommandLine returns a list of nix strings. toGNUCommandLineShell returns an escaped shell string. Example. cli.toGNUCommandLine {} { data = builtins.toJSON { id = 0; }; X = \"PUT\"; retry = 3; retry-delay = null; url = [ \"https://example.com/foo\" \"https://example.com/bar\" ]; silent = false; verbose = true; } =&gt; [ \"-X\" \"PUT\" \"--data\" \"{\\\"id\\\":0}\" \"--retry\" \"3\" \"--url\" \"https://example.com/foo\" \"--url\" \"https://example.com/bar\" \"--verbose\" ] cli.toGNUCommandLineShell {} { data = builtins.toJSON { id = 0; }; X = \"PUT\"; retry = 3; retry-delay = null; url = [ \"https://example.com/foo\" \"https://example.com/bar\" ]; silent = false; verbose = true; } =&gt; \"'-X' 'PUT' '--data' '{\\\"id\\\":0}' '--retry' '3' '--url' 'https://example.com/foo' '--url' 'https://example.com/bar' '--verbose'\"; Arguments. [options] [attrs] Edit source.",
    "raw_url": "/f/lib/cli/toGNUCommandLineShell.html",
    "excerpt": "lib.cli.toGNUCommandLineShell. Automatically convert an attribute set to command-line options. This helps protect against malformed command lines and also to reduce boilerplate related to command-line construction for simple use cases. toGNUCommandLine",
    "sub_results": []
  },
  {
    "url": "/f/lib/cli/toGNUCommandLine.html",
    "content": "lib.cli.toGNUCommandLine. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.cli.toGNUCommandLine"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.cli.toGNUCommandLine. Edit source.",
    "raw_url": "/f/lib/cli/toGNUCommandLine.html",
    "excerpt": "lib.cli.toGNUCommandLine. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkEnableOption.html",
    "content": "lib.mkEnableOption. Creates an Option attribute set for a boolean value option i.e an option to be toggled on or off: Example. mkEnableOption \"foo\" => { _type = \"option\"; default = false; description = \"Whether to enable foo.\"; example = true; type = { ... }; } Arguments. [name] Name for the created option. Edit source. Noogle also knows. Aliases. lib.options.mkEnableOption.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkEnableOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 46
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkEnableOption. Creates an Option attribute set for a boolean value option i.e an option to be toggled on or off: Example. mkEnableOption \"foo\" =&gt; { _type = \"option\"; default = false; description = \"Whether to enable foo.\"; example = true; type = { ... }; } Arguments. [name] Name for the created option. Edit source. Noogle also knows. Aliases. lib.options.mkEnableOption.",
    "raw_url": "/f/lib/mkEnableOption.html",
    "excerpt": "lib.mkEnableOption. Creates an Option attribute set for a boolean value option i.e an option to be toggled on or off: Example. mkEnableOption \"foo\" =&gt; { _type = \"option\"; default =",
    "sub_results": []
  },
  {
    "url": "/f/lib/filterAttrs.html",
    "content": "lib.filterAttrs. Filter an attribute set by removing all attributes for which the given predicate return false. Example. filterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; } => { foo = 1; } Type. filterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet Arguments. [pred] Predicate taking an attribute name and an attribute value, which returns true to include the attribute, or false to exclude the attribute. [set] The attribute set to filter. Edit source. Noogle also knows. Aliases. lib.attrsets.filterAttrs.",
    "word_count": 86,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.filterAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 37
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 49
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.filterAttrs. Filter an attribute set by removing all attributes for which the given predicate return false. Example. filterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; } =&gt; { foo = 1; } Type. filterAttrs :: (String -&gt; Any -&gt; Bool) -&gt; AttrSet -&gt; AttrSet Arguments. [pred] Predicate taking an attribute name and an attribute value, which returns true to include the attribute, or false to exclude the attribute. [set] The attribute set to filter. Edit source. Noogle also knows. Aliases. lib.attrsets.filterAttrs.",
    "raw_url": "/f/lib/filterAttrs.html",
    "excerpt": "lib.filterAttrs. Filter an attribute set by removing all attributes for which the given predicate return false. Example. filterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2;",
    "sub_results": []
  },
  {
    "url": "/f/lib/fixedWidthNumber.html",
    "content": "lib.fixedWidthNumber. Format a number adding leading zeroes up to fixed width. Example. fixedWidthNumber 5 15 => \"00015\" Arguments. [width] [n] Edit source. Noogle also knows. Aliases. lib.strings.fixedWidthNumber.",
    "word_count": 27,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fixedWidthNumber"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 17
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fixedWidthNumber. Format a number adding leading zeroes up to fixed width. Example. fixedWidthNumber 5 15 =&gt; \"00015\" Arguments. [width] [n] Edit source. Noogle also knows. Aliases. lib.strings.fixedWidthNumber.",
    "raw_url": "/f/lib/fixedWidthNumber.html",
    "excerpt": "lib.fixedWidthNumber. Format a number adding leading zeroes up to fixed width. Example. fixedWidthNumber 5 15 =&gt; \"00015\" Arguments. [width] [n] Edit source. Noogle also knows. Aliases. lib.strings.fixedWidthNumber.",
    "sub_results": []
  },
  {
    "url": "/f/lib/showAttrPath.html",
    "content": "lib.showAttrPath. Turns a list of strings into a human-readable description of those strings represented as an attribute path. The result of this function is not intended to be machine-readable. Create a new attribute set with value set at the nested attribute location specified in attrPath. Example. showAttrPath [ \"foo\" \"10\" \"bar\" ] => \"foo.\\\"10\\\".bar\" showAttrPath [] => \"<root attribute path>\" Type. showAttrPath :: [String] -> String Arguments. [path] Attribute path to render to a string. Edit source. Noogle also knows. Aliases. lib.attrsets.showAttrPath.",
    "word_count": 82,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.showAttrPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 45
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 60
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 66
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.showAttrPath. Turns a list of strings into a human-readable description of those strings represented as an attribute path. The result of this function is not intended to be machine-readable. Create a new attribute set with value set at the nested attribute location specified in attrPath. Example. showAttrPath [ \"foo\" \"10\" \"bar\" ] =&gt; \"foo.\\\"10\\\".bar\" showAttrPath [] =&gt; \"&lt;root attribute path&gt;\" Type. showAttrPath :: [String] -&gt; String Arguments. [path] Attribute path to render to a string. Edit source. Noogle also knows. Aliases. lib.attrsets.showAttrPath.",
    "raw_url": "/f/lib/showAttrPath.html",
    "excerpt": "lib.showAttrPath. Turns a list of strings into a human-readable description of those strings represented as an attribute path. The result of this function is not intended to be machine-readable. Create",
    "sub_results": []
  },
  {
    "url": "/f/lib/getValue.html",
    "content": "lib.getValue. Edit source. Noogle also knows. Aliases. lib.misc.getValue.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getValue"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getValue. Edit source. Noogle also knows. Aliases. lib.misc.getValue.",
    "raw_url": "/f/lib/getValue.html",
    "excerpt": "lib.getValue. Edit source. Noogle also knows. Aliases. lib.misc.getValue.",
    "sub_results": []
  },
  {
    "url": "/f/lib/__unfix__.html",
    "content": "lib.__unfix__. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.__unfix__"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.__unfix__. Edit source.",
    "raw_url": "/f/lib/__unfix__.html",
    "excerpt": "lib.__unfix__. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrNames.html",
    "content": "lib.attrNames Primop. Takes 1 arguments. set. Return the names of the attributes in the set set in an alphabetically sorted list. For instance, builtins.attrNames { y = 1; x = \"foo\"; } evaluates to [ \"x\" \"y\" ]. Noogle also knows. Aliases. builtins.attrNames. lib.attrsets.attrNames.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrNames Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrNames Primop. Takes 1 arguments. set. Return the names of the attributes in the set set in an alphabetically sorted list. For instance, builtins.attrNames { y = 1; x = \"foo\"; } evaluates to [ \"x\" \"y\" ]. Noogle also knows. Aliases. builtins.attrNames. lib.attrsets.attrNames.",
    "raw_url": "/f/lib/attrNames.html",
    "excerpt": "lib.attrNames Primop. Takes 1 arguments. set. Return the names of the attributes in the set set in an alphabetically sorted list. For instance, builtins.attrNames { y = 1; x =",
    "sub_results": []
  },
  {
    "url": "/f/lib/commitIdFromGitRepo.html",
    "content": "lib.commitIdFromGitRepo. Get the commit id of a git repo. Example. commitIdFromGitRepo <nixpkgs/.git> Arguments. [path] Edit source. Noogle also knows. Aliases. lib.sources.commitIdFromGitRepo.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.commitIdFromGitRepo"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.commitIdFromGitRepo. Get the commit id of a git repo. Example. commitIdFromGitRepo &lt;nixpkgs/.git&gt; Arguments. [path] Edit source. Noogle also knows. Aliases. lib.sources.commitIdFromGitRepo.",
    "raw_url": "/f/lib/commitIdFromGitRepo.html",
    "excerpt": "lib.commitIdFromGitRepo. Get the commit id of a git repo. Example. commitIdFromGitRepo &lt;nixpkgs/.git&gt; Arguments. [path] Edit source. Noogle also knows. Aliases. lib.sources.commitIdFromGitRepo.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkBefore.html",
    "content": "lib.mkBefore. Noogle also knows. Aliases. lib.modules.mkBefore.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkBefore"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkBefore. Noogle also knows. Aliases. lib.modules.mkBefore.",
    "raw_url": "/f/lib/mkBefore.html",
    "excerpt": "lib.mkBefore. Noogle also knows. Aliases. lib.modules.mkBefore.",
    "sub_results": []
  },
  {
    "url": "/f/lib/max.html",
    "content": "lib.max. Return maximum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.max.",
    "word_count": 16,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.max"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 6
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.max. Return maximum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.max.",
    "raw_url": "/f/lib/max.html",
    "excerpt": "lib.max. Return maximum of two numbers. Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.max.",
    "sub_results": []
  },
  {
    "url": "/f/lib/updateName.html",
    "content": "lib.updateName. Like setName, but takes the previous name as an argument. Example. updateName (oldName: oldName + \"-experimental\") somePkg Arguments. [updater] [drv] Edit source. Noogle also knows. Aliases. lib.meta.updateName.",
    "word_count": 28,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.updateName"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 18
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.updateName. Like setName, but takes the previous name as an argument. Example. updateName (oldName: oldName + \"-experimental\") somePkg Arguments. [updater] [drv] Edit source. Noogle also knows. Aliases. lib.meta.updateName.",
    "raw_url": "/f/lib/updateName.html",
    "excerpt": "lib.updateName. Like setName, but takes the previous name as an argument. Example. updateName (oldName: oldName + \"-experimental\") somePkg Arguments. [updater] [drv] Edit source. Noogle also knows. Aliases. lib.meta.updateName.",
    "sub_results": []
  },
  {
    "url": "/f/lib/getBin.html",
    "content": "lib.getBin. Get a package's bin output. If the output does not exist, fallback to .out and then to the default. Example. getBin pkgs.openssl => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r\" Type. getBin :: Derivation -> String Edit source. Noogle also knows. Aliases. lib.attrsets.getBin.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getBin"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getBin. Get a package's bin output. If the output does not exist, fallback to .out and then to the default. Example. getBin pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r\" Type. getBin :: Derivation -&gt; String Edit source. Noogle also knows. Aliases. lib.attrsets.getBin.",
    "raw_url": "/f/lib/getBin.html",
    "excerpt": "lib.getBin. Get a package's bin output. If the output does not exist, fallback to .out and then to the default. Example. getBin pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r\" Type. getBin :: Derivation -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/boolToString.html",
    "content": "lib.boolToString. Convert a boolean to a string. This function uses the strings \"true\" and \"false\" to represent boolean values. Calling toString on a bool instead returns \"1\" and \"\" (sic!). Type. boolToString :: bool -> string Arguments. [b] Edit source. Noogle also knows. Aliases. lib.trivial.boolToString.",
    "word_count": 45,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.boolToString"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 30
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 36
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.boolToString. Convert a boolean to a string. This function uses the strings \"true\" and \"false\" to represent boolean values. Calling toString on a bool instead returns \"1\" and \"\" (sic!). Type. boolToString :: bool -&gt; string Arguments. [b] Edit source. Noogle also knows. Aliases. lib.trivial.boolToString.",
    "raw_url": "/f/lib/boolToString.html",
    "excerpt": "lib.boolToString. Convert a boolean to a string. This function uses the strings \"true\" and \"false\" to represent boolean values. Calling toString on a bool instead returns \"1\" and \"\" (sic!).",
    "sub_results": []
  },
  {
    "url": "/f/lib/imap.html",
    "content": "lib.imap. deprecated: For historical reasons, imap has an index starting at 1. But for consistency with the rest of the library we want an index starting at zero. Edit source. Noogle also knows. Aliases. lib.misc.imap.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.imap"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.imap. deprecated: For historical reasons, imap has an index starting at 1. But for consistency with the rest of the library we want an index starting at zero. Edit source. Noogle also knows. Aliases. lib.misc.imap.",
    "raw_url": "/f/lib/imap.html",
    "excerpt": "lib.imap. deprecated: For historical reasons, imap has an index starting at 1. But for consistency with the rest of the library we want an index starting at zero. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/findSingle.html",
    "content": "lib.findSingle. Find the sole element in the list matching the specified predicate, returns default if no such element exists, or multiple if there are multiple matching elements. Example. findSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ] => \"multiple\" findSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ] => 3 findSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ] => \"none\" Type. findSingle :: (a -> bool) -> a -> a -> [a] -> a Arguments. [pred] Predicate. [default] Default value to return if element was not found. [multiple] Default value to return if more than one element was found. [list] Input list. Edit source. Noogle also knows. Aliases. lib.lists.findSingle.",
    "word_count": 117,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.findSingle"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 27
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 68
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 82
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.findSingle. Find the sole element in the list matching the specified predicate, returns default if no such element exists, or multiple if there are multiple matching elements. Example. findSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 3 ] =&gt; \"multiple\" findSingle (x: x == 3) \"none\" \"multiple\" [ 1 3 ] =&gt; 3 findSingle (x: x == 3) \"none\" \"multiple\" [ 1 9 ] =&gt; \"none\" Type. findSingle :: (a -&gt; bool) -&gt; a -&gt; a -&gt; [a] -&gt; a Arguments. [pred] Predicate. [default] Default value to return if element was not found. [multiple] Default value to return if more than one element was found. [list] Input list. Edit source. Noogle also knows. Aliases. lib.lists.findSingle.",
    "raw_url": "/f/lib/findSingle.html",
    "excerpt": "lib.findSingle. Find the sole element in the list matching the specified predicate, returns default if no such element exists, or multiple if there are multiple matching elements. Example. findSingle (x:",
    "sub_results": []
  },
  {
    "url": "/f/lib/maybeEnv.html",
    "content": "lib.maybeEnv. Edit source. Noogle also knows. Aliases. lib.misc.maybeEnv.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.maybeEnv"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.maybeEnv. Edit source. Noogle also knows. Aliases. lib.misc.maybeEnv.",
    "raw_url": "/f/lib/maybeEnv.html",
    "excerpt": "lib.maybeEnv. Edit source. Noogle also knows. Aliases. lib.misc.maybeEnv.",
    "sub_results": []
  },
  {
    "url": "/f/lib/toLower.html",
    "content": "lib.toLower. Converts an ASCII string to lower-case. Example. toLower \"HOME\" => \"home\" Type. toLower :: string -> string Edit source. Noogle also knows. Aliases. lib.strings.toLower.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toLower"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 7
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toLower. Converts an ASCII string to lower-case. Example. toLower \"HOME\" =&gt; \"home\" Type. toLower :: string -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.toLower.",
    "raw_url": "/f/lib/toLower.html",
    "excerpt": "lib.toLower. Converts an ASCII string to lower-case. Example. toLower \"HOME\" =&gt; \"home\" Type. toLower :: string -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.toLower.",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/optionalAttrs.html",
    "content": "lib.attrsets.optionalAttrs. If cond is true, return the attribute set as, otherwise an empty attribute set. Example. optionalAttrs (true) { my = \"set\"; } => { my = \"set\"; } optionalAttrs (false) { my = \"set\"; } => { } Type. optionalAttrs :: Bool -> AttrSet -> AttrSet Arguments. [cond] Condition under which the as attribute set is returned. [as] The attribute set to return if cond is true. Edit source. Noogle also knows. Aliases. lib.optionalAttrs.",
    "word_count": 75,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.optionalAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 39
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 47
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.optionalAttrs. If cond is true, return the attribute set as, otherwise an empty attribute set. Example. optionalAttrs (true) { my = \"set\"; } =&gt; { my = \"set\"; } optionalAttrs (false) { my = \"set\"; } =&gt; { } Type. optionalAttrs :: Bool -&gt; AttrSet -&gt; AttrSet Arguments. [cond] Condition under which the as attribute set is returned. [as] The attribute set to return if cond is true. Edit source. Noogle also knows. Aliases. lib.optionalAttrs.",
    "raw_url": "/f/lib/attrsets/optionalAttrs.html",
    "excerpt": "lib.attrsets.optionalAttrs. If cond is true, return the attribute set as, otherwise an empty attribute set. Example. optionalAttrs (true) { my = \"set\"; } =&gt; { my = \"set\"; } optionalAttrs",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/listToAttrs.html",
    "content": "lib.attrsets.listToAttrs Primop. Takes 1 arguments. e. Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting of a string-valued attribute name specifying the name of the attribute, and an attribute value specifying its value. In case of duplicate occurrences of the same name, the first takes precedence. Example: builtins.listToAttrs [ { name = \"foo\"; value = 123; } { name = \"bar\"; value = 456; } { name = \"bar\"; value = 420; } ] evaluates to. { foo = 123; bar = 456; } Noogle also knows. Aliases. builtins.listToAttrs. lib.listToAttrs.",
    "word_count": 105,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.listToAttrs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.listToAttrs Primop. Takes 1 arguments. e. Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting of a string-valued attribute name specifying the name of the attribute, and an attribute value specifying its value. In case of duplicate occurrences of the same name, the first takes precedence. Example: builtins.listToAttrs [ { name = \"foo\"; value = 123; } { name = \"bar\"; value = 456; } { name = \"bar\"; value = 420; } ] evaluates to. { foo = 123; bar = 456; } Noogle also knows. Aliases. builtins.listToAttrs. lib.listToAttrs.",
    "raw_url": "/f/lib/attrsets/listToAttrs.html",
    "excerpt": "lib.attrsets.listToAttrs Primop. Takes 1 arguments. e. Construct a set from a list specifying the names and values of each attribute. Each element of the list should be a set consisting",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/getMan.html",
    "content": "lib.attrsets.getMan. Get a package's man output. If the output does not exist, fallback to .out and then to the default. Example. getMan pkgs.openssl => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-man\" Type. getMan :: Derivation -> String Edit source. Noogle also knows. Aliases. lib.getMan.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.getMan"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.getMan. Get a package's man output. If the output does not exist, fallback to .out and then to the default. Example. getMan pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-man\" Type. getMan :: Derivation -&gt; String Edit source. Noogle also knows. Aliases. lib.getMan.",
    "raw_url": "/f/lib/attrsets/getMan.html",
    "excerpt": "lib.attrsets.getMan. Get a package's man output. If the output does not exist, fallback to .out and then to the default. Example. getMan pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-man\" Type. getMan :: Derivation -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/getLib.html",
    "content": "lib.attrsets.getLib. Get a package's lib output. If the output does not exist, fallback to .out and then to the default. Example. getLib pkgs.openssl => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-lib\" Type. getLib :: Derivation -> String Edit source. Noogle also knows. Aliases. lib.getLib.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.getLib"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.getLib. Get a package's lib output. If the output does not exist, fallback to .out and then to the default. Example. getLib pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-lib\" Type. getLib :: Derivation -&gt; String Edit source. Noogle also knows. Aliases. lib.getLib.",
    "raw_url": "/f/lib/attrsets/getLib.html",
    "excerpt": "lib.attrsets.getLib. Get a package's lib output. If the output does not exist, fallback to .out and then to the default. Example. getLib pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-lib\" Type. getLib :: Derivation -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/removeAttrs.html",
    "content": "lib.attrsets.removeAttrs Primop. Takes 2 arguments. set, list. Remove the attributes listed in list from set. The attributes don’t have to exist in set. For instance, removeAttrs { x = 1; y = 2; z = 3; } [ \"a\" \"x\" \"z\" ] evaluates to { y = 2; }. Noogle also knows. Aliases. builtins.removeAttrs.",
    "word_count": 54,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.removeAttrs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.removeAttrs Primop. Takes 2 arguments. set, list. Remove the attributes listed in list from set. The attributes don’t have to exist in set. For instance, removeAttrs { x = 1; y = 2; z = 3; } [ \"a\" \"x\" \"z\" ] evaluates to { y = 2; }. Noogle also knows. Aliases. builtins.removeAttrs.",
    "raw_url": "/f/lib/attrsets/removeAttrs.html",
    "excerpt": "lib.attrsets.removeAttrs Primop. Takes 2 arguments. set, list. Remove the attributes listed in list from set. The attributes don’t have to exist in set. For instance, removeAttrs { x = 1;",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/zipAttrs.html",
    "content": "lib.attrsets.zipAttrs. Merge sets of attributes and combine each attribute value in to a list. Like lib.attrsets.zipAttrsWith with (name: values: values) as the function. Example. zipAttrs [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrs :: [ AttrSet ] -> AttrSet Arguments. [sets] List of attribute sets to zip together. Edit source. Noogle also knows. Aliases. lib.zipAttrs.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.zipAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 44
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 52
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.zipAttrs. Merge sets of attributes and combine each attribute value in to a list. Like lib.attrsets.zipAttrsWith with (name: values: values) as the function. Example. zipAttrs [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrs :: [ AttrSet ] -&gt; AttrSet Arguments. [sets] List of attribute sets to zip together. Edit source. Noogle also knows. Aliases. lib.zipAttrs.",
    "raw_url": "/f/lib/attrsets/zipAttrs.html",
    "excerpt": "lib.attrsets.zipAttrs. Merge sets of attributes and combine each attribute value in to a list. Like lib.attrsets.zipAttrsWith with (name: values: values) as the function. Example. zipAttrs [{a = \"x\";} {a =",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/mapAttrs'.html",
    "content": "lib.attrsets.mapAttrs' (Prime). Like mapAttrs, but allows the name of each attribute to be changed in addition to the value. The applied function should return both the new name and value as a nameValuePair. Example. mapAttrs' (name: value: nameValuePair (\"foo_\" + name) (\"bar-\" + value)) { x = \"a\"; y = \"b\"; } => { foo_x = \"bar-a\"; foo_y = \"bar-b\"; } Type. mapAttrs' :: (String -> Any -> { name :: String; value :: Any; }) -> AttrSet -> AttrSet Arguments. [f] A function, given an attribute's name and value, returns a new nameValuePair. [set] Attribute set to map over. Edit source. Noogle also knows. Aliases. lib.mapAttrs'",
    "word_count": 107,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.mapAttrs' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 33
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 61
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 80
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.mapAttrs' (Prime). Like mapAttrs, but allows the name of each attribute to be changed in addition to the value. The applied function should return both the new name and value as a nameValuePair. Example. mapAttrs' (name: value: nameValuePair (\"foo_\" + name) (\"bar-\" + value)) { x = \"a\"; y = \"b\"; } =&gt; { foo_x = \"bar-a\"; foo_y = \"bar-b\"; } Type. mapAttrs' :: (String -&gt; Any -&gt; { name :: String; value :: Any; }) -&gt; AttrSet -&gt; AttrSet Arguments. [f] A function, given an attribute's name and value, returns a new nameValuePair. [set] Attribute set to map over. Edit source. Noogle also knows. Aliases. lib.mapAttrs'",
    "raw_url": "/f/lib/attrsets/mapAttrs'.html",
    "excerpt": "lib.attrsets.mapAttrs' (Prime). Like mapAttrs, but allows the name of each attribute to be changed in addition to the value. The applied function should return both the new name and value",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/zipAttrsWith.html",
    "content": "lib.attrsets.zipAttrsWith Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names. Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names. Example. zipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet Edit source. Noogle also knows. Aliases. builtins.zipAttrsWith. lib.zip. lib.zipAttrsWith. lib.attrsets.zip.",
    "word_count": 118,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.zipAttrsWith Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 68
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 92
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.zipAttrsWith Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names. Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names. Example. zipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrsWith :: (String -&gt; [ Any ] -&gt; Any) -&gt; [ AttrSet ] -&gt; AttrSet Edit source. Noogle also knows. Aliases. builtins.zipAttrsWith. lib.zip. lib.zipAttrsWith. lib.attrsets.zip.",
    "raw_url": "/f/lib/attrsets/zipAttrsWith.html",
    "excerpt": "lib.attrsets.zipAttrsWith Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names.",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/mapAttrsToList.html",
    "content": "lib.attrsets.mapAttrsToList. Call a function for each attribute in the given set and return the result in a list. Example. mapAttrsToList (name: value: name + value) { x = \"a\"; y = \"b\"; } => [ \"xa\" \"yb\" ] Type. mapAttrsToList :: (String -> a -> b) -> AttrSet -> [b] Arguments. [f] A function, given an attribute's name and value, returns a new value. [attrs] Attribute set to map over. Edit source. Noogle also knows. Aliases. lib.mapAttrsToList.",
    "word_count": 77,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.mapAttrsToList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 38
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.mapAttrsToList. Call a function for each attribute in the given set and return the result in a list. Example. mapAttrsToList (name: value: name + value) { x = \"a\"; y = \"b\"; } =&gt; [ \"xa\" \"yb\" ] Type. mapAttrsToList :: (String -&gt; a -&gt; b) -&gt; AttrSet -&gt; [b] Arguments. [f] A function, given an attribute's name and value, returns a new value. [attrs] Attribute set to map over. Edit source. Noogle also knows. Aliases. lib.mapAttrsToList.",
    "raw_url": "/f/lib/attrsets/mapAttrsToList.html",
    "excerpt": "lib.attrsets.mapAttrsToList. Call a function for each attribute in the given set and return the result in a list. Example. mapAttrsToList (name: value: name + value) { x = \"a\"; y",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/zipWithNames.html",
    "content": "lib.attrsets.zipWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; } Type. zipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet Arguments. [names] List of attribute names to zip. [f] A function, accepts an attribute name, all the values, and returns a combined value. [sets] List of values from the list of attribute sets. Edit source. Noogle also knows. Aliases. lib.zipWithNames.",
    "word_count": 96,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.zipWithNames"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 36
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 56
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.zipWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; } Type. zipAttrsWithNames :: [ String ] -&gt; (String -&gt; [ Any ] -&gt; Any) -&gt; [ AttrSet ] -&gt; AttrSet Arguments. [names] List of attribute names to zip. [f] A function, accepts an attribute name, all the values, and returns a combined value. [sets] List of values from the list of attribute sets. Edit source. Noogle also knows. Aliases. lib.zipWithNames.",
    "raw_url": "/f/lib/attrsets/zipWithNames.html",
    "excerpt": "lib.attrsets.zipWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/mapAttrsRecursive.html",
    "content": "lib.attrsets.mapAttrsRecursive. Like mapAttrs, except that it recursively applies itself to the leaf attributes of a potentially-nested attribute set: the second argument of the function will never be an attrset. Also, the first argument of the argument function is a list of the attribute names that form the path to the leaf attribute. For a function that gives you control over what counts as a leaf, see mapAttrsRecursiveCond. Example. mapAttrsRecursive (path: value: concatStringsSep \"-\" (path ++ [value])) { n = { a = \"A\"; m = { b = \"B\"; c = \"C\"; }; }; d = \"D\"; } => { n = { a = \"n-a-A\"; m = { b = \"n-m-b-B\"; c = \"n-m-c-C\"; }; }; d = \"d-D\"; } Type. mapAttrsRecursive :: ([String] -> a -> b) -> AttrSet -> AttrSet Arguments. [f] A function, given a list of attribute names and a value, returns a new value. [set] Set to recursively map over. Edit source. Noogle also knows. Aliases. lib.mapAttrsRecursive.",
    "word_count": 163,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.mapAttrsRecursive"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 67
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 121
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 133
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.mapAttrsRecursive. Like mapAttrs, except that it recursively applies itself to the leaf attributes of a potentially-nested attribute set: the second argument of the function will never be an attrset. Also, the first argument of the argument function is a list of the attribute names that form the path to the leaf attribute. For a function that gives you control over what counts as a leaf, see mapAttrsRecursiveCond. Example. mapAttrsRecursive (path: value: concatStringsSep \"-\" (path ++ [value])) { n = { a = \"A\"; m = { b = \"B\"; c = \"C\"; }; }; d = \"D\"; } =&gt; { n = { a = \"n-a-A\"; m = { b = \"n-m-b-B\"; c = \"n-m-c-C\"; }; }; d = \"d-D\"; } Type. mapAttrsRecursive :: ([String] -&gt; a -&gt; b) -&gt; AttrSet -&gt; AttrSet Arguments. [f] A function, given a list of attribute names and a value, returns a new value. [set] Set to recursively map over. Edit source. Noogle also knows. Aliases. lib.mapAttrsRecursive.",
    "raw_url": "/f/lib/attrsets/mapAttrsRecursive.html",
    "excerpt": "lib.attrsets.mapAttrsRecursive. Like mapAttrs, except that it recursively applies itself to the leaf attributes of a potentially-nested attribute set: the second argument of the function will never be an attrset. Also,",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/chooseDevOutputs.html",
    "content": "lib.attrsets.chooseDevOutputs. Pick the outputs of packages to place in buildInputs. Type. chooseDevOutputs :: [Derivation] -> [String] Arguments. [drvs] List of packages to pick dev outputs from. Edit source. Noogle also knows. Aliases. lib.chooseDevOutputs.",
    "word_count": 33,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.chooseDevOutputs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 10
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 16
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.chooseDevOutputs. Pick the outputs of packages to place in buildInputs. Type. chooseDevOutputs :: [Derivation] -&gt; [String] Arguments. [drvs] List of packages to pick dev outputs from. Edit source. Noogle also knows. Aliases. lib.chooseDevOutputs.",
    "raw_url": "/f/lib/attrsets/chooseDevOutputs.html",
    "excerpt": "lib.attrsets.chooseDevOutputs. Pick the outputs of packages to place in buildInputs. Type. chooseDevOutputs :: [Derivation] -&gt; [String] Arguments. [drvs] List of packages to pick dev outputs from. Edit source. Noogle also",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/hasAttr.html",
    "content": "lib.attrsets.hasAttr Primop. Takes 2 arguments. s, set. hasAttr returns true if set has an attribute named s, and false otherwise. This is a dynamic version of the ? operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. builtins.hasAttr. lib.hasAttr.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.hasAttr Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.hasAttr Primop. Takes 2 arguments. s, set. hasAttr returns true if set has an attribute named s, and false otherwise. This is a dynamic version of the ? operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. builtins.hasAttr. lib.hasAttr.",
    "raw_url": "/f/lib/attrsets/hasAttr.html",
    "excerpt": "lib.attrsets.hasAttr Primop. Takes 2 arguments. s, set. hasAttr returns true if set has an attribute named s, and false otherwise. This is a dynamic version of the ? operator, since",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/mergeAttrsList.html",
    "content": "lib.attrsets.mergeAttrsList. Merge a list of attribute sets together using the // operator. In case of duplicate attributes, values from later list elements take precedence over earlier ones. The result is the same as foldl mergeAttrs { }, but the performance is better for large inputs. For n list elements, each with an attribute set containing m unique attributes, the complexity of this operation is O(nm log n). Example. mergeAttrsList [ { a = 0; b = 1; } { c = 2; d = 3; } ] => { a = 0; b = 1; c = 2; d = 3; } mergeAttrsList [ { a = 0; } { a = 1; } ] => { a = 1; } Type. mergeAttrsList :: [ Attrs ] -> Attrs Arguments. [list] Edit source.",
    "word_count": 133,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.mergeAttrsList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 67
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 121
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 129
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.mergeAttrsList. Merge a list of attribute sets together using the // operator. In case of duplicate attributes, values from later list elements take precedence over earlier ones. The result is the same as foldl mergeAttrs { }, but the performance is better for large inputs. For n list elements, each with an attribute set containing m unique attributes, the complexity of this operation is O(nm log n). Example. mergeAttrsList [ { a = 0; b = 1; } { c = 2; d = 3; } ] =&gt; { a = 0; b = 1; c = 2; d = 3; } mergeAttrsList [ { a = 0; } { a = 1; } ] =&gt; { a = 1; } Type. mergeAttrsList :: [ Attrs ] -&gt; Attrs Arguments. [list] Edit source.",
    "raw_url": "/f/lib/attrsets/mergeAttrsList.html",
    "excerpt": "lib.attrsets.mergeAttrsList. Merge a list of attribute sets together using the // operator. In case of duplicate attributes, values from later list elements take precedence over earlier ones. The result is",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/concatMapAttrs.html",
    "content": "lib.attrsets.concatMapAttrs. Map each attribute in the given set and merge them into a new attribute set. Example. concatMapAttrs (name: value: { ${name} = value; ${name + value} = value; }) { x = \"a\"; y = \"b\"; } => { x = \"a\"; xa = \"a\"; y = \"b\"; yb = \"b\"; } Type. concatMapAttrs :: (String -> a -> AttrSet) -> AttrSet -> AttrSet Arguments. [f] [v] Edit source. Noogle also knows. Aliases. lib.concatMapAttrs.",
    "word_count": 75,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.concatMapAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 53
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 65
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.concatMapAttrs. Map each attribute in the given set and merge them into a new attribute set. Example. concatMapAttrs (name: value: { ${name} = value; ${name + value} = value; }) { x = \"a\"; y = \"b\"; } =&gt; { x = \"a\"; xa = \"a\"; y = \"b\"; yb = \"b\"; } Type. concatMapAttrs :: (String -&gt; a -&gt; AttrSet) -&gt; AttrSet -&gt; AttrSet Arguments. [f] [v] Edit source. Noogle also knows. Aliases. lib.concatMapAttrs.",
    "raw_url": "/f/lib/attrsets/concatMapAttrs.html",
    "excerpt": "lib.attrsets.concatMapAttrs. Map each attribute in the given set and merge them into a new attribute set. Example. concatMapAttrs (name: value: { ${name} = value; ${name + value} = value; })",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/recursiveUpdateUntil.html",
    "content": "lib.attrsets.recursiveUpdateUntil. Does the same as the update operator '//' except that attributes are merged until the given predicate is verified. The predicate should accept 3 arguments which are the path to reach the attribute, a part of the first attribute set and a part of the second attribute set. When the predicate is satisfied, the value of the first attribute set is replaced by the value of the second attribute set. Example. recursiveUpdateUntil (path: l: r: path == [\"foo\"]) { # first attribute set foo.bar = 1; foo.baz = 2; bar = 3; } { #second attribute set foo.bar = 1; foo.quz = 2; baz = 4; } => { foo.bar = 1; # 'foo.*' from the second set foo.quz = 2; # bar = 3; # 'bar' from the first set baz = 4; # 'baz' from the second set } Type. recursiveUpdateUntil :: ( [ String ] -> AttrSet -> AttrSet -> Bool ) -> AttrSet -> AttrSet -> AttrSet Arguments. [pred] Predicate, taking the path to the current attribute as a list of strings for attribute names, and the two values at that path from the original arguments. [lhs] Left attribute set of the merge. [rhs] Right attribute set of the merge. Edit source. Noogle also knows. Aliases. lib.recursiveUpdateUntil.",
    "word_count": 212,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.recursiveUpdateUntil"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 71
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 142
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 162
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.recursiveUpdateUntil. Does the same as the update operator '//' except that attributes are merged until the given predicate is verified. The predicate should accept 3 arguments which are the path to reach the attribute, a part of the first attribute set and a part of the second attribute set. When the predicate is satisfied, the value of the first attribute set is replaced by the value of the second attribute set. Example. recursiveUpdateUntil (path: l: r: path == [\"foo\"]) { # first attribute set foo.bar = 1; foo.baz = 2; bar = 3; } { #second attribute set foo.bar = 1; foo.quz = 2; baz = 4; } =&gt; { foo.bar = 1; # 'foo.*' from the second set foo.quz = 2; # bar = 3; # 'bar' from the first set baz = 4; # 'baz' from the second set } Type. recursiveUpdateUntil :: ( [ String ] -&gt; AttrSet -&gt; AttrSet -&gt; Bool ) -&gt; AttrSet -&gt; AttrSet -&gt; AttrSet Arguments. [pred] Predicate, taking the path to the current attribute as a list of strings for attribute names, and the two values at that path from the original arguments. [lhs] Left attribute set of the merge. [rhs] Right attribute set of the merge. Edit source. Noogle also knows. Aliases. lib.recursiveUpdateUntil.",
    "raw_url": "/f/lib/attrsets/recursiveUpdateUntil.html",
    "excerpt": "lib.attrsets.recursiveUpdateUntil. Does the same as the update operator '//' except that attributes are merged until the given predicate is verified. The predicate should accept 3 arguments which are the path",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/mapAttrsRecursiveCond.html",
    "content": "lib.attrsets.mapAttrsRecursiveCond. Like mapAttrsRecursive, but it takes an additional predicate function that tells it whether to recurse into an attribute set. If it returns false, mapAttrsRecursiveCond does not recurse, but does apply the map function. If it returns true, it does recurse, and does not apply the map function. Example. # To prevent recursing into derivations (which are attribute # sets with the attribute \"type\" equal to \"derivation\"): mapAttrsRecursiveCond (as: !(as ? \"type\" && as.type == \"derivation\")) (x: ... do something ...) attrs Type. mapAttrsRecursiveCond :: (AttrSet -> Bool) -> ([String] -> a -> b) -> AttrSet -> AttrSet Arguments. [cond] A function, given the attribute set the recursion is currently at, determine if to recurse deeper into that attribute set. [f] A function, given a list of attribute names and a value, returns a new value. [set] Attribute set to recursively map over. Edit source. Noogle also knows. Aliases. lib.mapAttrsRecursiveCond.",
    "word_count": 150,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.mapAttrsRecursiveCond"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 48
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 82
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 98
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.mapAttrsRecursiveCond. Like mapAttrsRecursive, but it takes an additional predicate function that tells it whether to recurse into an attribute set. If it returns false, mapAttrsRecursiveCond does not recurse, but does apply the map function. If it returns true, it does recurse, and does not apply the map function. Example. # To prevent recursing into derivations (which are attribute # sets with the attribute \"type\" equal to \"derivation\"): mapAttrsRecursiveCond (as: !(as ? \"type\" && as.type == \"derivation\")) (x: ... do something ...) attrs Type. mapAttrsRecursiveCond :: (AttrSet -&gt; Bool) -&gt; ([String] -&gt; a -&gt; b) -&gt; AttrSet -&gt; AttrSet Arguments. [cond] A function, given the attribute set the recursion is currently at, determine if to recurse deeper into that attribute set. [f] A function, given a list of attribute names and a value, returns a new value. [set] Attribute set to recursively map over. Edit source. Noogle also knows. Aliases. lib.mapAttrsRecursiveCond.",
    "raw_url": "/f/lib/attrsets/mapAttrsRecursiveCond.html",
    "excerpt": "lib.attrsets.mapAttrsRecursiveCond. Like mapAttrsRecursive, but it takes an additional predicate function that tells it whether to recurse into an attribute set. If it returns false, mapAttrsRecursiveCond does not recurse, but does",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/getAttrFromPath.html",
    "content": "lib.attrsets.getAttrFromPath. Like attrByPath, but without a default value. If it doesn't find the path it will throw an error. Example. x = { a = { b = 3; }; } getAttrFromPath [\"a\" \"b\"] x => 3 getAttrFromPath [\"z\" \"z\"] x => error: cannot find attribute `z.z' Type. getAttrFromPath :: [String] -> AttrSet -> Any Arguments. [attrPath] A list of strings representing the attribute path to get from set. [set] The nested attribute set to find the value in. Edit source. Noogle also knows. Aliases. lib.getAttrFromPath.",
    "word_count": 86,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.getAttrFromPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 19
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 47
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 55
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.getAttrFromPath. Like attrByPath, but without a default value. If it doesn't find the path it will throw an error. Example. x = { a = { b = 3; }; } getAttrFromPath [\"a\" \"b\"] x =&gt; 3 getAttrFromPath [\"z\" \"z\"] x =&gt; error: cannot find attribute `z.z' Type. getAttrFromPath :: [String] -&gt; AttrSet -&gt; Any Arguments. [attrPath] A list of strings representing the attribute path to get from set. [set] The nested attribute set to find the value in. Edit source. Noogle also knows. Aliases. lib.getAttrFromPath.",
    "raw_url": "/f/lib/attrsets/getAttrFromPath.html",
    "excerpt": "lib.attrsets.getAttrFromPath. Like attrByPath, but without a default value. If it doesn't find the path it will throw an error. Example. x = { a = { b = 3; };",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/hasAttrByPath.html",
    "content": "lib.attrsets.hasAttrByPath. Return if an attribute from nested attribute set exists. Example. x = { a = { b = 3; }; } hasAttrByPath [\"a\" \"b\"] x => true hasAttrByPath [\"z\" \"z\"] x => false Type. hasAttrByPath :: [String] -> AttrSet -> Bool Arguments. [attrPath] A list of strings representing the attribute path to check from set. [e] The nested attribute set to check. Edit source. Noogle also knows. Aliases. lib.hasAttrByPath.",
    "word_count": 70,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.hasAttrByPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.hasAttrByPath. Return if an attribute from nested attribute set exists. Example. x = { a = { b = 3; }; } hasAttrByPath [\"a\" \"b\"] x =&gt; true hasAttrByPath [\"z\" \"z\"] x =&gt; false Type. hasAttrByPath :: [String] -&gt; AttrSet -&gt; Bool Arguments. [attrPath] A list of strings representing the attribute path to check from set. [e] The nested attribute set to check. Edit source. Noogle also knows. Aliases. lib.hasAttrByPath.",
    "raw_url": "/f/lib/attrsets/hasAttrByPath.html",
    "excerpt": "lib.attrsets.hasAttrByPath. Return if an attribute from nested attribute set exists. Example. x = { a = { b = 3; }; } hasAttrByPath [\"a\" \"b\"] x =&gt; true hasAttrByPath [\"z\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/getDev.html",
    "content": "lib.attrsets.getDev. Get a package's dev output. If the output does not exist, fallback to .out and then to the default. Example. getDev pkgs.openssl => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getDev :: Derivation -> String Edit source. Noogle also knows. Aliases. lib.getDev.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.getDev"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.getDev. Get a package's dev output. If the output does not exist, fallback to .out and then to the default. Example. getDev pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getDev :: Derivation -&gt; String Edit source. Noogle also knows. Aliases. lib.getDev.",
    "raw_url": "/f/lib/attrsets/getDev.html",
    "excerpt": "lib.attrsets.getDev. Get a package's dev output. If the output does not exist, fallback to .out and then to the default. Example. getDev pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getDev :: Derivation -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/setAttrByPath.html",
    "content": "lib.attrsets.setAttrByPath. Create a new attribute set with value set at the nested attribute location specified in attrPath. Example. setAttrByPath [\"a\" \"b\"] 3 => { a = { b = 3; }; } Type. setAttrByPath :: [String] -> Any -> AttrSet Arguments. [attrPath] A list of strings representing the attribute path to set. [value] The value to set at the location described by attrPath. Edit source. Noogle also knows. Aliases. lib.setAttrByPath.",
    "word_count": 70,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.setAttrByPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 32
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.setAttrByPath. Create a new attribute set with value set at the nested attribute location specified in attrPath. Example. setAttrByPath [\"a\" \"b\"] 3 =&gt; { a = { b = 3; }; } Type. setAttrByPath :: [String] -&gt; Any -&gt; AttrSet Arguments. [attrPath] A list of strings representing the attribute path to set. [value] The value to set at the location described by attrPath. Edit source. Noogle also knows. Aliases. lib.setAttrByPath.",
    "raw_url": "/f/lib/attrsets/setAttrByPath.html",
    "excerpt": "lib.attrsets.setAttrByPath. Create a new attribute set with value set at the nested attribute location specified in attrPath. Example. setAttrByPath [\"a\" \"b\"] 3 =&gt; { a = { b = 3;",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/genAttrs.html",
    "content": "lib.attrsets.genAttrs. Generate an attribute set by mapping a function over a list of attribute names. Example. genAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name) => { foo = \"x_foo\"; bar = \"x_bar\"; } Type. genAttrs :: [ String ] -> (String -> Any) -> AttrSet Arguments. [names] Names of values in the resulting attribute set. [f] A function, given the name of the attribute, returns the attribute's value. Edit source. Noogle also knows. Aliases. lib.genAttrs.",
    "word_count": 76,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.genAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 15
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 46
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.genAttrs. Generate an attribute set by mapping a function over a list of attribute names. Example. genAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name) =&gt; { foo = \"x_foo\"; bar = \"x_bar\"; } Type. genAttrs :: [ String ] -&gt; (String -&gt; Any) -&gt; AttrSet Arguments. [names] Names of values in the resulting attribute set. [f] A function, given the name of the attribute, returns the attribute's value. Edit source. Noogle also knows. Aliases. lib.genAttrs.",
    "raw_url": "/f/lib/attrsets/genAttrs.html",
    "excerpt": "lib.attrsets.genAttrs. Generate an attribute set by mapping a function over a list of attribute names. Example. genAttrs [ \"foo\" \"bar\" ] (name: \"x_\" + name) =&gt; { foo = \"x_foo\";",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/zip.html",
    "content": "lib.attrsets.zip Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names. Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names. Example. zipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrsWith :: (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet Edit source. Noogle also knows. Aliases. builtins.zipAttrsWith. lib.zip. lib.zipAttrsWith. lib.attrsets.zipAttrsWith.",
    "word_count": 118,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.zip Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 68
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 92
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.zip Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names. Implementation note: Common names appear multiple times in the list of names, hopefully this does not affect the system because the maximal laziness avoid computing twice the same expression and listToAttrs does not care about duplicated attribute names. Example. zipAttrsWith (name: values: values) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; b = [\"z\"]; } Type. zipAttrsWith :: (String -&gt; [ Any ] -&gt; Any) -&gt; [ AttrSet ] -&gt; AttrSet Edit source. Noogle also knows. Aliases. builtins.zipAttrsWith. lib.zip. lib.zipAttrsWith. lib.attrsets.zipAttrsWith.",
    "raw_url": "/f/lib/attrsets/zip.html",
    "excerpt": "lib.attrsets.zip Primop. Takes 2 arguments. f, list. Merge sets of attributes and use the function f to merge attribute values. Like lib.attrsets.zipAttrsWithNames with all key names are passed for names.",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/getAttr.html",
    "content": "lib.attrsets.getAttr Primop. Takes 2 arguments. s, set. getAttr returns the attribute named s from set. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the . operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. builtins.getAttr. lib.getAttr.",
    "word_count": 46,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.getAttr Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.getAttr Primop. Takes 2 arguments. s, set. getAttr returns the attribute named s from set. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the . operator, since s is an expression rather than an identifier. Noogle also knows. Aliases. builtins.getAttr. lib.getAttr.",
    "raw_url": "/f/lib/attrsets/getAttr.html",
    "excerpt": "lib.attrsets.getAttr Primop. Takes 2 arguments. s, set. getAttr returns the attribute named s from set. Evaluation aborts if the attribute doesn’t exist. This is a dynamic version of the .",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/zipAttrsWithNames.html",
    "content": "lib.attrsets.zipAttrsWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] => { a = [\"x\" \"y\"]; } Type. zipAttrsWithNames :: [ String ] -> (String -> [ Any ] -> Any) -> [ AttrSet ] -> AttrSet Arguments. [names] List of attribute names to zip. [f] A function, accepts an attribute name, all the values, and returns a combined value. [sets] List of values from the list of attribute sets. Edit source. Noogle also knows. Aliases. lib.zipAttrsWithNames.",
    "word_count": 96,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.zipAttrsWithNames"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 14
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 36
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 56
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.zipAttrsWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt; { a = [\"x\" \"y\"]; } Type. zipAttrsWithNames :: [ String ] -&gt; (String -&gt; [ Any ] -&gt; Any) -&gt; [ AttrSet ] -&gt; AttrSet Arguments. [names] List of attribute names to zip. [f] A function, accepts an attribute name, all the values, and returns a combined value. [sets] List of values from the list of attribute sets. Edit source. Noogle also knows. Aliases. lib.zipAttrsWithNames.",
    "raw_url": "/f/lib/attrsets/zipAttrsWithNames.html",
    "excerpt": "lib.attrsets.zipAttrsWithNames. Merge sets of attributes and use the function f to merge attributes values. Example. zipAttrsWithNames [\"a\"] (name: vs: vs) [{a = \"x\";} {a = \"y\"; b = \"z\";}] =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/attrValues.html",
    "content": "lib.attrsets.attrValues Primop. Takes 1 arguments. set. Return the values of all attributes in the given set, sorted by attribute name. Example. attrValues {c = 3; a = 1; b = 2;} => [1 2 3] Type. attrValues :: AttrSet -> [Any] Edit source. Noogle also knows. Aliases. builtins.attrValues. lib.attrValues.",
    "word_count": 49,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.attrValues Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 35
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.attrValues Primop. Takes 1 arguments. set. Return the values of all attributes in the given set, sorted by attribute name. Example. attrValues {c = 3; a = 1; b = 2;} =&gt; [1 2 3] Type. attrValues :: AttrSet -&gt; [Any] Edit source. Noogle also knows. Aliases. builtins.attrValues. lib.attrValues.",
    "raw_url": "/f/lib/attrsets/attrValues.html",
    "excerpt": "lib.attrsets.attrValues Primop. Takes 1 arguments. set. Return the values of all attributes in the given set, sorted by attribute name. Example. attrValues {c = 3; a = 1; b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/overrideExisting.html",
    "content": "lib.attrsets.overrideExisting. Override only the attributes that are already present in the old set useful for deep-overriding. Example. overrideExisting {} { a = 1; } => {} overrideExisting { b = 2; } { a = 1; } => { b = 2; } overrideExisting { a = 3; b = 2; } { a = 1; } => { a = 1; b = 2; } Type. overrideExisting :: AttrSet -> AttrSet -> AttrSet Arguments. [old] Original attribute set. [new] Attribute set with attributes to override in old. Edit source. Noogle also knows. Aliases. lib.overrideExisting.",
    "word_count": 95,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.overrideExisting"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 66
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 74
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.overrideExisting. Override only the attributes that are already present in the old set useful for deep-overriding. Example. overrideExisting {} { a = 1; } =&gt; {} overrideExisting { b = 2; } { a = 1; } =&gt; { b = 2; } overrideExisting { a = 3; b = 2; } { a = 1; } =&gt; { a = 1; b = 2; } Type. overrideExisting :: AttrSet -&gt; AttrSet -&gt; AttrSet Arguments. [old] Original attribute set. [new] Attribute set with attributes to override in old. Edit source. Noogle also knows. Aliases. lib.overrideExisting.",
    "raw_url": "/f/lib/attrsets/overrideExisting.html",
    "excerpt": "lib.attrsets.overrideExisting. Override only the attributes that are already present in the old set useful for deep-overriding. Example. overrideExisting {} { a = 1; } =&gt; {} overrideExisting { b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/toDerivation.html",
    "content": "lib.attrsets.toDerivation. Converts a store path to a fake derivation. Type. toDerivation :: Path -> Derivation Arguments. [path] A store path to convert to a derivation. Edit source. Noogle also knows. Aliases. lib.toDerivation.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.toDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 15
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.toDerivation. Converts a store path to a fake derivation. Type. toDerivation :: Path -&gt; Derivation Arguments. [path] A store path to convert to a derivation. Edit source. Noogle also knows. Aliases. lib.toDerivation.",
    "raw_url": "/f/lib/attrsets/toDerivation.html",
    "excerpt": "lib.attrsets.toDerivation. Converts a store path to a fake derivation. Type. toDerivation :: Path -&gt; Derivation Arguments. [path] A store path to convert to a derivation. Edit source. Noogle also knows.",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/collect.html",
    "content": "lib.attrsets.collect. Recursively collect sets that verify a given predicate named pred from the set attrs. The recursion is stopped when the predicate is verified. Example. collect isList { a = { b = [\"b\"]; }; c = [1]; } => [[\"b\"] [1]] collect (x: x ? outPath) { a = { outPath = \"a/\"; }; b = { outPath = \"b/\"; }; } => [{ outPath = \"a/\"; } { outPath = \"b/\"; }] Type. collect :: (AttrSet -> Bool) -> AttrSet -> [x] Arguments. [pred] Given an attribute's value, determine if recursion should stop. [attrs] The attribute set to recursively collect. Edit source. Noogle also knows. Aliases. lib.collect.",
    "word_count": 109,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.collect"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 24
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 74
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 84
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.collect. Recursively collect sets that verify a given predicate named pred from the set attrs. The recursion is stopped when the predicate is verified. Example. collect isList { a = { b = [\"b\"]; }; c = [1]; } =&gt; [[\"b\"] [1]] collect (x: x ? outPath) { a = { outPath = \"a/\"; }; b = { outPath = \"b/\"; }; } =&gt; [{ outPath = \"a/\"; } { outPath = \"b/\"; }] Type. collect :: (AttrSet -&gt; Bool) -&gt; AttrSet -&gt; [x] Arguments. [pred] Given an attribute's value, determine if recursion should stop. [attrs] The attribute set to recursively collect. Edit source. Noogle also knows. Aliases. lib.collect.",
    "raw_url": "/f/lib/attrsets/collect.html",
    "excerpt": "lib.attrsets.collect. Recursively collect sets that verify a given predicate named pred from the set attrs. The recursion is stopped when the predicate is verified. Example. collect isList { a =",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/getAttrs.html",
    "content": "lib.attrsets.getAttrs. Given a set of attribute names, return the set of the corresponding attributes from the given set. Example. getAttrs [ \"a\" \"b\" ] { a = 1; b = 2; c = 3; } => { a = 1; b = 2; } Type. getAttrs :: [String] -> AttrSet -> AttrSet Arguments. [names] A list of attribute names to get out of set. [attrs] The set to get the named attributes from. Edit source. Noogle also knows. Aliases. lib.getAttrs.",
    "word_count": 80,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.getAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 44
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 52
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.getAttrs. Given a set of attribute names, return the set of the corresponding attributes from the given set. Example. getAttrs [ \"a\" \"b\" ] { a = 1; b = 2; c = 3; } =&gt; { a = 1; b = 2; } Type. getAttrs :: [String] -&gt; AttrSet -&gt; AttrSet Arguments. [names] A list of attribute names to get out of set. [attrs] The set to get the named attributes from. Edit source. Noogle also knows. Aliases. lib.getAttrs.",
    "raw_url": "/f/lib/attrsets/getAttrs.html",
    "excerpt": "lib.attrsets.getAttrs. Given a set of attribute names, return the set of the corresponding attributes from the given set. Example. getAttrs [ \"a\" \"b\" ] { a = 1; b =",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/getOutput.html",
    "content": "lib.attrsets.getOutput. Get a package output. If no output is found, fallback to .out and then to the default. Example. getOutput \"dev\" pkgs.openssl => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getOutput :: String -> Derivation -> String Arguments. [output] [pkg] Edit source. Noogle also knows. Aliases. lib.getOutput.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.getOutput"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 24
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 32
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.getOutput. Get a package output. If no output is found, fallback to .out and then to the default. Example. getOutput \"dev\" pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getOutput :: String -&gt; Derivation -&gt; String Arguments. [output] [pkg] Edit source. Noogle also knows. Aliases. lib.getOutput.",
    "raw_url": "/f/lib/attrsets/getOutput.html",
    "excerpt": "lib.attrsets.getOutput. Get a package output. If no output is found, fallback to .out and then to the default. Example. getOutput \"dev\" pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r-dev\" Type. getOutput :: String -&gt; Derivation",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/foldAttrs.html",
    "content": "lib.attrsets.foldAttrs. Apply fold functions to values grouped by key. Example. foldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }] => { a = [ 2 3 ]; } Type. foldAttrs :: (Any -> Any -> Any) -> Any -> [AttrSets] -> Any Arguments. [op] A function, given a value and a collector combines the two. [nul] The starting value. [list_of_attrs] A list of attribute sets to fold together by key. Edit source. Noogle also knows. Aliases. lib.foldAttrs.",
    "word_count": 85,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.foldAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 36
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.foldAttrs. Apply fold functions to values grouped by key. Example. foldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }] =&gt; { a = [ 2 3 ]; } Type. foldAttrs :: (Any -&gt; Any -&gt; Any) -&gt; Any -&gt; [AttrSets] -&gt; Any Arguments. [op] A function, given a value and a collector combines the two. [nul] The starting value. [list_of_attrs] A list of attribute sets to fold together by key. Edit source. Noogle also knows. Aliases. lib.foldAttrs.",
    "raw_url": "/f/lib/attrsets/foldAttrs.html",
    "excerpt": "lib.attrsets.foldAttrs. Apply fold functions to values grouped by key. Example. foldAttrs (item: acc: [item] ++ acc) [] [{ a = 2; } { a = 3; }] =&gt; { a",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/recurseIntoAttrs.html",
    "content": "lib.attrsets.recurseIntoAttrs. Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc. This function only affects a single attribute set; it does not apply itself recursively for nested attribute sets. Example. { pkgs ? import <nixpkgs> {} }: { myTools = pkgs.lib.recurseIntoAttrs { inherit (pkgs) hello figlet; }; } Type. recurseIntoAttrs :: AttrSet -> AttrSet Arguments. [attrs] An attribute set to scan for derivations. Edit source. Noogle also knows. Aliases. lib.recurseIntoAttrs. pkgs.recurseIntoAttrs.",
    "word_count": 81,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.recurseIntoAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 39
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 58
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 64
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.recurseIntoAttrs. Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc. This function only affects a single attribute set; it does not apply itself recursively for nested attribute sets. Example. { pkgs ? import &lt;nixpkgs&gt; {} }: { myTools = pkgs.lib.recurseIntoAttrs { inherit (pkgs) hello figlet; }; } Type. recurseIntoAttrs :: AttrSet -&gt; AttrSet Arguments. [attrs] An attribute set to scan for derivations. Edit source. Noogle also knows. Aliases. lib.recurseIntoAttrs. pkgs.recurseIntoAttrs.",
    "raw_url": "/f/lib/attrsets/recurseIntoAttrs.html",
    "excerpt": "lib.attrsets.recurseIntoAttrs. Make various Nix tools consider the contents of the resulting attribute set when looking for what to build, find, etc. This function only affects a single attribute set; it",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/foldlAttrs.html",
    "content": "lib.attrsets.foldlAttrs. Like lib.lists.foldl' but for attribute sets. Iterates over every name-value pair in the given attribute set. The result of the callback function is often called acc for accumulator. It is passed between callbacks from left to right and the final acc is the return value of foldlAttrs. Attention: There is a completely different function lib.foldAttrs which has nothing to do with this function, despite the similar name. Example. foldlAttrs (acc: name: value: { sum = acc.sum + value; names = acc.names ++ [name]; }) { sum = 0; names = []; } { foo = 1; bar = 10; } -> { sum = 11; names = [\"bar\" \"foo\"]; } foldlAttrs (throw \"function not needed\") 123 {}; -> 123 foldlAttrs (acc: _: _: acc) 3 { z = throw \"value not needed\"; a = throw \"value not needed\"; }; -> 3 The accumulator doesn't have to be an attrset. It can be as simple as a number or string. foldlAttrs (acc: _: v: acc * 10 + v) 1 { z = 1; a = 2; }; -> 121 Type. foldlAttrs :: ( a -> String -> b -> a ) -> a -> { ... :: b } -> a Arguments. [f] [init] [set] Edit source. Noogle also knows. Aliases. lib.foldlAttrs.",
    "word_count": 213,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.foldlAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 68
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 180
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 202
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.foldlAttrs. Like lib.lists.foldl' but for attribute sets. Iterates over every name-value pair in the given attribute set. The result of the callback function is often called acc for accumulator. It is passed between callbacks from left to right and the final acc is the return value of foldlAttrs. Attention: There is a completely different function lib.foldAttrs which has nothing to do with this function, despite the similar name. Example. foldlAttrs (acc: name: value: { sum = acc.sum + value; names = acc.names ++ [name]; }) { sum = 0; names = []; } { foo = 1; bar = 10; } -&gt; { sum = 11; names = [\"bar\" \"foo\"]; } foldlAttrs (throw \"function not needed\") 123 {}; -&gt; 123 foldlAttrs (acc: _: _: acc) 3 { z = throw \"value not needed\"; a = throw \"value not needed\"; }; -&gt; 3 The accumulator doesn't have to be an attrset. It can be as simple as a number or string. foldlAttrs (acc: _: v: acc * 10 + v) 1 { z = 1; a = 2; }; -&gt; 121 Type. foldlAttrs :: ( a -&gt; String -&gt; b -&gt; a ) -&gt; a -&gt; { ... :: b } -&gt; a Arguments. [f] [init] [set] Edit source. Noogle also knows. Aliases. lib.foldlAttrs.",
    "raw_url": "/f/lib/attrsets/foldlAttrs.html",
    "excerpt": "lib.attrsets.foldlAttrs. Like lib.lists.foldl' but for attribute sets. Iterates over every name-value pair in the given attribute set. The result of the callback function is often called acc for accumulator. It",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/matchAttrs.html",
    "content": "lib.attrsets.matchAttrs. Returns true if the pattern is contained in the set. False otherwise. Example. matchAttrs { cpu = {}; } { cpu = { bits = 64; }; } => true Type. matchAttrs :: AttrSet -> AttrSet -> Bool Arguments. [pattern] Attribute set structure to match. [attrs] Attribute set to find patterns in. Edit source. Noogle also knows. Aliases. lib.matchAttrs.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.matchAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.matchAttrs. Returns true if the pattern is contained in the set. False otherwise. Example. matchAttrs { cpu = {}; } { cpu = { bits = 64; }; } =&gt; true Type. matchAttrs :: AttrSet -&gt; AttrSet -&gt; Bool Arguments. [pattern] Attribute set structure to match. [attrs] Attribute set to find patterns in. Edit source. Noogle also knows. Aliases. lib.matchAttrs.",
    "raw_url": "/f/lib/attrsets/matchAttrs.html",
    "excerpt": "lib.attrsets.matchAttrs. Returns true if the pattern is contained in the set. False otherwise. Example. matchAttrs { cpu = {}; } { cpu = { bits = 64; }; } =&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/filterAttrsRecursive.html",
    "content": "lib.attrsets.filterAttrsRecursive. Filter an attribute set recursively by removing all attributes for which the given predicate return false. Example. filterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; } => { foo = {}; } Type. filterAttrsRecursive :: (String -> Any -> Bool) -> AttrSet -> AttrSet Arguments. [pred] Predicate taking an attribute name and an attribute value, which returns true to include the attribute, or false to exclude the attribute. [set] The attribute set to filter. Edit source. Noogle also knows. Aliases. lib.filterAttrsRecursive.",
    "word_count": 88,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.filterAttrsRecursive"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 17
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 39
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 51
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.filterAttrsRecursive. Filter an attribute set recursively by removing all attributes for which the given predicate return false. Example. filterAttrsRecursive (n: v: v != null) { foo = { bar = null; }; } =&gt; { foo = {}; } Type. filterAttrsRecursive :: (String -&gt; Any -&gt; Bool) -&gt; AttrSet -&gt; AttrSet Arguments. [pred] Predicate taking an attribute name and an attribute value, which returns true to include the attribute, or false to exclude the attribute. [set] The attribute set to filter. Edit source. Noogle also knows. Aliases. lib.filterAttrsRecursive.",
    "raw_url": "/f/lib/attrsets/filterAttrsRecursive.html",
    "excerpt": "lib.attrsets.filterAttrsRecursive. Filter an attribute set recursively by removing all attributes for which the given predicate return false. Example. filterAttrsRecursive (n: v: v != null) { foo = { bar =",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/attrsToList.html",
    "content": "lib.attrsets.attrsToList. Deconstruct an attrset to a list of name-value pairs as expected by builtins.listToAttrs. Each element of the resulting list is an attribute set with these attributes: name (string): The name of the attribute. value (any): The value of the attribute The following is always true: builtins.listToAttrs (attrsToList attrs) == attrs :::{.warning} The opposite is not always true. In general expect that. attrsToList (builtins.listToAttrs list) != list This is because the listToAttrs removes duplicate names and doesn't preserve the order of the list. ::: Example. attrsToList { foo = 1; bar = \"asdf\"; } => [ { name = \"bar\"; value = \"asdf\"; } { name = \"foo\"; value = 1; } ] Type. attrsToList :: AttrSet -> [ { name :: String; value :: Any; } ] Edit source. Noogle also knows. Aliases. lib.attrsToList.",
    "word_count": 135,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.attrsToList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 84
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 113
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.attrsToList. Deconstruct an attrset to a list of name-value pairs as expected by builtins.listToAttrs. Each element of the resulting list is an attribute set with these attributes: name (string): The name of the attribute. value (any): The value of the attribute The following is always true: builtins.listToAttrs (attrsToList attrs) == attrs :::{.warning} The opposite is not always true. In general expect that. attrsToList (builtins.listToAttrs list) != list This is because the listToAttrs removes duplicate names and doesn't preserve the order of the list. ::: Example. attrsToList { foo = 1; bar = \"asdf\"; } =&gt; [ { name = \"bar\"; value = \"asdf\"; } { name = \"foo\"; value = 1; } ] Type. attrsToList :: AttrSet -&gt; [ { name :: String; value :: Any; } ] Edit source. Noogle also knows. Aliases. lib.attrsToList.",
    "raw_url": "/f/lib/attrsets/attrsToList.html",
    "excerpt": "lib.attrsets.attrsToList. Deconstruct an attrset to a list of name-value pairs as expected by builtins.listToAttrs. Each element of the resulting list is an attribute set with these attributes: name (string): The",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/cartesianProductOfSets.html",
    "content": "lib.attrsets.cartesianProductOfSets. Return the cartesian product of attribute set value combinations. Example. cartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; } => [ { a = 1; b = 10; } { a = 1; b = 20; } { a = 2; b = 10; } { a = 2; b = 20; } ] Type. cartesianProductOfSets :: AttrSet -> [AttrSet] Arguments. [attrsOfLists] Attribute set with attributes that are lists of values. Edit source. Noogle also knows. Aliases. lib.cartesianProductOfSets.",
    "word_count": 85,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.cartesianProductOfSets"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 61
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 67
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.cartesianProductOfSets. Return the cartesian product of attribute set value combinations. Example. cartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; } =&gt; [ { a = 1; b = 10; } { a = 1; b = 20; } { a = 2; b = 10; } { a = 2; b = 20; } ] Type. cartesianProductOfSets :: AttrSet -&gt; [AttrSet] Arguments. [attrsOfLists] Attribute set with attributes that are lists of values. Edit source. Noogle also knows. Aliases. lib.cartesianProductOfSets.",
    "raw_url": "/f/lib/attrsets/cartesianProductOfSets.html",
    "excerpt": "lib.attrsets.cartesianProductOfSets. Return the cartesian product of attribute set value combinations. Example. cartesianProductOfSets { a = [ 1 2 ]; b = [ 10 20 ]; } =&gt; [ { a",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/updateManyAttrsByPath.html",
    "content": "lib.attrsets.updateManyAttrsByPath. Update or set specific paths of an attribute set. Takes a list of updates to apply and an attribute set to apply them to, and returns the attribute set with the updates applied. Updates are represented as { path = ...; update = ...; } values, where path is a list of strings representing the attribute path that should be updated, and update is a function that takes the old value at that attribute path as an argument and returns the new value it should be. Properties: Updates to deeper attribute paths are applied before updates to more shallow attribute paths. Multiple updates to the same attribute path are applied in the order they appear in the update list. If any but the last path element leads into a value that is not an attribute set, an error is thrown. If there is an update for an attribute path that doesn't exist, accessing the argument in the update function causes an error, but intermediate attribute sets are implicitly created as needed. Example. updateManyAttrsByPath [ { path = [ \"a\" \"b\" ]; update = old: { d = old.c; }; } { path = [ \"a\" \"b\" \"c\" ]; update = old: old + 1; } { path = [ \"x\" \"y\" ]; update = old: \"xy\"; } ] { a.b.c = 0; } => { a = { b = { d = 1; }; }; x = { y = \"xy\"; }; } Type. updateManyAttrsByPath :: [{ path :: [String]; update :: (Any -> Any); }] -> AttrSet -> AttrSet Edit source. Noogle also knows. Aliases. lib.updateManyAttrsByPath.",
    "word_count": 269,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.updateManyAttrsByPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 172
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 245
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.updateManyAttrsByPath. Update or set specific paths of an attribute set. Takes a list of updates to apply and an attribute set to apply them to, and returns the attribute set with the updates applied. Updates are represented as { path = ...; update = ...; } values, where path is a list of strings representing the attribute path that should be updated, and update is a function that takes the old value at that attribute path as an argument and returns the new value it should be. Properties: Updates to deeper attribute paths are applied before updates to more shallow attribute paths. Multiple updates to the same attribute path are applied in the order they appear in the update list. If any but the last path element leads into a value that is not an attribute set, an error is thrown. If there is an update for an attribute path that doesn't exist, accessing the argument in the update function causes an error, but intermediate attribute sets are implicitly created as needed. Example. updateManyAttrsByPath [ { path = [ \"a\" \"b\" ]; update = old: { d = old.c; }; } { path = [ \"a\" \"b\" \"c\" ]; update = old: old + 1; } { path = [ \"x\" \"y\" ]; update = old: \"xy\"; } ] { a.b.c = 0; } =&gt; { a = { b = { d = 1; }; }; x = { y = \"xy\"; }; } Type. updateManyAttrsByPath :: [{ path :: [String]; update :: (Any -&gt; Any); }] -&gt; AttrSet -&gt; AttrSet Edit source. Noogle also knows. Aliases. lib.updateManyAttrsByPath.",
    "raw_url": "/f/lib/attrsets/updateManyAttrsByPath.html",
    "excerpt": "lib.attrsets.updateManyAttrsByPath. Update or set specific paths of an attribute set. Takes a list of updates to apply and an attribute set to apply them to, and returns the attribute set",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/recursiveUpdate.html",
    "content": "lib.attrsets.recursiveUpdate. A recursive variant of the update operator ‘//’. The recursion stops when one of the attribute values is not an attribute set, in which case the right hand side value takes precedence over the left hand side value. Example. recursiveUpdate { boot.loader.grub.enable = true; boot.loader.grub.device = \"/dev/hda\"; } { boot.loader.grub.device = \"\"; } returns: { boot.loader.grub.enable = true; boot.loader.grub.device = \"\"; } Type. recursiveUpdate :: AttrSet -> AttrSet -> AttrSet Arguments. [lhs] Left attribute set of the merge. [rhs] Right attribute set of the merge. Edit source. Noogle also knows. Aliases. lib.recursiveUpdate.",
    "word_count": 93,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.recursiveUpdate"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 39
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 63
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 71
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.recursiveUpdate. A recursive variant of the update operator ‘//’. The recursion stops when one of the attribute values is not an attribute set, in which case the right hand side value takes precedence over the left hand side value. Example. recursiveUpdate { boot.loader.grub.enable = true; boot.loader.grub.device = \"/dev/hda\"; } { boot.loader.grub.device = \"\"; } returns: { boot.loader.grub.enable = true; boot.loader.grub.device = \"\"; } Type. recursiveUpdate :: AttrSet -&gt; AttrSet -&gt; AttrSet Arguments. [lhs] Left attribute set of the merge. [rhs] Right attribute set of the merge. Edit source. Noogle also knows. Aliases. lib.recursiveUpdate.",
    "raw_url": "/f/lib/attrsets/recursiveUpdate.html",
    "excerpt": "lib.attrsets.recursiveUpdate. A recursive variant of the update operator ‘//’. The recursion stops when one of the attribute values is not an attribute set, in which case the right hand side",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/attrVals.html",
    "content": "lib.attrsets.attrVals. Return the specified attributes from a set. Example. attrVals [\"a\" \"b\" \"c\"] as => [as.a as.b as.c] Type. attrVals :: [String] -> AttrSet -> [Any] Arguments. [nameList] The list of attributes to fetch from set. Each attribute name must exist on the attrbitue set. [set] The set to get attribute values from. Edit source. Noogle also knows. Aliases. lib.attrVals.",
    "word_count": 60,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.attrVals"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 8
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 18
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.attrVals. Return the specified attributes from a set. Example. attrVals [\"a\" \"b\" \"c\"] as =&gt; [as.a as.b as.c] Type. attrVals :: [String] -&gt; AttrSet -&gt; [Any] Arguments. [nameList] The list of attributes to fetch from set. Each attribute name must exist on the attrbitue set. [set] The set to get attribute values from. Edit source. Noogle also knows. Aliases. lib.attrVals.",
    "raw_url": "/f/lib/attrsets/attrVals.html",
    "excerpt": "lib.attrsets.attrVals. Return the specified attributes from a set. Example. attrVals [\"a\" \"b\" \"c\"] as =&gt; [as.a as.b as.c] Type. attrVals :: [String] -&gt; AttrSet -&gt; [Any] Arguments. [nameList] The list",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/attrByPath.html",
    "content": "lib.attrsets.attrByPath. Return an attribute from nested attribute sets. Example. x = { a = { b = 3; }; } # [\"a\" \"b\"] is equivalent to x.a.b # 6 is a default value to return if the path does not exist in attrset attrByPath [\"a\" \"b\"] 6 x => 3 attrByPath [\"z\" \"z\"] 6 x => 6 Type. attrByPath :: [String] -> Any -> AttrSet -> Any Arguments. [attrPath] A list of strings representing the attribute path to return from set. [default] Default value if attrPath does not resolve to an existing value. [set] The nested attribute set to select values from. Edit source. Noogle also knows. Aliases. lib.attrByPath.",
    "word_count": 109,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.attrByPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 8
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 57
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 67
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.attrByPath. Return an attribute from nested attribute sets. Example. x = { a = { b = 3; }; } # [\"a\" \"b\"] is equivalent to x.a.b # 6 is a default value to return if the path does not exist in attrset attrByPath [\"a\" \"b\"] 6 x =&gt; 3 attrByPath [\"z\" \"z\"] 6 x =&gt; 6 Type. attrByPath :: [String] -&gt; Any -&gt; AttrSet -&gt; Any Arguments. [attrPath] A list of strings representing the attribute path to return from set. [default] Default value if attrPath does not resolve to an existing value. [set] The nested attribute set to select values from. Edit source. Noogle also knows. Aliases. lib.attrByPath.",
    "raw_url": "/f/lib/attrsets/attrByPath.html",
    "excerpt": "lib.attrsets.attrByPath. Return an attribute from nested attribute sets. Example. x = { a = { b = 3; }; } # [\"a\" \"b\"] is equivalent to x.a.b # 6 is",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/isDerivation.html",
    "content": "lib.attrsets.isDerivation. Check whether the argument is a derivation. Any set with { type = \"derivation\"; } counts as a derivation. Example. nixpkgs = import <nixpkgs> {} isDerivation nixpkgs.ruby => true isDerivation \"foobar\" => false Type. isDerivation :: Any -> Bool Arguments. [value] Value to check. Edit source. Noogle also knows. Aliases. lib.isDerivation.",
    "word_count": 52,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.isDerivation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 34
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 40
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.isDerivation. Check whether the argument is a derivation. Any set with { type = \"derivation\"; } counts as a derivation. Example. nixpkgs = import &lt;nixpkgs&gt; {} isDerivation nixpkgs.ruby =&gt; true isDerivation \"foobar\" =&gt; false Type. isDerivation :: Any -&gt; Bool Arguments. [value] Value to check. Edit source. Noogle also knows. Aliases. lib.isDerivation.",
    "raw_url": "/f/lib/attrsets/isDerivation.html",
    "excerpt": "lib.attrsets.isDerivation. Check whether the argument is a derivation. Any set with { type = \"derivation\"; } counts as a derivation. Example. nixpkgs = import &lt;nixpkgs&gt; {} isDerivation nixpkgs.ruby =&gt; true",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/nameValuePair.html",
    "content": "lib.attrsets.nameValuePair. Utility function that creates a {name, value} pair as expected by builtins.listToAttrs. Example. nameValuePair \"some\" 6 => { name = \"some\"; value = 6; } Type. nameValuePair :: String -> Any -> { name :: String; value :: Any; } Arguments. [name] Attribute name. [value] Attribute value. Edit source. Noogle also knows. Aliases. lib.nameValuePair.",
    "word_count": 55,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.nameValuePair"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 13
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 26
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 41
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.nameValuePair. Utility function that creates a {name, value} pair as expected by builtins.listToAttrs. Example. nameValuePair \"some\" 6 =&gt; { name = \"some\"; value = 6; } Type. nameValuePair :: String -&gt; Any -&gt; { name :: String; value :: Any; } Arguments. [name] Attribute name. [value] Attribute value. Edit source. Noogle also knows. Aliases. lib.nameValuePair.",
    "raw_url": "/f/lib/attrsets/nameValuePair.html",
    "excerpt": "lib.attrsets.nameValuePair. Utility function that creates a {name, value} pair as expected by builtins.listToAttrs. Example. nameValuePair \"some\" 6 =&gt; { name = \"some\"; value = 6; } Type. nameValuePair :: String",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/isAttrs.html",
    "content": "lib.attrsets.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. builtins.isAttrs. lib.isAttrs. lib.strings.isAttrs.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.isAttrs Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. builtins.isAttrs. lib.isAttrs. lib.strings.isAttrs.",
    "raw_url": "/f/lib/attrsets/isAttrs.html",
    "excerpt": "lib.attrsets.isAttrs Primop. Takes 1 arguments. e. Return true if e evaluates to a set, and false otherwise. Noogle also knows. Aliases. builtins.isAttrs. lib.isAttrs. lib.strings.isAttrs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/mapAttrs.html",
    "content": "lib.attrsets.mapAttrs Primop. Takes 2 arguments. f, attrset. Apply a function to each element in an attribute set, creating a new attribute set. Example. mapAttrs (name: value: name + \"-\" + value) { x = \"foo\"; y = \"bar\"; } => { x = \"x-foo\"; y = \"y-bar\"; } Type. mapAttrs :: (String -> Any -> Any) -> AttrSet -> AttrSet Edit source. Noogle also knows. Aliases. builtins.mapAttrs. lib.mapAttrs.",
    "word_count": 68,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.mapAttrs Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 22
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 48
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.mapAttrs Primop. Takes 2 arguments. f, attrset. Apply a function to each element in an attribute set, creating a new attribute set. Example. mapAttrs (name: value: name + \"-\" + value) { x = \"foo\"; y = \"bar\"; } =&gt; { x = \"x-foo\"; y = \"y-bar\"; } Type. mapAttrs :: (String -&gt; Any -&gt; Any) -&gt; AttrSet -&gt; AttrSet Edit source. Noogle also knows. Aliases. builtins.mapAttrs. lib.mapAttrs.",
    "raw_url": "/f/lib/attrsets/mapAttrs.html",
    "excerpt": "lib.attrsets.mapAttrs Primop. Takes 2 arguments. f, attrset. Apply a function to each element in an attribute set, creating a new attribute set. Example. mapAttrs (name: value: name + \"-\" +",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/filterAttrs.html",
    "content": "lib.attrsets.filterAttrs. Filter an attribute set by removing all attributes for which the given predicate return false. Example. filterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; } => { foo = 1; } Type. filterAttrs :: (String -> Any -> Bool) -> AttrSet -> AttrSet Arguments. [pred] Predicate taking an attribute name and an attribute value, which returns true to include the attribute, or false to exclude the attribute. [set] The attribute set to filter. Edit source. Noogle also knows. Aliases. lib.filterAttrs.",
    "word_count": 86,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.filterAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 16
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 37
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 49
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.filterAttrs. Filter an attribute set by removing all attributes for which the given predicate return false. Example. filterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2; } =&gt; { foo = 1; } Type. filterAttrs :: (String -&gt; Any -&gt; Bool) -&gt; AttrSet -&gt; AttrSet Arguments. [pred] Predicate taking an attribute name and an attribute value, which returns true to include the attribute, or false to exclude the attribute. [set] The attribute set to filter. Edit source. Noogle also knows. Aliases. lib.filterAttrs.",
    "raw_url": "/f/lib/attrsets/filterAttrs.html",
    "excerpt": "lib.attrsets.filterAttrs. Filter an attribute set by removing all attributes for which the given predicate return false. Example. filterAttrs (n: v: n == \"foo\") { foo = 1; bar = 2;",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/showAttrPath.html",
    "content": "lib.attrsets.showAttrPath. Turns a list of strings into a human-readable description of those strings represented as an attribute path. The result of this function is not intended to be machine-readable. Create a new attribute set with value set at the nested attribute location specified in attrPath. Example. showAttrPath [ \"foo\" \"10\" \"bar\" ] => \"foo.\\\"10\\\".bar\" showAttrPath [] => \"<root attribute path>\" Type. showAttrPath :: [String] -> String Arguments. [path] Attribute path to render to a string. Edit source. Noogle also knows. Aliases. lib.showAttrPath.",
    "word_count": 82,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.showAttrPath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 45
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 60
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 66
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.showAttrPath. Turns a list of strings into a human-readable description of those strings represented as an attribute path. The result of this function is not intended to be machine-readable. Create a new attribute set with value set at the nested attribute location specified in attrPath. Example. showAttrPath [ \"foo\" \"10\" \"bar\" ] =&gt; \"foo.\\\"10\\\".bar\" showAttrPath [] =&gt; \"&lt;root attribute path&gt;\" Type. showAttrPath :: [String] -&gt; String Arguments. [path] Attribute path to render to a string. Edit source. Noogle also knows. Aliases. lib.showAttrPath.",
    "raw_url": "/f/lib/attrsets/showAttrPath.html",
    "excerpt": "lib.attrsets.showAttrPath. Turns a list of strings into a human-readable description of those strings represented as an attribute path. The result of this function is not intended to be machine-readable. Create",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/attrNames.html",
    "content": "lib.attrsets.attrNames Primop. Takes 1 arguments. set. Return the names of the attributes in the set set in an alphabetically sorted list. For instance, builtins.attrNames { y = 1; x = \"foo\"; } evaluates to [ \"x\" \"y\" ]. Noogle also knows. Aliases. builtins.attrNames. lib.attrNames.",
    "word_count": 44,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.attrNames Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.attrNames Primop. Takes 1 arguments. set. Return the names of the attributes in the set set in an alphabetically sorted list. For instance, builtins.attrNames { y = 1; x = \"foo\"; } evaluates to [ \"x\" \"y\" ]. Noogle also knows. Aliases. builtins.attrNames. lib.attrNames.",
    "raw_url": "/f/lib/attrsets/attrNames.html",
    "excerpt": "lib.attrsets.attrNames Primop. Takes 1 arguments. set. Return the names of the attributes in the set set in an alphabetically sorted list. For instance, builtins.attrNames { y = 1; x =",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/getBin.html",
    "content": "lib.attrsets.getBin. Get a package's bin output. If the output does not exist, fallback to .out and then to the default. Example. getBin pkgs.openssl => \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r\" Type. getBin :: Derivation -> String Edit source. Noogle also knows. Aliases. lib.getBin.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.getBin"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 20
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 25
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.getBin. Get a package's bin output. If the output does not exist, fallback to .out and then to the default. Example. getBin pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r\" Type. getBin :: Derivation -&gt; String Edit source. Noogle also knows. Aliases. lib.getBin.",
    "raw_url": "/f/lib/attrsets/getBin.html",
    "excerpt": "lib.attrsets.getBin. Get a package's bin output. If the output does not exist, fallback to .out and then to the default. Example. getBin pkgs.openssl =&gt; \"/nix/store/9rz8gxhzf8sw4kf2j2f1grr49w8zx5vj-openssl-1.0.1r\" Type. getBin :: Derivation -&gt;",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/catAttrs.html",
    "content": "lib.attrsets.catAttrs Primop. Takes 2 arguments. attr, list. Collect each attribute named attr from a list of attribute sets. Sets that don't contain the named attribute are ignored. Example. catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}] => [1 2] Type. catAttrs :: String -> [AttrSet] -> [Any] Edit source. Noogle also knows. Aliases. builtins.catAttrs. lib.catAttrs.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.catAttrs Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 27
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.catAttrs Primop. Takes 2 arguments. attr, list. Collect each attribute named attr from a list of attribute sets. Sets that don't contain the named attribute are ignored. Example. catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}] =&gt; [1 2] Type. catAttrs :: String -&gt; [AttrSet] -&gt; [Any] Edit source. Noogle also knows. Aliases. builtins.catAttrs. lib.catAttrs.",
    "raw_url": "/f/lib/attrsets/catAttrs.html",
    "excerpt": "lib.attrsets.catAttrs Primop. Takes 2 arguments. attr, list. Collect each attribute named attr from a list of attribute sets. Sets that don't contain the named attribute are ignored. Example. catAttrs \"a\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/unionOfDisjoint.html",
    "content": "lib.attrsets.unionOfDisjoint. unionOfDisjoint x y is equal to x // y // z where the attrnames in z are the intersection of the attrnames in x and y, and all values assert with an error message. This operator is commutative, unlike (//). Type. unionOfDisjoint :: AttrSet -> AttrSet -> AttrSet Arguments. [x] [y] Edit source.",
    "word_count": 54,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.unionOfDisjoint"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 41
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 49
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.unionOfDisjoint. unionOfDisjoint x y is equal to x // y // z where the attrnames in z are the intersection of the attrnames in x and y, and all values assert with an error message. This operator is commutative, unlike (//). Type. unionOfDisjoint :: AttrSet -&gt; AttrSet -&gt; AttrSet Arguments. [x] [y] Edit source.",
    "raw_url": "/f/lib/attrsets/unionOfDisjoint.html",
    "excerpt": "lib.attrsets.unionOfDisjoint. unionOfDisjoint x y is equal to x // y // z where the attrnames in z are the intersection of the attrnames in x and y, and all values",
    "sub_results": []
  },
  {
    "url": "/f/lib/attrsets/dontRecurseIntoAttrs.html",
    "content": "lib.attrsets.dontRecurseIntoAttrs. Undo the effect of recurseIntoAttrs. Type. dontRecurseIntoAttrs :: AttrSet -> AttrSet Arguments. [attrs] An attribute set to not scan for derivations. Edit source. Noogle also knows. Aliases. lib.dontRecurseIntoAttrs. pkgs.dontRecurseIntoAttrs.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.attrsets.dontRecurseIntoAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 6
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.attrsets.dontRecurseIntoAttrs. Undo the effect of recurseIntoAttrs. Type. dontRecurseIntoAttrs :: AttrSet -&gt; AttrSet Arguments. [attrs] An attribute set to not scan for derivations. Edit source. Noogle also knows. Aliases. lib.dontRecurseIntoAttrs. pkgs.dontRecurseIntoAttrs.",
    "raw_url": "/f/lib/attrsets/dontRecurseIntoAttrs.html",
    "excerpt": "lib.attrsets.dontRecurseIntoAttrs. Undo the effect of recurseIntoAttrs. Type. dontRecurseIntoAttrs :: AttrSet -&gt; AttrSet Arguments. [attrs] An attribute set to not scan for derivations. Edit source. Noogle also knows. Aliases. lib.dontRecurseIntoAttrs. pkgs.dontRecurseIntoAttrs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/getExe'.html",
    "content": "lib.getExe' (Prime). Get the path of a program of a derivation. Example. getExe' pkgs.hello \"hello\" => \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe' pkgs.imagemagick \"convert\" => \"/nix/store/5rs48jamq7k6sal98ymj9l4k2bnwq515-imagemagick-7.1.1-15/bin/convert\" Type. getExe' :: derivation -> string -> string Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.meta.getExe'",
    "word_count": 40,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.getExe' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 11
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 22
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 30
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.getExe' (Prime). Get the path of a program of a derivation. Example. getExe' pkgs.hello \"hello\" =&gt; \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe' pkgs.imagemagick \"convert\" =&gt; \"/nix/store/5rs48jamq7k6sal98ymj9l4k2bnwq515-imagemagick-7.1.1-15/bin/convert\" Type. getExe' :: derivation -&gt; string -&gt; string Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.meta.getExe'",
    "raw_url": "/f/lib/getExe'.html",
    "excerpt": "lib.getExe' (Prime). Get the path of a program of a derivation. Example. getExe' pkgs.hello \"hello\" =&gt; \"/nix/store/g124820p9hlv4lj8qplzxw1c44dxaw1k-hello-2.12/bin/hello\" getExe' pkgs.imagemagick \"convert\" =&gt; \"/nix/store/5rs48jamq7k6sal98ymj9l4k2bnwq515-imagemagick-7.1.1-15/bin/convert\" Type. getExe' :: derivation -&gt; string -&gt; string",
    "sub_results": []
  },
  {
    "url": "/f/lib/innerClosePropagation.html",
    "content": "lib.innerClosePropagation. Edit source. Noogle also knows. Aliases. lib.misc.innerClosePropagation.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.innerClosePropagation"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.innerClosePropagation. Edit source. Noogle also knows. Aliases. lib.misc.innerClosePropagation.",
    "raw_url": "/f/lib/innerClosePropagation.html",
    "excerpt": "lib.innerClosePropagation. Edit source. Noogle also knows. Aliases. lib.misc.innerClosePropagation.",
    "sub_results": []
  },
  {
    "url": "/f/lib/hasInfix.html",
    "content": "lib.hasInfix. Determine whether a string contains the given infix. Example. hasInfix \"bc\" \"abcd\" => true hasInfix \"ab\" \"abcd\" => true hasInfix \"cd\" \"abcd\" => true hasInfix \"foo\" \"abcd\" => false Type. hasInfix :: string -> string -> bool Arguments. [infix] [content] Edit source. Noogle also knows. Aliases. lib.strings.hasInfix.",
    "word_count": 48,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.hasInfix"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 30
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 38
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.hasInfix. Determine whether a string contains the given infix. Example. hasInfix \"bc\" \"abcd\" =&gt; true hasInfix \"ab\" \"abcd\" =&gt; true hasInfix \"cd\" \"abcd\" =&gt; true hasInfix \"foo\" \"abcd\" =&gt; false Type. hasInfix :: string -&gt; string -&gt; bool Arguments. [infix] [content] Edit source. Noogle also knows. Aliases. lib.strings.hasInfix.",
    "raw_url": "/f/lib/hasInfix.html",
    "excerpt": "lib.hasInfix. Determine whether a string contains the given infix. Example. hasInfix \"bc\" \"abcd\" =&gt; true hasInfix \"ab\" \"abcd\" =&gt; true hasInfix \"cd\" \"abcd\" =&gt; true hasInfix \"foo\" \"abcd\" =&gt; false",
    "sub_results": []
  },
  {
    "url": "/f/lib/concat.html",
    "content": "lib.concat. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] => [ 1 2 3 4 ] Type. concat :: [a] -> [a] -> [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.concat.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concat"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 4
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 21
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concat. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments. [x] [y] Edit source. Noogle also knows. Aliases. lib.trivial.concat.",
    "raw_url": "/f/lib/concat.html",
    "excerpt": "lib.concat. Concatenate two lists. Example. concat [ 1 2 ] [ 3 4 ] =&gt; [ 1 2 3 4 ] Type. concat :: [a] -&gt; [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkVMOverride.html",
    "content": "lib.mkVMOverride. Noogle also knows. Aliases. lib.modules.mkVMOverride.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkVMOverride"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkVMOverride. Noogle also knows. Aliases. lib.modules.mkVMOverride.",
    "raw_url": "/f/lib/mkVMOverride.html",
    "excerpt": "lib.mkVMOverride. Noogle also knows. Aliases. lib.modules.mkVMOverride.",
    "sub_results": []
  },
  {
    "url": "/f/lib/isStorePath.html",
    "content": "lib.isStorePath. Check whether a value is a store path. Example. isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11/bin/python\" => false isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11\" => true isStorePath pkgs.python => true isStorePath [] || isStorePath 42 || isStorePath {} || … => false Arguments. [x] Edit source. Noogle also knows. Aliases. lib.strings.isStorePath.",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isStorePath"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 34
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isStorePath. Check whether a value is a store path. Example. isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11/bin/python\" =&gt; false isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11\" =&gt; true isStorePath pkgs.python =&gt; true isStorePath [] || isStorePath 42 || isStorePath {} || … =&gt; false Arguments. [x] Edit source. Noogle also knows. Aliases. lib.strings.isStorePath.",
    "raw_url": "/f/lib/isStorePath.html",
    "excerpt": "lib.isStorePath. Check whether a value is a store path. Example. isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11/bin/python\" =&gt; false isStorePath \"/nix/store/d945ibfx9x185xf04b890y4f9g3cbb63-python-2.7.11\" =&gt; true isStorePath pkgs.python =&gt; true isStorePath [] || isStorePath 42 || isStorePath {}",
    "sub_results": []
  },
  {
    "url": "/f/lib/toShellVar.html",
    "content": "lib.toShellVar. Translate a Nix value into a shell variable declaration, with proper escaping. The value can be a string (mapped to a regular variable), a list of strings (mapped to a Bash-style array) or an attribute set of strings (mapped to a Bash-style associative array). Note that \"string\" includes string-coercible values like paths or derivations. Strings are translated into POSIX sh-compatible code; lists and attribute sets assume a shell that understands Bash syntax (e.g. Bash or ZSH). Example. '' ${toShellVar \"foo\" \"some string\"} [[ \"$foo\" == \"some string\" ]] '' Type. string -> (string | listOf string | attrsOf string) -> string Arguments. [name] [value] Edit source. Noogle also knows. Aliases. lib.strings.toShellVar.",
    "word_count": 112,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toShellVar"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 77
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 90
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 102
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toShellVar. Translate a Nix value into a shell variable declaration, with proper escaping. The value can be a string (mapped to a regular variable), a list of strings (mapped to a Bash-style array) or an attribute set of strings (mapped to a Bash-style associative array). Note that \"string\" includes string-coercible values like paths or derivations. Strings are translated into POSIX sh-compatible code; lists and attribute sets assume a shell that understands Bash syntax (e.g. Bash or ZSH). Example. '' ${toShellVar \"foo\" \"some string\"} [[ \"$foo\" == \"some string\" ]] '' Type. string -&gt; (string | listOf string | attrsOf string) -&gt; string Arguments. [name] [value] Edit source. Noogle also knows. Aliases. lib.strings.toShellVar.",
    "raw_url": "/f/lib/toShellVar.html",
    "excerpt": "lib.toShellVar. Translate a Nix value into a shell variable declaration, with proper escaping. The value can be a string (mapped to a regular variable), a list of strings (mapped to",
    "sub_results": []
  },
  {
    "url": "/f/lib/reverseList.html",
    "content": "lib.reverseList. Reverse the order of the elements of a list. Example. reverseList [ \"b\" \"o\" \"j\" ] => [ \"j\" \"o\" \"b\" ] Type. reverseList :: [a] -> [a] Arguments. [xs] Edit source. Noogle also knows. Aliases. lib.lists.reverseList.",
    "word_count": 38,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.reverseList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 10
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 29
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.reverseList. Reverse the order of the elements of a list. Example. reverseList [ \"b\" \"o\" \"j\" ] =&gt; [ \"j\" \"o\" \"b\" ] Type. reverseList :: [a] -&gt; [a] Arguments. [xs] Edit source. Noogle also knows. Aliases. lib.lists.reverseList.",
    "raw_url": "/f/lib/reverseList.html",
    "excerpt": "lib.reverseList. Reverse the order of the elements of a list. Example. reverseList [ \"b\" \"o\" \"j\" ] =&gt; [ \"j\" \"o\" \"b\" ] Type. reverseList :: [a] -&gt; [a] Arguments.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkOption.html",
    "content": "lib.mkOption. Creates an Option attribute set. mkOption accepts an attribute set with the following keys: All keys default to null when not given. Example. mkOption { } // => { _type = \"option\"; } mkOption { default = \"foo\"; } // => { _type = \"option\"; default = \"foo\"; } Arguments. Edit source. Noogle also knows. Aliases. lib.options.mkOption.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkOption"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 23
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 50
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkOption. Creates an Option attribute set. mkOption accepts an attribute set with the following keys: All keys default to null when not given. Example. mkOption { } // =&gt; { _type = \"option\"; } mkOption { default = \"foo\"; } // =&gt; { _type = \"option\"; default = \"foo\"; } Arguments. Edit source. Noogle also knows. Aliases. lib.options.mkOption.",
    "raw_url": "/f/lib/mkOption.html",
    "excerpt": "lib.mkOption. Creates an Option attribute set. mkOption accepts an attribute set with the following keys: All keys default to null when not given. Example. mkOption { } // =&gt; {",
    "sub_results": []
  },
  {
    "url": "/f/lib/mergeUniqueOption.html",
    "content": "lib.mergeUniqueOption. Edit source. Noogle also knows. Aliases. lib.options.mergeUniqueOption.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mergeUniqueOption"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mergeUniqueOption. Edit source. Noogle also knows. Aliases. lib.options.mergeUniqueOption.",
    "raw_url": "/f/lib/mergeUniqueOption.html",
    "excerpt": "lib.mergeUniqueOption. Edit source. Noogle also knows. Aliases. lib.options.mergeUniqueOption.",
    "sub_results": []
  },
  {
    "url": "/f/lib/sub.html",
    "content": "lib.sub Primop. Takes 2 arguments. e1, e2. Return the difference between the numbers e1 and e2. Noogle also knows. Aliases. builtins.sub. lib.trivial.sub.",
    "word_count": 22,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sub Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sub Primop. Takes 2 arguments. e1, e2. Return the difference between the numbers e1 and e2. Noogle also knows. Aliases. builtins.sub. lib.trivial.sub.",
    "raw_url": "/f/lib/sub.html",
    "excerpt": "lib.sub Primop. Takes 2 arguments. e1, e2. Return the difference between the numbers e1 and e2. Noogle also knows. Aliases. builtins.sub. lib.trivial.sub.",
    "sub_results": []
  },
  {
    "url": "/f/lib/last.html",
    "content": "lib.last. Return the last element of a list. This function throws an error if the list is empty. Example. last [ 1 2 3 ] => 3 Type. last :: [a] -> a Arguments. [list] Edit source. Noogle also knows. Aliases. lib.lists.last.",
    "word_count": 42,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.last"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 18
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 27
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 33
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.last. Return the last element of a list. This function throws an error if the list is empty. Example. last [ 1 2 3 ] =&gt; 3 Type. last :: [a] -&gt; a Arguments. [list] Edit source. Noogle also knows. Aliases. lib.lists.last.",
    "raw_url": "/f/lib/last.html",
    "excerpt": "lib.last. Return the last element of a list. This function throws an error if the list is empty. Example. last [ 1 2 3 ] =&gt; 3 Type. last ::",
    "sub_results": []
  },
  {
    "url": "/f/lib/sourceByRegex.html",
    "content": "lib.sourceByRegex. Filter sources by a list of regular expressions. Example. src = sourceByRegex ./my-subproject [\".*\\.py$\" \"^database.sql$\"] Arguments. [src] [regexes] Edit source. Noogle also knows. Aliases. lib.sources.sourceByRegex.",
    "word_count": 26,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.sourceByRegex"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 9
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 16
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.sourceByRegex. Filter sources by a list of regular expressions. Example. src = sourceByRegex ./my-subproject [\".*\\.py$\" \"^database.sql$\"] Arguments. [src] [regexes] Edit source. Noogle also knows. Aliases. lib.sources.sourceByRegex.",
    "raw_url": "/f/lib/sourceByRegex.html",
    "excerpt": "lib.sourceByRegex. Filter sources by a list of regular expressions. Example. src = sourceByRegex ./my-subproject [\".*\\.py$\" \"^database.sql$\"] Arguments. [src] [regexes] Edit source. Noogle also knows. Aliases. lib.sources.sourceByRegex.",
    "sub_results": []
  },
  {
    "url": "/f/lib/makeScope.html",
    "content": "lib.makeScope. Make a set of packages with a common scope. All packages called with the provided callPackage will be evaluated with the same arguments. Any package in the set may depend on any other. The overrideScope' function allows subsequent modification of the package set in a consistent way, i.e. all packages in the set will be called with the overridden packages. The package sets may be hierarchical: the packages in the set are called with the scope provided by newScope and the set provides a newScope attribute which can form the parent scope for later package sets. Type. makeScope :: (AttrSet -> ((AttrSet -> a) | Path) -> AttrSet -> a) -> (AttrSet -> AttrSet) -> AttrSet Arguments. [newScope] [f] Edit source. Noogle also knows. Aliases. lib.customisation.makeScope.",
    "word_count": 127,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.makeScope"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 97
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 117
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.makeScope. Make a set of packages with a common scope. All packages called with the provided callPackage will be evaluated with the same arguments. Any package in the set may depend on any other. The overrideScope' function allows subsequent modification of the package set in a consistent way, i.e. all packages in the set will be called with the overridden packages. The package sets may be hierarchical: the packages in the set are called with the scope provided by newScope and the set provides a newScope attribute which can form the parent scope for later package sets. Type. makeScope :: (AttrSet -&gt; ((AttrSet -&gt; a) | Path) -&gt; AttrSet -&gt; a) -&gt; (AttrSet -&gt; AttrSet) -&gt; AttrSet Arguments. [newScope] [f] Edit source. Noogle also knows. Aliases. lib.customisation.makeScope.",
    "raw_url": "/f/lib/makeScope.html",
    "excerpt": "lib.makeScope. Make a set of packages with a common scope. All packages called with the provided callPackage will be evaluated with the same arguments. Any package in the set may",
    "sub_results": []
  },
  {
    "url": "/f/lib/addMetaAttrs.html",
    "content": "lib.addMetaAttrs. Add to or override the meta attributes of the given derivation. Example. addMetaAttrs {description = \"Bla blah\";} somePkg Arguments. [newAttrs] [drv] Edit source. Noogle also knows. Aliases. lib.meta.addMetaAttrs.",
    "word_count": 29,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.addMetaAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 12
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 19
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.addMetaAttrs. Add to or override the meta attributes of the given derivation. Example. addMetaAttrs {description = \"Bla blah\";} somePkg Arguments. [newAttrs] [drv] Edit source. Noogle also knows. Aliases. lib.meta.addMetaAttrs.",
    "raw_url": "/f/lib/addMetaAttrs.html",
    "excerpt": "lib.addMetaAttrs. Add to or override the meta attributes of the given derivation. Example. addMetaAttrs {description = \"Bla blah\";} somePkg Arguments. [newAttrs] [drv] Edit source. Noogle also knows. Aliases. lib.meta.addMetaAttrs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/deepSeq.html",
    "content": "lib.deepSeq Primop. Takes 2 arguments. e1, e2. This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are also evaluated recursively. Noogle also knows. Aliases. builtins.deepSeq. lib.trivial.deepSeq.",
    "word_count": 39,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.deepSeq Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.deepSeq Primop. Takes 2 arguments. e1, e2. This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are also evaluated recursively. Noogle also knows. Aliases. builtins.deepSeq. lib.trivial.deepSeq.",
    "raw_url": "/f/lib/deepSeq.html",
    "excerpt": "lib.deepSeq Primop. Takes 2 arguments. e1, e2. This is like seq e1 e2, except that e1 is evaluated deeply: if it’s a list or set, its elements or attributes are",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkRemovedOptionModule.html",
    "content": "lib.mkRemovedOptionModule. Return a module that causes a warning to be shown if the specified option is defined. For example, mkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"\" causes a assertion if the user defines boot.loader.grub.bootDevice. replacementInstructions is a string that provides instructions on how to achieve the same functionality without the removed option, or alternatively a reasoning why the functionality is not needed. replacementInstructions SHOULD be provided! Arguments. [optionName] [replacementInstructions] Edit source. Noogle also knows. Aliases. lib.modules.mkRemovedOptionModule.",
    "word_count": 77,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkRemovedOptionModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 67
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkRemovedOptionModule. Return a module that causes a warning to be shown if the specified option is defined. For example, mkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"\" causes a assertion if the user defines boot.loader.grub.bootDevice. replacementInstructions is a string that provides instructions on how to achieve the same functionality without the removed option, or alternatively a reasoning why the functionality is not needed. replacementInstructions SHOULD be provided! Arguments. [optionName] [replacementInstructions] Edit source. Noogle also knows. Aliases. lib.modules.mkRemovedOptionModule.",
    "raw_url": "/f/lib/mkRemovedOptionModule.html",
    "excerpt": "lib.mkRemovedOptionModule. Return a module that causes a warning to be shown if the specified option is defined. For example, mkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"\" causes a assertion",
    "sub_results": []
  },
  {
    "url": "/f/lib/elem.html",
    "content": "lib.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. builtins.elem. lib.lists.elem. lib.strings.elem.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.elem Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. builtins.elem. lib.lists.elem. lib.strings.elem.",
    "raw_url": "/f/lib/elem.html",
    "excerpt": "lib.elem Primop. Takes 2 arguments. x, xs. Return true if a value equal to x occurs in the list xs, and false otherwise. Noogle also knows. Aliases. builtins.elem. lib.lists.elem. lib.strings.elem.",
    "sub_results": []
  },
  {
    "url": "/f/lib/optionAttrSetToDocList.html",
    "content": "lib.optionAttrSetToDocList. Noogle also knows. Aliases. lib.options.optionAttrSetToDocList.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.optionAttrSetToDocList"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.optionAttrSetToDocList. Noogle also knows. Aliases. lib.options.optionAttrSetToDocList.",
    "raw_url": "/f/lib/optionAttrSetToDocList.html",
    "excerpt": "lib.optionAttrSetToDocList. Noogle also knows. Aliases. lib.options.optionAttrSetToDocList.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkRenamedOptionModule.html",
    "content": "lib.modules.mkRenamedOptionModule. Return a module that causes a warning to be shown if the specified \"from\" option is defined; the defined value is however forwarded to the \"to\" option. This can be used to rename options while providing backward compatibility. For example, mkRenamedOptionModule [ \"boot\" \"copyKernels\" ] [ \"boot\" \"loader\" \"grub\" \"copyKernels\" ] forwards any definitions of boot.copyKernels to boot.loader.grub.copyKernels while printing a warning. This also copies over the priority from the aliased option to the non-aliased option. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.mkRenamedOptionModule.",
    "word_count": 87,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkRenamedOptionModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 77
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkRenamedOptionModule. Return a module that causes a warning to be shown if the specified \"from\" option is defined; the defined value is however forwarded to the \"to\" option. This can be used to rename options while providing backward compatibility. For example, mkRenamedOptionModule [ \"boot\" \"copyKernels\" ] [ \"boot\" \"loader\" \"grub\" \"copyKernels\" ] forwards any definitions of boot.copyKernels to boot.loader.grub.copyKernels while printing a warning. This also copies over the priority from the aliased option to the non-aliased option. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.mkRenamedOptionModule.",
    "raw_url": "/f/lib/modules/mkRenamedOptionModule.html",
    "excerpt": "lib.modules.mkRenamedOptionModule. Return a module that causes a warning to be shown if the specified \"from\" option is defined; the defined value is however forwarded to the \"to\" option. This can",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/evalOptionValue.html",
    "content": "lib.modules.evalOptionValue. Merge all the definitions of an option to produce the final config value. Arguments. [loc] [opt] [defs] Edit source. Noogle also knows. Aliases. lib.evalOptionValue.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.evalOptionValue"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 14
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.evalOptionValue. Merge all the definitions of an option to produce the final config value. Arguments. [loc] [opt] [defs] Edit source. Noogle also knows. Aliases. lib.evalOptionValue.",
    "raw_url": "/f/lib/modules/evalOptionValue.html",
    "excerpt": "lib.modules.evalOptionValue. Merge all the definitions of an option to produce the final config value. Arguments. [loc] [opt] [defs] Edit source. Noogle also knows. Aliases. lib.evalOptionValue.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkAliasDefinitions.html",
    "content": "lib.modules.mkAliasDefinitions. Noogle also knows. Aliases. lib.mkAliasDefinitions.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkAliasDefinitions"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkAliasDefinitions. Noogle also knows. Aliases. lib.mkAliasDefinitions.",
    "raw_url": "/f/lib/modules/mkAliasDefinitions.html",
    "excerpt": "lib.modules.mkAliasDefinitions. Noogle also knows. Aliases. lib.mkAliasDefinitions.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkAliasOptionModule.html",
    "content": "lib.modules.mkAliasOptionModule. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.mkAliasOptionModule.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkAliasOptionModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkAliasOptionModule. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.mkAliasOptionModule.",
    "raw_url": "/f/lib/modules/mkAliasOptionModule.html",
    "excerpt": "lib.modules.mkAliasOptionModule. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.mkAliasOptionModule.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mergeAttrDefinitionsWithPrio.html",
    "content": "lib.modules.mergeAttrDefinitionsWithPrio. Merge an option's definitions in a way that preserves the priority of the individual attributes in the option value. This does not account for all option semantics, such as readOnly. Type. option -> attrsOf { highestPrio, value } Arguments. [opt] Edit source.",
    "word_count": 43,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mergeAttrDefinitionsWithPrio"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 39
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mergeAttrDefinitionsWithPrio. Merge an option's definitions in a way that preserves the priority of the individual attributes in the option value. This does not account for all option semantics, such as readOnly. Type. option -&gt; attrsOf { highestPrio, value } Arguments. [opt] Edit source.",
    "raw_url": "/f/lib/modules/mergeAttrDefinitionsWithPrio.html",
    "excerpt": "lib.modules.mergeAttrDefinitionsWithPrio. Merge an option's definitions in a way that preserves the priority of the individual attributes in the option value. This does not account for all option semantics, such as",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/unifyModuleSyntax.html",
    "content": "lib.modules.unifyModuleSyntax. Massage a module into canonical form, that is, a set consisting of ‘options’, ‘config’ and ‘imports’ attributes. Arguments. [file] [key] [m] Edit source. Noogle also knows. Aliases. lib.unifyModuleSyntax.",
    "word_count": 29,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.unifyModuleSyntax"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 18
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.unifyModuleSyntax. Massage a module into canonical form, that is, a set consisting of ‘options’, ‘config’ and ‘imports’ attributes. Arguments. [file] [key] [m] Edit source. Noogle also knows. Aliases. lib.unifyModuleSyntax.",
    "raw_url": "/f/lib/modules/unifyModuleSyntax.html",
    "excerpt": "lib.modules.unifyModuleSyntax. Massage a module into canonical form, that is, a set consisting of ‘options’, ‘config’ and ‘imports’ attributes. Arguments. [file] [key] [m] Edit source. Noogle also knows. Aliases. lib.unifyModuleSyntax.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/evalModules.html",
    "content": "lib.modules.evalModules. See https://nixos.org/manual/nixpkgs/unstable/#module-system-lib-evalModules or file://./../doc/module-system/module-system.chapter.md !!! Please think twice before adding to this argument list! The more that is specified here instead of in the modules themselves the harder it is to transparently move a set of modules to be a submodule of another config (as the proper arguments need to be replicated at each call to evalModules) and the less declarative the module set is. Arguments. Edit source. Noogle also knows. Aliases. lib.evalModules.",
    "word_count": 74,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.evalModules"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 66
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.evalModules. See https://nixos.org/manual/nixpkgs/unstable/#module-system-lib-evalModules or file://./../doc/module-system/module-system.chapter.md !!! Please think twice before adding to this argument list! The more that is specified here instead of in the modules themselves the harder it is to transparently move a set of modules to be a submodule of another config (as the proper arguments need to be replicated at each call to evalModules) and the less declarative the module set is. Arguments. Edit source. Noogle also knows. Aliases. lib.evalModules.",
    "raw_url": "/f/lib/modules/evalModules.html",
    "excerpt": "lib.modules.evalModules. See https://nixos.org/manual/nixpkgs/unstable/#module-system-lib-evalModules or file://./../doc/module-system/module-system.chapter.md !!! Please think twice before adding to this argument list! The more that is specified here instead of in the modules themselves the harder it",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkMergedOptionModule.html",
    "content": "lib.modules.mkMergedOptionModule. Return a module that causes a warning to be shown if any of the \"from\" option is defined; the defined values can be used in the \"mergeFn\" to set the \"to\" value. This function can be used to merge multiple options into one that has a different type. \"mergeFn\" takes the module \"config\" as a parameter and must return a value of \"to\" option type. mkMergedOptionModule [ [ \"a\" \"b\" \"c\" ] [ \"d\" \"e\" \"f\" ] ] [ \"x\" \"y\" \"z\" ] (config: let value = p: getAttrFromPath p config; in if (value [ \"a\" \"b\" \"c\" ]) == true then \"foo\" else if (value [ \"d\" \"e\" \"f\" ]) == true then \"bar\" else \"baz\"). options.a.b.c is a removed boolean option. options.d.e.f is a removed boolean option. options.x.y.z is a new str option that combines a.b.c and d.e.f functionality This show a warning if any a.b.c or d.e.f is set, and set the value of x.y.z to the result of the merge function. Arguments. [from] [to] [mergeFn] Edit source. Noogle also knows. Aliases. lib.mkMergedOptionModule.",
    "word_count": 177,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkMergedOptionModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 166
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkMergedOptionModule. Return a module that causes a warning to be shown if any of the \"from\" option is defined; the defined values can be used in the \"mergeFn\" to set the \"to\" value. This function can be used to merge multiple options into one that has a different type. \"mergeFn\" takes the module \"config\" as a parameter and must return a value of \"to\" option type. mkMergedOptionModule [ [ \"a\" \"b\" \"c\" ] [ \"d\" \"e\" \"f\" ] ] [ \"x\" \"y\" \"z\" ] (config: let value = p: getAttrFromPath p config; in if (value [ \"a\" \"b\" \"c\" ]) == true then \"foo\" else if (value [ \"d\" \"e\" \"f\" ]) == true then \"bar\" else \"baz\"). options.a.b.c is a removed boolean option. options.d.e.f is a removed boolean option. options.x.y.z is a new str option that combines a.b.c and d.e.f functionality This show a warning if any a.b.c or d.e.f is set, and set the value of x.y.z to the result of the merge function. Arguments. [from] [to] [mergeFn] Edit source. Noogle also knows. Aliases. lib.mkMergedOptionModule.",
    "raw_url": "/f/lib/modules/mkMergedOptionModule.html",
    "excerpt": "lib.modules.mkMergedOptionModule. Return a module that causes a warning to be shown if any of the \"from\" option is defined; the defined values can be used in the \"mergeFn\" to set",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/fixMergeModules.html",
    "content": "lib.modules.fixMergeModules. Compatibility. Arguments. [modules] [args] Edit source. Noogle also knows. Aliases. lib.fixMergeModules.",
    "word_count": 12,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.fixMergeModules"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 2
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.fixMergeModules. Compatibility. Arguments. [modules] [args] Edit source. Noogle also knows. Aliases. lib.fixMergeModules.",
    "raw_url": "/f/lib/modules/fixMergeModules.html",
    "excerpt": "lib.modules.fixMergeModules. Compatibility. Arguments. [modules] [args] Edit source. Noogle also knows. Aliases. lib.fixMergeModules.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkAliasAndWrapDefinitions.html",
    "content": "lib.modules.mkAliasAndWrapDefinitions. Edit source. Noogle also knows. Aliases. lib.mkAliasAndWrapDefinitions.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkAliasAndWrapDefinitions"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkAliasAndWrapDefinitions. Edit source. Noogle also knows. Aliases. lib.mkAliasAndWrapDefinitions.",
    "raw_url": "/f/lib/modules/mkAliasAndWrapDefinitions.html",
    "excerpt": "lib.modules.mkAliasAndWrapDefinitions. Edit source. Noogle also knows. Aliases. lib.mkAliasAndWrapDefinitions.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkForce.html",
    "content": "lib.modules.mkForce. Noogle also knows. Aliases. lib.mkForce.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkForce"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkForce. Noogle also knows. Aliases. lib.mkForce.",
    "raw_url": "/f/lib/modules/mkForce.html",
    "excerpt": "lib.modules.mkForce. Noogle also knows. Aliases. lib.mkForce.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mergeDefinitions.html",
    "content": "lib.modules.mergeDefinitions. Edit source. Noogle also knows. Aliases. lib.mergeDefinitions.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mergeDefinitions"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mergeDefinitions. Edit source. Noogle also knows. Aliases. lib.mergeDefinitions.",
    "raw_url": "/f/lib/modules/mergeDefinitions.html",
    "excerpt": "lib.modules.mergeDefinitions. Edit source. Noogle also knows. Aliases. lib.mergeDefinitions.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkAfter.html",
    "content": "lib.modules.mkAfter. Noogle also knows. Aliases. lib.mkAfter.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkAfter"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkAfter. Noogle also knows. Aliases. lib.mkAfter.",
    "raw_url": "/f/lib/modules/mkAfter.html",
    "excerpt": "lib.modules.mkAfter. Noogle also knows. Aliases. lib.mkAfter.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkOverride.html",
    "content": "lib.modules.mkOverride. Edit source. Noogle also knows. Aliases. lib.mkOverride.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkOverride"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkOverride. Edit source. Noogle also knows. Aliases. lib.mkOverride.",
    "raw_url": "/f/lib/modules/mkOverride.html",
    "excerpt": "lib.modules.mkOverride. Edit source. Noogle also knows. Aliases. lib.mkOverride.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/applyModuleArgsIfFunction.html",
    "content": "lib.modules.applyModuleArgsIfFunction. Edit source. Noogle also knows. Aliases. lib.applyModuleArgsIfFunction.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.applyModuleArgsIfFunction"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.applyModuleArgsIfFunction. Edit source. Noogle also knows. Aliases. lib.applyModuleArgsIfFunction.",
    "raw_url": "/f/lib/modules/applyModuleArgsIfFunction.html",
    "excerpt": "lib.modules.applyModuleArgsIfFunction. Edit source. Noogle also knows. Aliases. lib.applyModuleArgsIfFunction.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/filterOverrides'.html",
    "content": "lib.modules.filterOverrides' (Prime). Edit source.",
    "word_count": 4,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.filterOverrides' (Prime)"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.filterOverrides' (Prime). Edit source.",
    "raw_url": "/f/lib/modules/filterOverrides'.html",
    "excerpt": "lib.modules.filterOverrides' (Prime). Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mergeModules'.html",
    "content": "lib.modules.mergeModules' (Prime). Edit source. Noogle also knows. Aliases. lib.mergeModules'",
    "word_count": 9,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mergeModules' (Prime)"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mergeModules' (Prime). Edit source. Noogle also knows. Aliases. lib.mergeModules'",
    "raw_url": "/f/lib/modules/mergeModules'.html",
    "excerpt": "lib.modules.mergeModules' (Prime). Edit source. Noogle also knows. Aliases. lib.mergeModules'",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkDefault.html",
    "content": "lib.modules.mkDefault. Noogle also knows. Aliases. lib.mkDefault.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkDefault"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkDefault. Noogle also knows. Aliases. lib.mkDefault.",
    "raw_url": "/f/lib/modules/mkDefault.html",
    "excerpt": "lib.modules.mkDefault. Noogle also knows. Aliases. lib.mkDefault.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkDerivedConfig.html",
    "content": "lib.modules.mkDerivedConfig. mkDerivedConfig : Option a -> (a -> Definition b) -> Definition b Create config definitions with the same priority as the definition of another option. This should be used for option definitions where one option sets the value of another as a convenience. For instance a config file could be set with a text or source option, where text translates to a source value using mkDerivedConfig options.text (pkgs.writeText \"filename.conf\"). It takes care of setting the right priority using mkOverride. Arguments. [opt] [f] Edit source. Noogle also knows. Aliases. lib.mkDerivedConfig.",
    "word_count": 90,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkDerivedConfig"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 80
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkDerivedConfig. mkDerivedConfig : Option a -&gt; (a -&gt; Definition b) -&gt; Definition b Create config definitions with the same priority as the definition of another option. This should be used for option definitions where one option sets the value of another as a convenience. For instance a config file could be set with a text or source option, where text translates to a source value using mkDerivedConfig options.text (pkgs.writeText \"filename.conf\"). It takes care of setting the right priority using mkOverride. Arguments. [opt] [f] Edit source. Noogle also knows. Aliases. lib.mkDerivedConfig.",
    "raw_url": "/f/lib/modules/mkDerivedConfig.html",
    "excerpt": "lib.modules.mkDerivedConfig. mkDerivedConfig : Option a -&gt; (a -&gt; Definition b) -&gt; Definition b Create config definitions with the same priority as the definition of another option. This should be used",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/filterOverrides.html",
    "content": "lib.modules.filterOverrides. Given a list of config values, process the mkOverride properties, that is, return the values that have the highest (that is, numerically lowest) priority, and strip the mkOverride properties. For example, [ { file = \"/1\"; value = mkOverride 10 \"a\"; } { file = \"/2\"; value = mkOverride 20 \"b\"; } { file = \"/3\"; value = \"z\"; } { file = \"/4\"; value = mkOverride 10 \"d\"; } ] yields [ { file = \"/1\"; value = \"a\"; } { file = \"/4\"; value = \"d\"; } ] Note that \"z\" has the default priority 100. Arguments. [defs] Edit source. Noogle also knows. Aliases. lib.filterOverrides.",
    "word_count": 108,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.filterOverrides"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 99
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.filterOverrides. Given a list of config values, process the mkOverride properties, that is, return the values that have the highest (that is, numerically lowest) priority, and strip the mkOverride properties. For example, [ { file = \"/1\"; value = mkOverride 10 \"a\"; } { file = \"/2\"; value = mkOverride 20 \"b\"; } { file = \"/3\"; value = \"z\"; } { file = \"/4\"; value = mkOverride 10 \"d\"; } ] yields [ { file = \"/1\"; value = \"a\"; } { file = \"/4\"; value = \"d\"; } ] Note that \"z\" has the default priority 100. Arguments. [defs] Edit source. Noogle also knows. Aliases. lib.filterOverrides.",
    "raw_url": "/f/lib/modules/filterOverrides.html",
    "excerpt": "lib.modules.filterOverrides. Given a list of config values, process the mkOverride properties, that is, return the values that have the highest (that is, numerically lowest) priority, and strip the mkOverride properties.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mergeModules.html",
    "content": "lib.modules.mergeModules. Merge a list of modules. This will recurse over the option declarations in all modules, combining them into a single set. At the same time, for each option declaration, it will merge the corresponding option definitions in all machines, returning them in the ‘value’ attribute of each option. This returns a set like { A recursive set of options along with their final values. matchedOptions = { foo = { _type = \"option\"; value = \"option value of foo\"; ... }; bar.baz = { _type = \"option\"; value = \"option value of bar.baz\"; ... }; ... }; A list of definitions that weren't matched by any option. unmatchedDefns = [ { file = \"file.nix\"; prefix = [ \"qux\" ]; value = \"qux\"; } ... ]; } Arguments. [prefix] [modules] Edit source. Noogle also knows. Aliases. lib.mergeModules.",
    "word_count": 137,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mergeModules"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "a-recursive-set-of-options-along-with-their-final-values",
        "text": "A recursive set of options along with their final values",
        "location": 55
      },
      {
        "element": "h2",
        "id": "a-list-of-definitions-that-werent-matched-by-any-option",
        "text": "A list of definitions that weren't matched by any option",
        "location": 98
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 127
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mergeModules. Merge a list of modules. This will recurse over the option declarations in all modules, combining them into a single set. At the same time, for each option declaration, it will merge the corresponding option definitions in all machines, returning them in the ‘value’ attribute of each option. This returns a set like { A recursive set of options along with their final values. matchedOptions = { foo = { _type = \"option\"; value = \"option value of foo\"; ... }; bar.baz = { _type = \"option\"; value = \"option value of bar.baz\"; ... }; ... }; A list of definitions that weren't matched by any option. unmatchedDefns = [ { file = \"file.nix\"; prefix = [ \"qux\" ]; value = \"qux\"; } ... ]; } Arguments. [prefix] [modules] Edit source. Noogle also knows. Aliases. lib.mergeModules.",
    "raw_url": "/f/lib/modules/mergeModules.html",
    "excerpt": "lib.modules.mergeModules. Merge a list of modules. This will recurse over the option declarations in all modules, combining them into a single set. At the same time, for each option declaration,",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/doRename.html",
    "content": "lib.modules.doRename. Edit source. Noogle also knows. Aliases. lib.doRename.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.doRename"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.doRename. Edit source. Noogle also knows. Aliases. lib.doRename.",
    "raw_url": "/f/lib/modules/doRename.html",
    "excerpt": "lib.modules.doRename. Edit source. Noogle also knows. Aliases. lib.doRename.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/importJSON.html",
    "content": "lib.modules.importJSON. Reads a JSON file. Type. importJSON :: path -> any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importJSON. lib.trivial.importJSON.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.importJSON"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 5
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.importJSON. Reads a JSON file. Type. importJSON :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importJSON. lib.trivial.importJSON.",
    "raw_url": "/f/lib/modules/importJSON.html",
    "excerpt": "lib.modules.importJSON. Reads a JSON file. Type. importJSON :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importJSON. lib.trivial.importJSON.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/pushDownProperties.html",
    "content": "lib.modules.pushDownProperties. Given a config set, expand mkMerge properties, and push down the other properties into the children. The result is a list of config sets that do not have properties at top-level. For example, mkMerge [ { boot = set1; } (mkIf cond { boot = set2; services = set3; }) ] is transformed into [ { boot = set1; } { boot = mkIf cond set2; services = mkIf cond set3; } ]. This transform is the critical step that allows mkIf conditions to refer to the full configuration without creating an infinite recursion. Arguments. [cfg] Edit source. Noogle also knows. Aliases. lib.pushDownProperties.",
    "word_count": 104,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.pushDownProperties"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 95
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.pushDownProperties. Given a config set, expand mkMerge properties, and push down the other properties into the children. The result is a list of config sets that do not have properties at top-level. For example, mkMerge [ { boot = set1; } (mkIf cond { boot = set2; services = set3; }) ] is transformed into [ { boot = set1; } { boot = mkIf cond set2; services = mkIf cond set3; } ]. This transform is the critical step that allows mkIf conditions to refer to the full configuration without creating an infinite recursion. Arguments. [cfg] Edit source. Noogle also knows. Aliases. lib.pushDownProperties.",
    "raw_url": "/f/lib/modules/pushDownProperties.html",
    "excerpt": "lib.modules.pushDownProperties. Given a config set, expand mkMerge properties, and push down the other properties into the children. The result is a list of config sets that do not have properties",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/dischargeProperties.html",
    "content": "lib.modules.dischargeProperties. Given a config value, expand mkMerge properties, and discharge any mkIf conditions. That is, this is the place where mkIf conditions are actually evaluated. The result is a list of config values. For example, ‘mkIf false x’ yields ‘[]’, ‘mkIf true x’ yields ‘[x]’, and mkMerge [ 1 (mkIf true 2) (mkIf true (mkIf false 3)) ] yields ‘[ 1 2 ]’. Arguments. [def] Edit source. Noogle also knows. Aliases. lib.dischargeProperties.",
    "word_count": 72,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.dischargeProperties"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 63
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.dischargeProperties. Given a config value, expand mkMerge properties, and discharge any mkIf conditions. That is, this is the place where mkIf conditions are actually evaluated. The result is a list of config values. For example, ‘mkIf false x’ yields ‘[]’, ‘mkIf true x’ yields ‘[x]’, and mkMerge [ 1 (mkIf true 2) (mkIf true (mkIf false 3)) ] yields ‘[ 1 2 ]’. Arguments. [def] Edit source. Noogle also knows. Aliases. lib.dischargeProperties.",
    "raw_url": "/f/lib/modules/dischargeProperties.html",
    "excerpt": "lib.modules.dischargeProperties. Given a config value, expand mkMerge properties, and discharge any mkIf conditions. That is, this is the place where mkIf conditions are actually evaluated. The result is a list",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkAssert.html",
    "content": "lib.modules.mkAssert. Edit source. Noogle also knows. Aliases. lib.mkAssert.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkAssert"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkAssert. Edit source. Noogle also knows. Aliases. lib.mkAssert.",
    "raw_url": "/f/lib/modules/mkAssert.html",
    "excerpt": "lib.modules.mkAssert. Edit source. Noogle also knows. Aliases. lib.mkAssert.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/sortProperties.html",
    "content": "lib.modules.sortProperties. Sort a list of properties. The sort priority of a property is defaultOrderPriority by default, but can be overridden by wrapping the property using mkOrder. Arguments. [defs] Edit source. Noogle also knows. Aliases. lib.sortProperties.",
    "word_count": 35,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.sortProperties"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 26
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.sortProperties. Sort a list of properties. The sort priority of a property is defaultOrderPriority by default, but can be overridden by wrapping the property using mkOrder. Arguments. [defs] Edit source. Noogle also knows. Aliases. lib.sortProperties.",
    "raw_url": "/f/lib/modules/sortProperties.html",
    "excerpt": "lib.modules.sortProperties. Sort a list of properties. The sort priority of a property is defaultOrderPriority by default, but can be overridden by wrapping the property using mkOrder. Arguments. [defs] Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkOrder.html",
    "content": "lib.modules.mkOrder. Edit source. Noogle also knows. Aliases. lib.mkOrder.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkOrder"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkOrder. Edit source. Noogle also knows. Aliases. lib.mkOrder.",
    "raw_url": "/f/lib/modules/mkOrder.html",
    "excerpt": "lib.modules.mkOrder. Edit source. Noogle also knows. Aliases. lib.mkOrder.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkAliasOptionModuleMD.html",
    "content": "lib.modules.mkAliasOptionModuleMD. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.mkAliasOptionModuleMD.",
    "word_count": 18,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkAliasOptionModuleMD"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 8
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkAliasOptionModuleMD. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.mkAliasOptionModuleMD.",
    "raw_url": "/f/lib/modules/mkAliasOptionModuleMD.html",
    "excerpt": "lib.modules.mkAliasOptionModuleMD. Like ‘mkRenamedOptionModule’, but doesn't show a warning. Arguments. [from] [to] Edit source. Noogle also knows. Aliases. lib.mkAliasOptionModuleMD.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/setDefaultModuleLocation.html",
    "content": "lib.modules.setDefaultModuleLocation. Wrap a module with a default location for reporting errors. Arguments. [file] [m] Edit source. Noogle also knows. Aliases. lib.setDefaultModuleLocation.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.setDefaultModuleLocation"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.setDefaultModuleLocation. Wrap a module with a default location for reporting errors. Arguments. [file] [m] Edit source. Noogle also knows. Aliases. lib.setDefaultModuleLocation.",
    "raw_url": "/f/lib/modules/setDefaultModuleLocation.html",
    "excerpt": "lib.modules.setDefaultModuleLocation. Wrap a module with a default location for reporting errors. Arguments. [file] [m] Edit source. Noogle also knows. Aliases. lib.setDefaultModuleLocation.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkAliasIfDef.html",
    "content": "lib.modules.mkAliasIfDef. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkAliasIfDef"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkAliasIfDef. Edit source.",
    "raw_url": "/f/lib/modules/mkAliasIfDef.html",
    "excerpt": "lib.modules.mkAliasIfDef. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/fixupOptionType.html",
    "content": "lib.modules.fixupOptionType. Edit source. Noogle also knows. Aliases. lib.fixupOptionType.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.fixupOptionType"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.fixupOptionType. Edit source. Noogle also knows. Aliases. lib.fixupOptionType.",
    "raw_url": "/f/lib/modules/fixupOptionType.html",
    "excerpt": "lib.modules.fixupOptionType. Edit source. Noogle also knows. Aliases. lib.fixupOptionType.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkOptionDefault.html",
    "content": "lib.modules.mkOptionDefault. Noogle also knows. Aliases. lib.mkOptionDefault.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkOptionDefault"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkOptionDefault. Noogle also knows. Aliases. lib.mkOptionDefault.",
    "raw_url": "/f/lib/modules/mkOptionDefault.html",
    "excerpt": "lib.modules.mkOptionDefault. Noogle also knows. Aliases. lib.mkOptionDefault.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mergeOptionDecls.html",
    "content": "lib.modules.mergeOptionDecls. Merge multiple option declarations into a single declaration. In general, there should be only one declaration of each option. The exception is the ‘options’ attribute, which specifies sub-options. These can be specified multiple times to allow one module to add sub-options to an option declared somewhere else (e.g. multiple modules define sub-options for ‘fileSystems’). 'loc' is the list of attribute names where the option is located. 'opts' is a list of modules. Each module has an options attribute which correspond to the definition of 'loc' in 'opt.file'. Arguments. [loc] [opts] Edit source. Noogle also knows. Aliases. lib.mergeOptionDecls.",
    "word_count": 98,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mergeOptionDecls"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 88
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mergeOptionDecls. Merge multiple option declarations into a single declaration. In general, there should be only one declaration of each option. The exception is the ‘options’ attribute, which specifies sub-options. These can be specified multiple times to allow one module to add sub-options to an option declared somewhere else (e.g. multiple modules define sub-options for ‘fileSystems’). 'loc' is the list of attribute names where the option is located. 'opts' is a list of modules. Each module has an options attribute which correspond to the definition of 'loc' in 'opt.file'. Arguments. [loc] [opts] Edit source. Noogle also knows. Aliases. lib.mergeOptionDecls.",
    "raw_url": "/f/lib/modules/mergeOptionDecls.html",
    "excerpt": "lib.modules.mergeOptionDecls. Merge multiple option declarations into a single declaration. In general, there should be only one declaration of each option. The exception is the ‘options’ attribute, which specifies sub-options. These",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkRenamedOptionModuleWith.html",
    "content": "lib.modules.mkRenamedOptionModuleWith. Edit source. Noogle also knows. Aliases. lib.mkRenamedOptionModuleWith.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkRenamedOptionModuleWith"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkRenamedOptionModuleWith. Edit source. Noogle also knows. Aliases. lib.mkRenamedOptionModuleWith.",
    "raw_url": "/f/lib/modules/mkRenamedOptionModuleWith.html",
    "excerpt": "lib.modules.mkRenamedOptionModuleWith. Edit source. Noogle also knows. Aliases. lib.mkRenamedOptionModuleWith.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkAliasAndWrapDefsWithPriority.html",
    "content": "lib.modules.mkAliasAndWrapDefsWithPriority. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkAliasAndWrapDefsWithPriority"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkAliasAndWrapDefsWithPriority. Edit source.",
    "raw_url": "/f/lib/modules/mkAliasAndWrapDefsWithPriority.html",
    "excerpt": "lib.modules.mkAliasAndWrapDefsWithPriority. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkMerge.html",
    "content": "lib.modules.mkMerge. Edit source. Noogle also knows. Aliases. lib.mkMerge.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkMerge"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkMerge. Edit source. Noogle also knows. Aliases. lib.mkMerge.",
    "raw_url": "/f/lib/modules/mkMerge.html",
    "excerpt": "lib.modules.mkMerge. Edit source. Noogle also knows. Aliases. lib.mkMerge.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/importTOML.html",
    "content": "lib.modules.importTOML. Reads a TOML file. Type. importTOML :: path -> any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importTOML. lib.trivial.importTOML.",
    "word_count": 21,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.importTOML"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 5
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 11
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.importTOML. Reads a TOML file. Type. importTOML :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importTOML. lib.trivial.importTOML.",
    "raw_url": "/f/lib/modules/importTOML.html",
    "excerpt": "lib.modules.importTOML. Reads a TOML file. Type. importTOML :: path -&gt; any Arguments. [path] Edit source. Noogle also knows. Aliases. lib.importTOML. lib.trivial.importTOML.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkImageMediaOverride.html",
    "content": "lib.modules.mkImageMediaOverride. Noogle also knows. Aliases. lib.mkImageMediaOverride.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkImageMediaOverride"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkImageMediaOverride. Noogle also knows. Aliases. lib.mkImageMediaOverride.",
    "raw_url": "/f/lib/modules/mkImageMediaOverride.html",
    "excerpt": "lib.modules.mkImageMediaOverride. Noogle also knows. Aliases. lib.mkImageMediaOverride.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkFixStrictness.html",
    "content": "lib.modules.mkFixStrictness. The identity function For when you need a function that does “nothing”. Type. id :: a -> a Arguments. [x] The value to return. Edit source. Noogle also knows. Aliases. lib.mkFixStrictness.",
    "word_count": 32,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkFixStrictness"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 13
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 19
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkFixStrictness. The identity function For when you need a function that does “nothing”. Type. id :: a -&gt; a Arguments. [x] The value to return. Edit source. Noogle also knows. Aliases. lib.mkFixStrictness.",
    "raw_url": "/f/lib/modules/mkFixStrictness.html",
    "excerpt": "lib.modules.mkFixStrictness. The identity function For when you need a function that does “nothing”. Type. id :: a -&gt; a Arguments. [x] The value to return. Edit source. Noogle also knows.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkChangedOptionModule.html",
    "content": "lib.modules.mkChangedOptionModule. Single \"from\" version of mkMergedOptionModule. Return a module that causes a warning to be shown if the \"from\" option is defined; the defined value can be used in the \"mergeFn\" to set the \"to\" value. This function can be used to change an option into another that has a different type. \"mergeFn\" takes the module \"config\" as a parameter and must return a value of \"to\" option type. mkChangedOptionModule [ \"a\" \"b\" \"c\" ] [ \"x\" \"y\" \"z\" ] (config: let value = getAttrFromPath [ \"a\" \"b\" \"c\" ] config; in if value > 100 then \"high\" else \"normal\"). options.a.b.c is a removed int option. options.x.y.z is a new str option that supersedes a.b.c This show a warning if a.b.c is set, and set the value of x.y.z to the result of the change function. Arguments. [from] [to] [changeFn] Edit source. Noogle also knows. Aliases. lib.mkChangedOptionModule.",
    "word_count": 147,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkChangedOptionModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 136
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkChangedOptionModule. Single \"from\" version of mkMergedOptionModule. Return a module that causes a warning to be shown if the \"from\" option is defined; the defined value can be used in the \"mergeFn\" to set the \"to\" value. This function can be used to change an option into another that has a different type. \"mergeFn\" takes the module \"config\" as a parameter and must return a value of \"to\" option type. mkChangedOptionModule [ \"a\" \"b\" \"c\" ] [ \"x\" \"y\" \"z\" ] (config: let value = getAttrFromPath [ \"a\" \"b\" \"c\" ] config; in if value &gt; 100 then \"high\" else \"normal\"). options.a.b.c is a removed int option. options.x.y.z is a new str option that supersedes a.b.c This show a warning if a.b.c is set, and set the value of x.y.z to the result of the change function. Arguments. [from] [to] [changeFn] Edit source. Noogle also knows. Aliases. lib.mkChangedOptionModule.",
    "raw_url": "/f/lib/modules/mkChangedOptionModule.html",
    "excerpt": "lib.modules.mkChangedOptionModule. Single \"from\" version of mkMergedOptionModule. Return a module that causes a warning to be shown if the \"from\" option is defined; the defined value can be used in the",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkBefore.html",
    "content": "lib.modules.mkBefore. Noogle also knows. Aliases. lib.mkBefore.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkBefore"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkBefore. Noogle also knows. Aliases. lib.mkBefore.",
    "raw_url": "/f/lib/modules/mkBefore.html",
    "excerpt": "lib.modules.mkBefore. Noogle also knows. Aliases. lib.mkBefore.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkVMOverride.html",
    "content": "lib.modules.mkVMOverride. Noogle also knows. Aliases. lib.mkVMOverride.",
    "word_count": 6,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkVMOverride"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkVMOverride. Noogle also knows. Aliases. lib.mkVMOverride.",
    "raw_url": "/f/lib/modules/mkVMOverride.html",
    "excerpt": "lib.modules.mkVMOverride. Noogle also knows. Aliases. lib.mkVMOverride.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkRemovedOptionModule.html",
    "content": "lib.modules.mkRemovedOptionModule. Return a module that causes a warning to be shown if the specified option is defined. For example, mkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"\" causes a assertion if the user defines boot.loader.grub.bootDevice. replacementInstructions is a string that provides instructions on how to achieve the same functionality without the removed option, or alternatively a reasoning why the functionality is not needed. replacementInstructions SHOULD be provided! Arguments. [optionName] [replacementInstructions] Edit source. Noogle also knows. Aliases. lib.mkRemovedOptionModule.",
    "word_count": 77,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkRemovedOptionModule"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 67
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkRemovedOptionModule. Return a module that causes a warning to be shown if the specified option is defined. For example, mkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"\" causes a assertion if the user defines boot.loader.grub.bootDevice. replacementInstructions is a string that provides instructions on how to achieve the same functionality without the removed option, or alternatively a reasoning why the functionality is not needed. replacementInstructions SHOULD be provided! Arguments. [optionName] [replacementInstructions] Edit source. Noogle also knows. Aliases. lib.mkRemovedOptionModule.",
    "raw_url": "/f/lib/modules/mkRemovedOptionModule.html",
    "excerpt": "lib.modules.mkRemovedOptionModule. Return a module that causes a warning to be shown if the specified option is defined. For example, mkRemovedOptionModule [ \"boot\" \"loader\" \"grub\" \"bootDevice\" ] \"\" causes a assertion",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/mkIf.html",
    "content": "lib.modules.mkIf. Properties. Arguments. [condition] [content] Edit source. Noogle also knows. Aliases. lib.mkIf.",
    "word_count": 12,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.mkIf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 2
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.mkIf. Properties. Arguments. [condition] [content] Edit source. Noogle also knows. Aliases. lib.mkIf.",
    "raw_url": "/f/lib/modules/mkIf.html",
    "excerpt": "lib.modules.mkIf. Properties. Arguments. [condition] [content] Edit source. Noogle also knows. Aliases. lib.mkIf.",
    "sub_results": []
  },
  {
    "url": "/f/lib/modules/collectModules.html",
    "content": "lib.modules.collectModules. Edit source.",
    "word_count": 3,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modules.collectModules"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modules.collectModules. Edit source.",
    "raw_url": "/f/lib/modules/collectModules.html",
    "excerpt": "lib.modules.collectModules. Edit source.",
    "sub_results": []
  },
  {
    "url": "/f/lib/toList.html",
    "content": "lib.toList. If argument is a list, return it; else, wrap it in a singleton list. If you're using this, you should almost certainly reconsider if there isn't a more \"well-typed\" approach. Example. toList [ 1 2 ] => [ 1 2 ] toList \"hi\" => [ \"hi \"] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.lists.toList.",
    "word_count": 57,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.toList"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 31
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 48
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.toList. If argument is a list, return it; else, wrap it in a singleton list. If you're using this, you should almost certainly reconsider if there isn't a more \"well-typed\" approach. Example. toList [ 1 2 ] =&gt; [ 1 2 ] toList \"hi\" =&gt; [ \"hi \"] Arguments. [x] Edit source. Noogle also knows. Aliases. lib.lists.toList.",
    "raw_url": "/f/lib/toList.html",
    "excerpt": "lib.toList. If argument is a list, return it; else, wrap it in a singleton list. If you're using this, you should almost certainly reconsider if there isn't a more \"well-typed\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkIf.html",
    "content": "lib.mkIf. Properties. Arguments. [condition] [content] Edit source. Noogle also knows. Aliases. lib.modules.mkIf.",
    "word_count": 12,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkIf"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 2
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkIf. Properties. Arguments. [condition] [content] Edit source. Noogle also knows. Aliases. lib.modules.mkIf.",
    "raw_url": "/f/lib/mkIf.html",
    "excerpt": "lib.mkIf. Properties. Arguments. [condition] [content] Edit source. Noogle also knows. Aliases. lib.modules.mkIf.",
    "sub_results": []
  },
  {
    "url": "/f/lib/fullDepEntry.html",
    "content": "lib.fullDepEntry. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.fullDepEntry.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.fullDepEntry"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.fullDepEntry. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.fullDepEntry.",
    "raw_url": "/f/lib/fullDepEntry.html",
    "excerpt": "lib.fullDepEntry. Edit source. Noogle also knows. Aliases. lib.stringsWithDeps.fullDepEntry.",
    "sub_results": []
  },
  {
    "url": "/f/lib/setFunctionArgs.html",
    "content": "lib.setFunctionArgs. Add metadata about expected function arguments to a function. The metadata should match the format given by builtins.functionArgs, i.e. a set from expected argument to a bool representing whether that argument has a default or not. setFunctionArgs : (a → b) → Map String Bool → (a → b) This function is necessary because you can't dynamically create a function of the { a, b ? foo, ... }: format, but some facilities like callPackage expect to be able to query expected arguments. Arguments. [f] [args] Edit source. Noogle also knows. Aliases. lib.trivial.setFunctionArgs.",
    "word_count": 94,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.setFunctionArgs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 84
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.setFunctionArgs. Add metadata about expected function arguments to a function. The metadata should match the format given by builtins.functionArgs, i.e. a set from expected argument to a bool representing whether that argument has a default or not. setFunctionArgs : (a → b) → Map String Bool → (a → b) This function is necessary because you can't dynamically create a function of the { a, b ? foo, ... }: format, but some facilities like callPackage expect to be able to query expected arguments. Arguments. [f] [args] Edit source. Noogle also knows. Aliases. lib.trivial.setFunctionArgs.",
    "raw_url": "/f/lib/setFunctionArgs.html",
    "excerpt": "lib.setFunctionArgs. Add metadata about expected function arguments to a function. The metadata should match the format given by builtins.functionArgs, i.e. a set from expected argument to a bool representing whether",
    "sub_results": []
  },
  {
    "url": "/f/lib/catAttrs.html",
    "content": "lib.catAttrs Primop. Takes 2 arguments. attr, list. Collect each attribute named attr from a list of attribute sets. Sets that don't contain the named attribute are ignored. Example. catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}] => [1 2] Type. catAttrs :: String -> [AttrSet] -> [Any] Edit source. Noogle also knows. Aliases. builtins.catAttrs. lib.attrsets.catAttrs.",
    "word_count": 58,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.catAttrs Primop."
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 27
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 42
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.catAttrs Primop. Takes 2 arguments. attr, list. Collect each attribute named attr from a list of attribute sets. Sets that don't contain the named attribute are ignored. Example. catAttrs \"a\" [{a = 1;} {b = 0;} {a = 2;}] =&gt; [1 2] Type. catAttrs :: String -&gt; [AttrSet] -&gt; [Any] Edit source. Noogle also knows. Aliases. builtins.catAttrs. lib.attrsets.catAttrs.",
    "raw_url": "/f/lib/catAttrs.html",
    "excerpt": "lib.catAttrs Primop. Takes 2 arguments. attr, list. Collect each attribute named attr from a list of attribute sets. Sets that don't contain the named attribute are ignored. Example. catAttrs \"a\"",
    "sub_results": []
  },
  {
    "url": "/f/lib/modifySumArgs.html",
    "content": "lib.modifySumArgs. Edit source. Noogle also knows. Aliases. lib.misc.modifySumArgs.",
    "word_count": 8,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.modifySumArgs"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.modifySumArgs. Edit source. Noogle also knows. Aliases. lib.misc.modifySumArgs.",
    "raw_url": "/f/lib/modifySumArgs.html",
    "excerpt": "lib.modifySumArgs. Edit source. Noogle also knows. Aliases. lib.misc.modifySumArgs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/concatStrings.html",
    "content": "lib.concatStrings. Concatenate a list of strings. Example. concatStrings [\"foo\" \"bar\"] => \"foobar\" Type. concatStrings :: [string] -> string Edit source. Noogle also knows. Aliases. lib.strings.concatStrings.",
    "word_count": 25,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.concatStrings"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 6
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.concatStrings. Concatenate a list of strings. Example. concatStrings [\"foo\" \"bar\"] =&gt; \"foobar\" Type. concatStrings :: [string] -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.concatStrings.",
    "raw_url": "/f/lib/concatStrings.html",
    "excerpt": "lib.concatStrings. Concatenate a list of strings. Example. concatStrings [\"foo\" \"bar\"] =&gt; \"foobar\" Type. concatStrings :: [string] -&gt; string Edit source. Noogle also knows. Aliases. lib.strings.concatStrings.",
    "sub_results": []
  },
  {
    "url": "/f/lib/dontRecurseIntoAttrs.html",
    "content": "lib.dontRecurseIntoAttrs. Undo the effect of recurseIntoAttrs. Type. dontRecurseIntoAttrs :: AttrSet -> AttrSet Arguments. [attrs] An attribute set to not scan for derivations. Edit source. Noogle also knows. Aliases. lib.attrsets.dontRecurseIntoAttrs. pkgs.dontRecurseIntoAttrs.",
    "word_count": 30,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.dontRecurseIntoAttrs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 6
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 12
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.dontRecurseIntoAttrs. Undo the effect of recurseIntoAttrs. Type. dontRecurseIntoAttrs :: AttrSet -&gt; AttrSet Arguments. [attrs] An attribute set to not scan for derivations. Edit source. Noogle also knows. Aliases. lib.attrsets.dontRecurseIntoAttrs. pkgs.dontRecurseIntoAttrs.",
    "raw_url": "/f/lib/dontRecurseIntoAttrs.html",
    "excerpt": "lib.dontRecurseIntoAttrs. Undo the effect of recurseIntoAttrs. Type. dontRecurseIntoAttrs :: AttrSet -&gt; AttrSet Arguments. [attrs] An attribute set to not scan for derivations. Edit source. Noogle also knows. Aliases. lib.attrsets.dontRecurseIntoAttrs. pkgs.dontRecurseIntoAttrs.",
    "sub_results": []
  },
  {
    "url": "/f/lib/zipListsWith.html",
    "content": "lib.zipListsWith. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. How both lists are merged is defined by the first argument. Example. zipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"] => [\"he\" \"lo\"] Type. zipListsWith :: (a -> b -> c) -> [a] -> [b] -> [c] Arguments. [f] Function to zip elements of both lists. [fst] First list. [snd] Second list. Edit source. Noogle also knows. Aliases. lib.lists.zipListsWith.",
    "word_count": 82,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.zipListsWith"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 32
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 46
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 60
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.zipListsWith. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. How both lists are merged is defined by the first argument. Example. zipListsWith (a: b: a + b) [\"h\" \"l\"] [\"e\" \"o\"] =&gt; [\"he\" \"lo\"] Type. zipListsWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c] Arguments. [f] Function to zip elements of both lists. [fst] First list. [snd] Second list. Edit source. Noogle also knows. Aliases. lib.lists.zipListsWith.",
    "raw_url": "/f/lib/zipListsWith.html",
    "excerpt": "lib.zipListsWith. Merges two lists of the same size together. If the sizes aren't the same the merging stops at the shortest. How both lists are merged is defined by the",
    "sub_results": []
  },
  {
    "url": "/f/lib/mirrorFunctionArgs.html",
    "content": "lib.mirrorFunctionArgs. mirrorFunctionArgs f g creates a new function g' with the same behavior as g (g' x == g x) but its function arguments mirroring f (lib.functionArgs g' == lib.functionArgs f). Example. addab = {a, b}: a + b addab { a = 2; b = 4; } => 6 lib.functionArgs addab => { a = false; b = false; } addab1 = attrs: addab attrs + 1 addab1 { a = 2; b = 4; } => 7 lib.functionArgs addab1 => { } addab1' = lib.mirrorFunctionArgs addab addab1 addab1' { a = 2; b = 4; } => 7 lib.functionArgs addab1' => { a = false; b = false; } Type. mirrorFunctionArgs :: (a -> b) -> (a -> c) -> (a -> c) Arguments. [f] Function to provide the argument metadata. Edit source. Noogle also knows. Aliases. lib.trivial.mirrorFunctionArgs.",
    "word_count": 140,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mirrorFunctionArgs"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 31
      },
      {
        "element": "h2",
        "id": "type",
        "text": "Type",
        "location": 111
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 125
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mirrorFunctionArgs. mirrorFunctionArgs f g creates a new function g' with the same behavior as g (g' x == g x) but its function arguments mirroring f (lib.functionArgs g' == lib.functionArgs f). Example. addab = {a, b}: a + b addab { a = 2; b = 4; } =&gt; 6 lib.functionArgs addab =&gt; { a = false; b = false; } addab1 = attrs: addab attrs + 1 addab1 { a = 2; b = 4; } =&gt; 7 lib.functionArgs addab1 =&gt; { } addab1' = lib.mirrorFunctionArgs addab addab1 addab1' { a = 2; b = 4; } =&gt; 7 lib.functionArgs addab1' =&gt; { a = false; b = false; } Type. mirrorFunctionArgs :: (a -&gt; b) -&gt; (a -&gt; c) -&gt; (a -&gt; c) Arguments. [f] Function to provide the argument metadata. Edit source. Noogle also knows. Aliases. lib.trivial.mirrorFunctionArgs.",
    "raw_url": "/f/lib/mirrorFunctionArgs.html",
    "excerpt": "lib.mirrorFunctionArgs. mirrorFunctionArgs f g creates a new function g' with the same behavior as g (g' x == g x) but its function arguments mirroring f (lib.functionArgs g' == lib.functionArgs",
    "sub_results": []
  },
  {
    "url": "/f/lib/isInt.html",
    "content": "lib.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. builtins.isInt. lib.strings.isInt. lib.trivial.isInt.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.isInt Primop."
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. builtins.isInt. lib.strings.isInt. lib.trivial.isInt.",
    "raw_url": "/f/lib/isInt.html",
    "excerpt": "lib.isInt Primop. Takes 1 arguments. e. Return true if e evaluates to an integer, and false otherwise. Noogle also knows. Aliases. builtins.isInt. lib.strings.isInt. lib.trivial.isInt.",
    "sub_results": []
  },
  {
    "url": "/f/lib/mkPackageOptionMD.html",
    "content": "lib.mkPackageOptionMD. Alias of mkPackageOption. Previously used to create options with markdown documentation, which is no longer required. Edit source. Noogle also knows. Aliases. lib.options.mkPackageOptionMD.",
    "word_count": 24,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.mkPackageOptionMD"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.mkPackageOptionMD. Alias of mkPackageOption. Previously used to create options with markdown documentation, which is no longer required. Edit source. Noogle also knows. Aliases. lib.options.mkPackageOptionMD.",
    "raw_url": "/f/lib/mkPackageOptionMD.html",
    "excerpt": "lib.mkPackageOptionMD. Alias of mkPackageOption. Previously used to create options with markdown documentation, which is no longer required. Edit source. Noogle also knows. Aliases. lib.options.mkPackageOptionMD.",
    "sub_results": []
  },
  {
    "url": "/f/lib/groupBy'.html",
    "content": "lib.groupBy' (Prime). Splits the elements of a list into many lists, using the return value of a predicate. Predicate should return a string which becomes keys of attrset groupBy returns. groupBy' allows to customise the combining function and initial value. Example. groupBy (x: boolToString (x > 2)) [ 5 1 2 3 4 ] => { true = [ 5 3 4 ]; false = [ 1 2 ]; } groupBy (x: x.name) [ {name = \"icewm\"; script = \"icewm &\";} {name = \"xfce\"; script = \"xfce4-session &\";} {name = \"icewm\"; script = \"icewmbg &\";} {name = \"mate\"; script = \"gnome-session &\";} ] => { icewm = [ { name = \"icewm\"; script = \"icewm &\"; } { name = \"icewm\"; script = \"icewmbg &\"; } ]; mate = [ { name = \"mate\"; script = \"gnome-session &\"; } ]; xfce = [ { name = \"xfce\"; script = \"xfce4-session &\"; } ]; } groupBy' builtins.add 0 (x: boolToString (x > 2)) [ 5 1 2 3 4 ] => { true = 12; false = 3; } Arguments. [op] [nul] [pred] [lst] Edit source. Noogle also knows. Aliases. lib.lists.groupBy'",
    "word_count": 190,
    "filters": {
      "type-to": ["Any"],
      "type-from": ["Any"]
    },
    "meta": {
      "title": "lib.groupBy' (Prime)"
    },
    "anchors": [
      {
        "element": "h2",
        "id": "example",
        "text": "Example",
        "location": 40
      },
      {
        "element": "h2",
        "id": "arguments",
        "text": "Arguments",
        "location": 178
      }
    ],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "lib.groupBy' (Prime). Splits the elements of a list into many lists, using the return value of a predicate. Predicate should return a string which becomes keys of attrset groupBy returns. groupBy' allows to customise the combining function and initial value. Example. groupBy (x: boolToString (x &gt; 2)) [ 5 1 2 3 4 ] =&gt; { true = [ 5 3 4 ]; false = [ 1 2 ]; } groupBy (x: x.name) [ {name = \"icewm\"; script = \"icewm &\";} {name = \"xfce\"; script = \"xfce4-session &\";} {name = \"icewm\"; script = \"icewmbg &\";} {name = \"mate\"; script = \"gnome-session &\";} ] =&gt; { icewm = [ { name = \"icewm\"; script = \"icewm &\"; } { name = \"icewm\"; script = \"icewmbg &\"; } ]; mate = [ { name = \"mate\"; script = \"gnome-session &\"; } ]; xfce = [ { name = \"xfce\"; script = \"xfce4-session &\"; } ]; } groupBy' builtins.add 0 (x: boolToString (x &gt; 2)) [ 5 1 2 3 4 ] =&gt; { true = 12; false = 3; } Arguments. [op] [nul] [pred] [lst] Edit source. Noogle also knows. Aliases. lib.lists.groupBy'",
    "raw_url": "/f/lib/groupBy'.html",
    "excerpt": "lib.groupBy' (Prime). Splits the elements of a list into many lists, using the return value of a predicate. Predicate should return a string which becomes keys of attrset groupBy returns.",
    "sub_results": []
  },
  {
    "url": "/",
    "content": "N::oogle |> Function of the day. lib.modules.mergeOptionDecls. Merge multiple option declarations into a single declaration. In general, there should be only one declaration of each option. The exception is the ‘options’ attribute, which specifies sub-options. These can be specified multiple times to allow one module to add sub-options to an option declared somewhere else (e.g. multiple modules define sub-options for ‘fileSystems’). 'loc' is the list of attribute names where the option is located. 'opts' is a list of modules. Each module has an options attribute which correspond to the definition of 'loc' in 'opt.file'. Arguments. [loc] [opts] PrevRandomTodays functionNext.",
    "word_count": 99,
    "filters": {},
    "meta": {
      "title": "N::oogle |>"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "N::oogle |&gt; Function of the day. lib.modules.mergeOptionDecls. Merge multiple option declarations into a single declaration. In general, there should be only one declaration of each option. The exception is the ‘options’ attribute, which specifies sub-options. These can be specified multiple times to allow one module to add sub-options to an option declared somewhere else (e.g. multiple modules define sub-options for ‘fileSystems’). 'loc' is the list of attribute names where the option is located. 'opts' is a list of modules. Each module has an options attribute which correspond to the definition of 'loc' in 'opt.file'. Arguments. [loc] [opts] PrevRandomTodays functionNext.",
    "raw_url": "/",
    "excerpt": "N::oogle |&gt; Function of the day. lib.modules.mergeOptionDecls. Merge multiple option declarations into a single declaration. In general, there should be only one declaration of each option. The exception is the",
    "sub_results": []
  },
  {
    "url": "/404.html",
    "content": "404. This page could not be found.",
    "word_count": 7,
    "filters": {},
    "meta": {
      "title": "404"
    },
    "anchors": [],
    "weighted_locations": [],
    "locations": [],
    "raw_content": "404. This page could not be found.",
    "raw_url": "/404.html",
    "excerpt": "404. This page could not be found.",
    "sub_results": []
  }
]
