# Contribute to noogle

# Documentation Guide.

- Describe what the function does.
- Provide examples for different scenarios when this function might be useful. -> ` # Example(s) `
- Provide a (single) type signature -> `# Type `
  - What types does the function expect?
  - Try to follow the [typednix](https://typednix.dev) convention for best compatibility with noogle
- Describe the purpose of all arguments.-> `# Arguments`
  - Positional Arguments
  - Attributes
- Maybe describe edge cases or what else should be taken into account
- References to other functions

# How References (will) work

Noogle uses tagref. For rendering and source agnostic references.

Every lambda is tagged by automatically with `[tag:name]`.
e.g. `lib.lists.count` is tagged with `[tag:lib.lists.count]`.

Reference to `lib.lists.count` can appear everywhere.

e.g.

```md

See [ref:lib.lists.count]

```

This will be rendered into

> ...  
>
> See <a href="/f/lib/lists/count">lib.lists.count</a>
 

## Understanding how noogle uses doc-comments

As specified per RFC-145. Doc-comments use `/** */` syntax. There are rules for the relationship beteween a doc-comment and the static expression.

```nix
# simple.nix
{
  /** 
    Markdown
  */
  mapThings = x: x;
}
```

Usually the nix compiler uses an expression to produce some value. The relationship between expression and value is non trivial.

Expression ( let a = 1; in a ) -> Value(1)

Some Values have source position tracking, which means they know the original nix file (line & cloumn), where they came from.

Noogle uses this source position tracking to move in the other direction. From Value to SourcePosition.

Value(Lambda) -> Expression( let id = x: x; in id)

From a given Expression position we can now do a static lookup and extract the doc-comment.

```nix
# source.nix
let 
  /**
   Docs
  */
  id = x: x; 
in id
```

## How aliases work

Considering the following three files, that represent how the lib functions in `nixpkgs.lib` are aliased.

```nix
# ops.nix
{
  /** 
    Docs for do
  */
  do = x: x;
}
```

```nix
# lib.nix
let
  ops = import ./ops.nix;
in
{
  lib = {
    inherit ops;
    inherit (ops) do;
  };
}
```

When evaluating the `lib.nix` file we end up with

```nix
nix-repl> { lib = { ops = { do = <lambda @ ops.nix>; }, do = <lambda @ ops.nix>; } } 
```

We can observe that both lambdas point to the exact same SourcePosition in `ops.nix`

This is basically how aliases are detected. It gets a little more complex with primops and partially applied lambdas.
