[{"id":"build-support.trivial-builders.runCommand","category":"./pkgs/build-support/trivial-builders.nix","name":"runCommand","fn_type":null,"description":[" Run the shell command `buildCommand' to produce a store path named\n  * `name'.  The attributes in `env' are added to the environment\n  * prior to running the command. By default `runCommand` runs in a\n  * stdenv with no compiler environment. `runCommandCC` uses the default\n  * stdenv, `pkgs.stdenv`.\n  *\n  * Examples:\n  * runCommand \"name\" {envVariable = true;} ''echo hello > $out''\n  * runCommandCC \"name\" {} ''gcc -o myfile myfile.c; cp myfile $out'';\n  *\n  * The `*Local` variants force a derivation to be built locally,\n  * it is not substituted.\n  *\n  * This is intended for very cheap commands (<1s execution time).\n  * It saves on the network roundrip and can speed up a build.\n  *\n  * It is the same as adding the special fields\n  * `preferLocalBuild = true;`\n  * `allowSubstitutes = false;`\n  * to a derivation’s attributes.",""],"example":null},{"id":"build-support.trivial-builders.runCommandWith","category":"./pkgs/build-support/trivial-builders.nix","name":"runCommandWith","fn_type":null,"description":[" Generalized version of the `runCommand`-variants\n   * which does customized behavior via a single\n   * attribute set passed as the first argument\n   * instead of having a lot of variants like\n   * `runCommand*`. Additionally it allows changing\n   * the used `stdenv` freely and has a more explicit\n   * approach to changing the arguments passed to\n   * `stdenv.mkDerivation`.",""],"example":null},{"id":"build-support.trivial-builders.writeTextFile","category":"./pkgs/build-support/trivial-builders.nix","name":"writeTextFile","fn_type":null,"description":[" Writes a text file to the nix store.\n   * The contents of text is added to the file in the store.\n   *\n   * Examples:\n   * # Writes my-file to /nix/store/<store path>\n   * writeTextFile {\n   *   name = \"my-file\";\n   *   text = ''\n   *     Contents of File\n   *   '';\n   * }\n   * # See also the `writeText` helper function below.\n   *\n   * # Writes executable my-file to /nix/store/<store path>/bin/my-file\n   * writeTextFile {\n   *   name = \"my-file\";\n   *   text = ''\n   *     Contents of File\n   *   '';\n   *   executable = true;\n   *   destination = \"/bin/my-file\";\n   * }",""],"example":null},{"id":"build-support.trivial-builders.writeText","category":"./pkgs/build-support/trivial-builders.nix","name":"writeText","fn_type":null,"description":["\n   * Writes a text file to nix store with no optional parameters available.\n   *\n   * Example:\n   * # Writes contents of file to /nix/store/<store path>\n   * writeText \"my-file\"\n   *   ''\n   *   Contents of File\n   *   '';\n   *",""],"example":null},{"id":"build-support.trivial-builders.writeTextDir","category":"./pkgs/build-support/trivial-builders.nix","name":"writeTextDir","fn_type":null,"description":["\n   * Writes a text file to nix store in a specific directory with no\n   * optional parameters available.\n   *\n   * Example:\n   * # Writes contents of file to /nix/store/<store path>/share/my-file\n   * writeTextDir \"share/my-file\"\n   *   ''\n   *   Contents of File\n   *   '';\n   *",""],"example":null},{"id":"build-support.trivial-builders.writeScript","category":"./pkgs/build-support/trivial-builders.nix","name":"writeScript","fn_type":null,"description":["\n   * Writes a text file to /nix/store/<store path> and marks the file as\n   * executable.\n   *\n   * If passed as a build input, will be used as a setup hook. This makes setup\n   * hooks more efficient to create: you don't need a derivation that copies\n   * them to $out/nix-support/setup-hook, instead you can use the file as is.\n   *\n   * Example:\n   * # Writes my-file to /nix/store/<store path> and makes executable\n   * writeScript \"my-file\"\n   *   ''\n   *   Contents of File\n   *   '';\n   *",""],"example":null},{"id":"build-support.trivial-builders.writeScriptBin","category":"./pkgs/build-support/trivial-builders.nix","name":"writeScriptBin","fn_type":null,"description":["\n   * Writes a text file to /nix/store/<store path>/bin/<name> and\n   * marks the file as executable.\n   *\n   * Example:\n   * # Writes my-file to /nix/store/<store path>/bin/my-file and makes executable.\n   * writeScriptBin \"my-file\"\n   *   ''\n   *   Contents of File\n   *   '';\n   *",""],"example":null},{"id":"build-support.trivial-builders.writeShellScript","category":"./pkgs/build-support/trivial-builders.nix","name":"writeShellScript","fn_type":null,"description":["\n   * Similar to writeScript. Writes a Shell script and checks its syntax.\n   * Automatically includes interpreter above the contents passed.\n   *\n   * Example:\n   * # Writes my-file to /nix/store/<store path> and makes executable.\n   * writeShellScript \"my-file\"\n   *   ''\n   *   Contents of File\n   *   '';\n   *",""],"example":null},{"id":"build-support.trivial-builders.writeShellScriptBin","category":"./pkgs/build-support/trivial-builders.nix","name":"writeShellScriptBin","fn_type":null,"description":["\n   * Similar to writeShellScript and writeScriptBin.\n   * Writes an executable Shell script to /nix/store/<store path>/bin/<name> and checks its syntax.\n   * Automatically includes interpreter above the contents passed.\n   *\n   * Example:\n   * # Writes my-file to /nix/store/<store path>/bin/my-file and makes executable.\n   * writeShellScriptBin \"my-file\"\n   *   ''\n   *   Contents of File\n   *   '';\n   *",""],"example":null},{"id":"build-support.trivial-builders.writeShellApplication","category":"./pkgs/build-support/trivial-builders.nix","name":"writeShellApplication","fn_type":null,"description":["\n   * Similar to writeShellScriptBin and writeScriptBin.\n   * Writes an executable Shell script to /nix/store/<store path>/bin/<name> and\n   * checks its syntax with shellcheck and the shell's -n option.\n   * Automatically includes sane set of shellopts (errexit, nounset, pipefail)\n   * and handles creation of PATH based on runtimeInputs\n   *\n   * Note that the checkPhase uses stdenv.shell for the test run of the script,\n   * while the generated shebang uses runtimeShell. If, for whatever reason,\n   * those were to mismatch you might lose fidelity in the default checks.\n   *\n   * Example:\n   * # Writes my-file to /nix/store/<store path>/bin/my-file and makes executable.\n   * writeShellApplication {\n   *   name = \"my-file\";\n   *   runtimeInputs = [ curl w3m ];\n   *   text = ''\n   *     curl -s 'https://nixos.org' | w3m -dump -T text/html\n   *    '';\n   * }",""],"example":null},{"id":"build-support.trivial-builders.concatTextFile","category":"./pkgs/build-support/trivial-builders.nix","name":"concatTextFile","fn_type":null,"description":[" concat a list of files to the nix store.\n   * The contents of files are added to the file in the store.\n   *\n   * Examples:\n   * # Writes my-file to /nix/store/<store path>\n   * concatTextFile {\n   *   name = \"my-file\";\n   *   files = [ drv1 \"${drv2}/path/to/file\" ];\n   * }\n   * # See also the `concatText` helper function below.\n   *\n   * # Writes executable my-file to /nix/store/<store path>/bin/my-file\n   * concatTextFile {\n   *   name = \"my-file\";\n   *   files = [ drv1 \"${drv2}/path/to/file\" ];\n   *   executable = true;\n   *   destination = \"/bin/my-file\";\n   * }",""],"example":null},{"id":"build-support.trivial-builders.concatText","category":"./pkgs/build-support/trivial-builders.nix","name":"concatText","fn_type":null,"description":["\n   * Writes a text file to nix store with no optional parameters available.\n   *\n   * Example:\n   * # Writes contents of files to /nix/store/<store path>\n   * concatText \"my-file\" [ file1 file2 ]\n   *",""],"example":null},{"id":"build-support.trivial-builders.concatScript","category":"./pkgs/build-support/trivial-builders.nix","name":"concatScript","fn_type":null,"description":["\n   * Writes a text file to nix store with and mark it as executable.\n   *\n   * Example:\n   * # Writes contents of files to /nix/store/<store path>\n   * concatScript \"my-file\" [ file1 file2 ]\n   *",""],"example":null},{"id":"build-support.trivial-builders.symlinkJoin","category":"./pkgs/build-support/trivial-builders.nix","name":"symlinkJoin","fn_type":null,"description":["\n   * Create a forest of symlinks to the files in `paths'.\n   *\n   * This creates a single derivation that replicates the directory structure\n   * of all the input paths.\n   *\n   * BEWARE: it may not \"work right\" when the passed paths contain symlinks to directories.\n   *\n   * Examples:\n   * # adds symlinks of hello to current build.\n   * symlinkJoin { name = \"myhello\"; paths = [ pkgs.hello ]; }\n   *\n   * # adds symlinks of hello and stack to current build and prints \"links added\"\n   * symlinkJoin { name = \"myexample\"; paths = [ pkgs.hello pkgs.stack ]; postBuild = \"echo links added\"; }\n   *\n   * This creates a derivation with a directory structure like the following:\n   *\n   * /nix/store/sglsr5g079a5235hy29da3mq3hv8sjmm-myexample\n   * |-- bin\n   * |   |-- hello -> /nix/store/qy93dp4a3rqyn2mz63fbxjg228hffwyw-hello-2.10/bin/hello\n   * |   `-- stack -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/bin/stack\n   * `-- share\n   *     |-- bash-completion\n   *     |   `-- completions\n   *     |       `-- stack -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/share/bash-completion/completions/stack\n   *     |-- fish\n   *     |   `-- vendor_completions.d\n   *     |       `-- stack.fish -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1/share/fish/vendor_completions.d/stack.fish\n   * ...\n   *\n   * symlinkJoin and linkFarm are similar functions, but they output\n   * derivations with different structure.\n   *\n   * symlinkJoin is used to create a derivation with a familiar directory\n   * structure (top-level bin/, share/, etc), but with all actual files being symlinks to\n   * the files in the input derivations.\n   *\n   * symlinkJoin is used many places in nixpkgs to create a single derivation\n   * that appears to contain binaries, libraries, documentation, etc from\n   * multiple input derivations.\n   *\n   * linkFarm is instead used to create a simple derivation with symlinks to\n   * other derivations.  A derivation created with linkFarm is often used in CI\n   * as a easy way to build multiple derivations at once.",""],"example":null},{"id":"build-support.trivial-builders.linkFarm","category":"./pkgs/build-support/trivial-builders.nix","name":"linkFarm","fn_type":null,"description":["\n   * Quickly create a set of symlinks to derivations.\n   *\n   * This creates a simple derivation with symlinks to all inputs.\n   *\n   * entries can be a list of attribute sets like\n   * [ { name = \"name\" ; path = \"/nix/store/...\"; } ]\n   *\n   * or an attribute set name -> path like:\n   * { name = \"/nix/store/...\"; other = \"/nix/store/...\"; }\n   *\n   * Example:\n   *\n   * # Symlinks hello and stack paths in store to current $out/hello-test and\n   * # $out/foobar.\n   * linkFarm \"myexample\" [ { name = \"hello-test\"; path = pkgs.hello; } { name = \"foobar\"; path = pkgs.stack; } ]\n   *\n   * This creates a derivation with a directory structure like the following:\n   *\n   * /nix/store/qc5728m4sa344mbks99r3q05mymwm4rw-myexample\n   * |-- foobar -> /nix/store/6lzdpxshx78281vy056lbk553ijsdr44-stack-2.1.3.1\n   * `-- hello-test -> /nix/store/qy93dp4a3rqyn2mz63fbxjg228hffwyw-hello-2.10\n   *\n   * See the note on symlinkJoin for the difference between linkFarm and symlinkJoin.",""],"example":null},{"id":"build-support.trivial-builders.linkFarmFromDrvs","category":"./pkgs/build-support/trivial-builders.nix","name":"linkFarmFromDrvs","fn_type":null,"description":["\n   * Easily create a linkFarm from a set of derivations.\n   *\n   * This calls linkFarm with a list of entries created from the list of input\n   * derivations.  It turns each input derivation into an attribute set\n   * like { name = drv.name ; path = drv }, and passes this to linkFarm.\n   *\n   * Example:\n   *\n   * # Symlinks the hello, gcc, and ghc derivations in $out\n   * linkFarmFromDrvs \"myexample\" [ pkgs.hello pkgs.gcc pkgs.ghc ]\n   *\n   * This creates a derivation with a directory structure like the following:\n   *\n   * /nix/store/m3s6wkjy9c3wy830201bqsb91nk2yj8c-myexample\n   * |-- gcc-wrapper-9.2.0 -> /nix/store/fqhjxf9ii4w4gqcsx59fyw2vvj91486a-gcc-wrapper-9.2.0\n   * |-- ghc-8.6.5 -> /nix/store/gnf3s07bglhbbk4y6m76sbh42siym0s6-ghc-8.6.5\n   * `-- hello-2.10 -> /nix/store/k0ll91c4npk4lg8lqhx00glg2m735g74-hello-2.10",""],"example":null},{"id":"build-support.trivial-builders.makeSetupHook","category":"./pkgs/build-support/trivial-builders.nix","name":"makeSetupHook","fn_type":null,"description":["\n   * Make a package that just contains a setup hook with the given contents.\n   * This setup hook will be invoked by any package that includes this package\n   * as a buildInput. Optionally takes a list of substitutions that should be\n   * applied to the resulting script.\n   *\n   * Examples:\n   * # setup hook that depends on the hello package and runs ./myscript.sh\n   * myhellohook = makeSetupHook { deps = [ hello ]; } ./myscript.sh;\n   *\n   * # writes a Linux-exclusive setup hook where @bash@ myscript.sh is substituted for the\n   * # bash interpreter.\n   * myhellohookSub = makeSetupHook {\n   *                 deps = [ hello ];\n   *                 substitutions = { bash = \"${pkgs.bash}/bin/bash\"; };\n   *                 meta.platforms = lib.platforms.linux;\n   *               } ./myscript.sh;\n   *\n   * # setup hook with a package test\n   * myhellohookTested = makeSetupHook {\n   *                 deps = [ hello ];\n   *                 substitutions = { bash = \"${pkgs.bash}/bin/bash\"; };\n   *                 meta.platforms = lib.platforms.linux;\n   *                 passthru.tests.greeting = callPackage ./test { };\n   *               } ./myscript.sh;",""],"example":null},{"id":"build-support.trivial-builders.writeDirectReferencesToFile","category":"./pkgs/build-support/trivial-builders.nix","name":"writeDirectReferencesToFile","fn_type":null,"description":["\n    Write the set of references to a file, that is, their immediate dependencies.","    This produces the equivalent of `nix-store -q --references`.",""],"example":null},{"id":"build-support.trivial-builders.writeStringReferencesToFile","category":"./pkgs/build-support/trivial-builders.nix","name":"writeStringReferencesToFile","fn_type":null,"description":["\n   * Extract a string's references to derivations and paths (its\n   * context) and write them to a text file, removing the input string\n   * itself from the dependency graph. This is useful when you want to\n   * make a derivation depend on the string's references, but not its\n   * contents (to avoid unnecessary rebuilds, for example).\n   *\n   * Note that this only works as intended on Nix >= 2.3.",""],"example":null},{"id":"build-support.trivial-builders.requireFile","category":"./pkgs/build-support/trivial-builders.nix","name":"requireFile","fn_type":null,"description":[" Print an error message if the file with the specified name and\n   * hash doesn't exist in the Nix store. This function should only\n   * be used by non-redistributable software with an unfree license\n   * that we need to require the user to download manually. It produces\n   * packages that cannot be built automatically.\n   *\n   * Examples:\n   *\n   * requireFile {\n   *   name = \"my-file\";\n   *   url = \"http://example.com/download/\";\n   *   sha256 = \"ffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n   * }",""],"example":null},{"id":"build-support.trivial-builders.applyPatches","category":"./pkgs/build-support/trivial-builders.nix","name":"applyPatches","fn_type":null,"description":[" Applies a list of patches to a source directory.\n   *\n   * Examples:\n   *\n   * # Patching nixpkgs:\n   * applyPatches {\n   *   src = pkgs.path;\n   *   patches = [\n   *     (pkgs.fetchpatch {\n   *       url = \"https://github.com/NixOS/nixpkgs/commit/1f770d20550a413e508e081ddc08464e9d08ba3d.patch\";\n   *       sha256 = \"1nlzx171y3r3jbk0qhvnl711kmdk57jlq4na8f8bs8wz2pbffymr\";\n   *     })\n   *   ];\n   * }",""],"example":null},{"id":"build-support.trivial-builders.emptyFile","category":"./pkgs/build-support/trivial-builders.nix","name":"emptyFile","fn_type":null,"description":[" An immutable file in the store with a length of 0 bytes.\n"],"example":null},{"id":"build-support.trivial-builders.emptyDirectory","category":"./pkgs/build-support/trivial-builders.nix","name":"emptyDirectory","fn_type":null,"description":[" An immutable empty directory in the store.\n"],"example":null},{"id":"build-support.plugins.diffPlugins","category":"./pkgs/build-support/plugins.nix","name":"diffPlugins","fn_type":null,"description":[" Takes a list of expected plugin names\n   * and compares it to the found plugins given in the file,\n   * one plugin per line.\n   * If the lists differ, the build fails with a nice message.\n   *\n   * This is helpful to ensure maintainers don’t miss\n   * the addition or removal of a plugin.",""],"example":null}]