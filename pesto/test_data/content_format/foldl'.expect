[
  {
    "name": "lib.lists.foldl'",
    "content": "\nReduce a list by applying a binary operator from left to right,\nstarting with an initial accumulator.\nBefore each application of the operator, the accumulator value is evaluated.\nThis behavior makes this function stricter than [`foldl`](#function-library-lib.lists.foldl).\nUnlike [`builtins.foldl'`](https://nixos.org/manual/nix/unstable/language/builtins.html#builtins-foldl'),\nthe initial accumulator argument is evaluated before the first iteration.\n    A call like\n    ```nix\n    foldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ]\n    ```\n    is (denotationally) equivalent to the following,\n    but with the added benefit that `foldl'` itself will never overflow the stack.\n    ```nix\n    let\n    acc₁   = builtins.seq acc₀   (op acc₀   x₀  );\n    acc₂   = builtins.seq acc₁   (op acc₁   x₁  );\n    acc₃   = builtins.seq acc₂   (op acc₂   x₂  );\n    ...\n    accₙ   = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁);\n    accₙ₊₁ = builtins.seq accₙ   (op accₙ   xₙ  );\n    in\n    accₙ₊₁\n    # Or ignoring builtins.seq\n    op (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ\n    ```\n\n    # Example\n\n    ```nix\n    foldl' (acc: x: acc + x) 0 [1 2 3]\n    => 6\n    ```\n\n    # Type\n\n    ```\n    foldl' :: (acc -> x -> acc) -> acc -> [x] -> acc\n    ```\n\n    # Arguments\n\n    - [op] The binary operation to run, where the two arguments are:\n\n1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n2. `x`: The corresponding list element for this iteration\n    - [acc] The initial accumulator value\n    - [list] The list to fold\n\n"
  }
]