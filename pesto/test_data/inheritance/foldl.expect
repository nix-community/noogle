[
  {
    "name": "lib.foldl'",
    "content": "\n    Reduce a list by applying a binary operator from left to right,\n    starting with an initial accumulator.\n    Before each application of the operator, the accumulator value is evaluated.\n    This behavior makes this function stricter than [`foldl`](#function-library-lib.lists.foldl).\n    Unlike [`builtins.foldl'`](https://nixos.org/manual/nix/unstable/language/builtins.html#builtins-foldl'),\n    the initial accumulator argument is evaluated before the first iteration.\n    A call like\n    ```nix\n    foldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ]\n    ```\n    is (denotationally) equivalent to the following,\n    but with the added benefit that `foldl'` itself will never overflow the stack.\n    ```nix\n    let\n    acc₁   = builtins.seq acc₀   (op acc₀   x₀  );\n    acc₂   = builtins.seq acc₁   (op acc₁   x₁  );\n    acc₃   = builtins.seq acc₂   (op acc₂   x₂  );\n    ...\n    accₙ   = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁);\n    accₙ₊₁ = builtins.seq accₙ   (op accₙ   xₙ  );\n    in\n    accₙ₊₁\n    # Or ignoring builtins.seq\n    op (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ\n    ```\n\n    # Example\n\n    ```nix\n    foldl' (acc: x: acc + x) 0 [1 2 3]\n    => 6\n    ```\n\n    # Type\n\n    ```\n    foldl' :: (acc -> x -> acc) -> acc -> [x] -> acc\n    ```\n\n    # Arguments\n\n    - [op] The binary operation to run, where the two arguments are:\n\n1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n2. `x`: The corresponding list element for this iteration\n    - [acc] The initial accumulator value\n    - [list] The list to fold\n\n  ",
    "source": "lib.lists.foldl'"
  },
  {
    "name": "lib.lists.foldl'",
    "content": "\n    Reduce a list by applying a binary operator from left to right,\n    starting with an initial accumulator.\n    Before each application of the operator, the accumulator value is evaluated.\n    This behavior makes this function stricter than [`foldl`](#function-library-lib.lists.foldl).\n    Unlike [`builtins.foldl'`](https://nixos.org/manual/nix/unstable/language/builtins.html#builtins-foldl'),\n    the initial accumulator argument is evaluated before the first iteration.\n    A call like\n    ```nix\n    foldl' op acc₀ [ x₀ x₁ x₂ ... xₙ₋₁ xₙ ]\n    ```\n    is (denotationally) equivalent to the following,\n    but with the added benefit that `foldl'` itself will never overflow the stack.\n    ```nix\n    let\n    acc₁   = builtins.seq acc₀   (op acc₀   x₀  );\n    acc₂   = builtins.seq acc₁   (op acc₁   x₁  );\n    acc₃   = builtins.seq acc₂   (op acc₂   x₂  );\n    ...\n    accₙ   = builtins.seq accₙ₋₁ (op accₙ₋₁ xₙ₋₁);\n    accₙ₊₁ = builtins.seq accₙ   (op accₙ   xₙ  );\n    in\n    accₙ₊₁\n    # Or ignoring builtins.seq\n    op (op (... (op (op (op acc₀ x₀) x₁) x₂) ...) xₙ₋₁) xₙ\n    ```\n\n    # Example\n\n    ```nix\n    foldl' (acc: x: acc + x) 0 [1 2 3]\n    => 6\n    ```\n\n    # Type\n\n    ```\n    foldl' :: (acc -> x -> acc) -> acc -> [x] -> acc\n    ```\n\n    # Arguments\n\n    - [op] The binary operation to run, where the two arguments are:\n\n1. `acc`: The current accumulator value: Either the initial one for the first iteration, or the result of the previous iteration\n2. `x`: The corresponding list element for this iteration\n    - [acc] The initial accumulator value\n    - [list] The list to fold\n\n  ",
    "source": "lib.lists.foldl'"
  },
  {
    "name": "builtins.foldl'",
    "content": "\n      Reduce a list by applying a binary operator, from left to right,\n      e.g. `foldl' op nul [x0 x1 x2 ...] : op (op (op nul x0) x1) x2)\n      ...`. For example, `foldl' (x: y: x + y) 0 [1 2 3]` evaluates to 6.\n      The return value of each application of `op` is evaluated immediately,\n      even for intermediate values.\n    ",
    "source": "builtins.foldl'"
  }
]